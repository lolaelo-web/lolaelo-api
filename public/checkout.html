<!DOCTYPE html>
<html lang="en">
<head>
<link rel="icon" href="/images/logo2.png" />
  <meta charset="UTF-8" />
  <title>Lolaelo - Checkout</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
    rel="stylesheet"
  />
  <!-- Flatpickr (calendar) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr@4.6.13/dist/flatpickr.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/flatpickr@4.6.13/dist/flatpickr.min.js"></script>

<style>
  /* =========================================================
     CHECKOUT BASE THEME + LAYOUT (CANONICAL)
     - Drop-in replacement for the entire block you pasted
     - Removes duplicate/conflicting date-card systems
     - Keeps existing class names/IDs so JS wiring doesn't break
     ========================================================= */

  :root {
    --bg: #f9fafb;
    --card-bg: #ffffff;

    /* core text */
    --text: #0f172a;
    --fg: #0f172a;
    --muted: #6b7280;

    /* borders + surfaces */
    --border: #e5e7eb;
    --border-soft: rgba(15, 23, 42, 0.10);
    --border-subtle: rgba(15, 23, 42, 0.14);
    --surface: #ffffff;
    --surface-subtle: #f9fafb;

    /* brand */
    --accent: #ff6a3d;
    --bubble: #ff6a3d;
    --accent-soft: rgba(255, 106, 61, 0.08);

    /* status */
    --teal: #0f766e;

    /* shape */
    --radius-lg: 16px;
    --shadow-soft: 0 12px 30px rgba(15, 23, 42, 0.08);
  }

  * { box-sizing: border-box; }

  body {
    margin: 0;
    padding: 0;
    font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    background: var(--bg);
    color: var(--text);
  }

  /* ANCHOR: LAYOUT_SHELL */
  .page {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
  }

  header {
    padding: 16px 24px;
    border-bottom: 1px solid var(--border);
    background: #ffffff;
    position: sticky;
    top: 0;
    z-index: 20;
  }

  .header-inner {
    max-width: 1040px;
    margin: 0 auto;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
  }

  .logo {
    display: inline-flex;
    align-items: center;
    gap: 10px;
    font-weight: 700;
    letter-spacing: 0.06em;
    font-size: 18px;
  }

  .logo img {
    height: 48px; /* smaller header logo */
    width: auto;
    display: block;
  }

  .logo-text {
    color: var(--accent);
    font-size: 14px;
    font-weight: 600;
    letter-spacing: 0.12em;
  }

  .step-indicator {
    font-size: 13px;
    color: var(--muted);
  }

  /* ANCHOR: CHECKOUT_HEADER_MOBILE_WRAP_FIX */
  @media (max-width: 560px){
    /* Let the header row wrap instead of colliding */
    .checkout-header-wrapper{
      flex-wrap: wrap !important;
      justify-content: flex-start !important;
      gap: 10px !important;
      padding: 12px 14px !important;
    }

    /* Center title: remove negative margin + give it a full row */
    .checkout-header-wrapper > div:nth-child(2){
      width: 100% !important;
      margin-left: 0 !important; /* overrides inline -48px */
      justify-content: center !important;
      order: 2;
    }

    /* Step indicator: move to its own line and allow wrapping */
    .checkout-header-wrapper > .step-indicator{
      width: 100% !important;
      text-align: center !important;
      white-space: normal !important; /* overrides inline nowrap */
      order: 3;
      font-size: 12px !important;
    }
  }

  main {
    flex: 1;
    padding: 24px 16px 32px;
  }

  .layout {
    max-width: 1040px;
    margin: 0 auto;
    display: grid;
    grid-template-columns: minmax(0, 2.2fr) minmax(0, 1.1fr);
    gap: 24px;
    align-items: flex-start;
  }

  @media (max-width: 900px) {
    .layout {
      grid-template-columns: minmax(0, 1fr);
    }
  }

  /* ANCHOR: CARD_FRAME */
  .card {
    background: var(--card-bg);
    border-radius: var(--radius-lg);
    box-shadow: var(--shadow-soft);
    padding: 20px 20px 18px;
    border: 1px solid rgba(15, 23, 42, 0.02);
  }

  .card-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
  }

  .card-header-right {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 4px;
  }

  .card-header-actions {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 2px;
  }

  .card-header-link {
    border: none;
    background: none;
    padding: 0;
    font-size: 12px;
    font-weight: 500;
    color: var(--accent);
    cursor: pointer;
    text-decoration: none;
  }

  .card-header-link:hover {
    text-decoration: underline;
  }

  .card-title {
    font-size: 15px;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .card-step {
    width: 22px;
    height: 22px;
    border-radius: 999px;
    border: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    font-weight: 500;
    color: var(--muted);
  }

  .card-step.active {
    border-color: var(--accent);
    background: var(--accent-soft);
    color: var(--accent);
  }

  .card-step.completed {
    border-color: var(--teal);
    background: rgba(16, 185, 129, 0.08);
    color: var(--teal);
  }

  .card-status {
    font-size: 12px;
    color: var(--muted);
  }

  .card-status.completed {
    color: var(--teal);
    font-weight: 500;
  }

  .section-body {
    margin-top: 6px;
    font-size: 14px;
    color: var(--muted);
  }

  .section-body.hidden {
    display: none;
  }

  /* =========================
     SECTION 2: ADD-ONS (BASE)
     ========================= */
  .addons-footer-row {
    margin-top: 16px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    flex-wrap: wrap;
  }

  /* Keep the pill tight and aligned in Section 3 */
  .addons-section-total-pill {
    margin: 0;
    white-space: nowrap;
  }

  .addons-section-total-pill span {
    font-weight: 600;
  }

  .addons-block {
    margin-top: 16px;
    padding-top: 12px;
    border-top: 1px dashed var(--border-soft);
  }

  .addons-header {
    margin-bottom: 6px;
  }

  .addons-title {
    font-size: 14px;
    font-weight: 500;
  }

  .addons-subtitle {
    font-size: 12px;
    color: var(--muted);
  }

  .addons-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-top: 4px;
  }

  .addon-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    font-size: 13px;
  }

  .addon-main {
    display: flex;
    flex-direction: column;
  }

  .addon-title {
    font-weight: 500;
  }

  .addon-meta {
    font-size: 12px;
    color: var(--muted);
  }

  .addon-qty {
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .addon-qty label {
    font-size: 12px;
    color: var(--muted);
    margin: 0;
  }

  .addon-qty input {
    width: 64px;
    padding: 4px 6px;
    border-radius: 6px;
    border: 1px solid var(--border-soft);
    text-align: right;
    font-size: 13px;
    font-family: inherit;
    background: #ffffff;
  }

  /* ANCHOR: ADDONS_MODAL_MOBILE */
  @media (max-width: 560px){
    /* If your modal uses a shared container class, keep selectors broad but safe */
    .modal,
    .addons-modal,
    #addonsModal,
    #addOnsModal,
    .dialog{
      max-height: calc(100vh - 24px) !important;
      overflow: hidden !important;
    }

    .modal-content,
    .addons-modal-content,
    #addonsModal .modal-content,
    #addOnsModal .modal-content,
    .dialog-content{
      max-height: calc(100vh - 24px) !important;
      overflow: auto !important;
      -webkit-overflow-scrolling: touch;
      padding: 14px !important;
    }

    .addons-footer-row{
      flex-direction: column;
      align-items: stretch;
      gap: 10px;
    }

    .addons-section-total-pill{
      width: 100%;
      text-align: center;
    }
  }

  /* =========================
     FIELDS + FORM (CANONICAL)
     ========================= */
  /* ANCHOR: FIELDS_AND_FORM */
  .field-row {
    margin-top: 12px;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .field-label {
    font-size: 13px;
    color: var(--muted);
  }

  .field-value {
    font-size: 14px;
    color: var(--text);
  }

  label {
    display: block;
    font-size: 13px;
    color: var(--muted);
    margin-bottom: 4px;
  }

  input,
  textarea {
    width: 100%;
    border-radius: 10px;
    border: 1px solid var(--border);
    padding: 8px 10px;
    font-size: 14px;
    font-family: inherit;
    outline: none;
    background: #ffffff;
    color: var(--text);
  }

  input:focus,
  textarea:focus {
    border-color: var(--teal);
    box-shadow: 0 0 0 1px rgba(15, 118, 110, 0.12);
  }

  textarea {
    min-height: 70px;
    resize: vertical;
  }

  .error-text {
    color: #b91c1c;
    font-size: 13px;
    margin-top: 6px;
  }

  .phone-row {
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .phone-country {
    min-width: 170px;
    border-radius: 10px;
    border: 1px solid var(--border);
    padding: 8px 8px;
    font-size: 13px;
    background: #ffffff;
    color: var(--text);
  }

  .phone-country:focus {
    border-color: var(--teal);
    box-shadow: 0 0 0 1px rgba(15, 118, 110, 0.12);
    outline: none;
  }

  .phone-input { flex: 1; }

  .guest-form-grid {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 10px 12px;
    margin-top: 8px;
  }

  @media (max-width: 600px) {
    .guest-form-grid {
      grid-template-columns: minmax(0, 1fr);
    }
  }

  /* =========================
     BUTTONS (CANONICAL)
     ========================= */
  button {
    font-family: inherit;
    border: none;
    cursor: pointer;
  }

  .btn-primary {
    margin-top: 14px;
    padding: 9px 16px;
    border-radius: 999px;
    background: var(--accent);
    color: #ffffff;
    font-size: 14px;
    font-weight: 500;
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }

  .btn-primary[disabled] {
    opacity: 0.6;
    cursor: default;
  }

  .btn-link {
    background: none;
    border: none;
    color: var(--teal);
    font-size: 13px;
    padding: 0;
  }

  /* =========================
     SUMMARY + PRICE (CANONICAL)
     ========================= */
  /* ANCHOR: SUMMARY_CARD */
  /* ANCHOR: PRICE_SUMMARY */
  .price-summary-row {
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: 16px;
    margin-top: 2px;
  }

  .price-main-info {
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .price-per-night {
    font-size: 14px;
    font-weight: 400;
    color: var(--text);
  }

  .price-per-night-caption {
    font-size: 12px;
    color: var(--muted);
  }

  .price-total-pill {
    padding: 10px 18px;
    border-radius: 999px;
    border: 1px solid var(--border);
    background: #f9fafb;
    font-size: 17px;
    font-weight: 500;
    white-space: nowrap;
    display: inline-flex;
    align-items: center;
    gap: 6px;
    transform: translateY(2px);
  }

  .price-total-pill span {
    font-weight: 600;
    font-size: 17px;
    color: var(--text);
  }

  .summary-card-title {
    font-size: 15px;
    font-weight: 600;
    margin-bottom: 6px;
  }

  .summary-line {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    font-size: 13px;
    margin-top: 4px;
    color: var(--muted);
  }

  .summary-line strong {
    font-size: 14px;
    color: var(--text);
  }

  .summary-total {
    margin-top: 10px;
    padding-top: 8px;
    border-top: 1px dashed var(--border);
    display: flex;
    justify-content: space-between;
    align-items: baseline;
  }

  .summary-total-label {
    font-size: 13px;
    color: var(--muted);
  }

  .summary-total-amount {
    font-size: 18px;
    font-weight: 600;
    color: var(--text);
  }

  .breakdown-toggle {
    margin-top: 8px;
    font-size: 13px;
    color: var(--teal);
    cursor: pointer;
  }

  .breakdown {
    margin-top: 6px;
    padding: 8px 0 4px;
    border-top: 1px dashed var(--border);
    display: none;
    font-size: 12px;
    color: var(--muted);
  }

  .breakdown.visible { display: block; }

  .breakdown-line{
    display: grid;
    grid-template-columns: auto 1fr auto;
    column-gap: 10px;
    align-items: baseline;
    margin-bottom: 2px;
  }

  .breakdown-line .bd-rooms{
    color: var(--muted);
    white-space: nowrap;
  }

  /* =========================
     STICKY FOOTER (DISABLED)
     ========================= */
  /* ANCHOR: STICKY_FOOTER */
  .sticky-footer { display: none; }

  /* =========================
     PAYMENT PILLS (CANONICAL)
     ========================= */
  /* ANCHOR: PAYMENT_PILLS */
  .card-logos {
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }

  /* BIGGER logos â€“ ~5x original */
  .card-logos img,
  .pill img,
  .card-logo-ticker {
    height: 60px;
    display: block;
    object-fit: contain;
  }

  .payment-options-row {
    display: flex;
    flex-wrap: wrap;
    gap: 16px;
    align-items: stretch;
  }

  .pill-wrap {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    min-width: 190px;
  }

  .pill-caption {
    font-size: 11px;
    color: var(--muted);
    text-align: center;
    line-height: 1.3;
    margin-bottom: 2px;
  }

  .pill {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 16px 22px;
    border-radius: 999px;
    font-size: 11px;
    font-weight: 500;
    border: 1px solid var(--border);
    color: var(--muted);
    background: #f9fafb;
    gap: 10px;
    transition:
      border-color 0.16s ease-out,
      box-shadow 0.16s ease-out,
      background 0.16s ease-out,
      transform 0.12s ease-out;
  }

  .pill-main {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  /* Invisible radio that sits over the pill */
  .payment-pill-input {
    position: absolute;
    inset: 20px 0 0 0;
    opacity: 0;
    cursor: pointer;
  }

  /* Selected pill: orange outline + soft gradient */
  .payment-pill-input:checked + .pill {
    border-color: var(--accent);
    box-shadow: 0 0 0 2px rgba(255, 106, 61, 0.35);
    background: linear-gradient(135deg, rgba(255, 247, 237, 1), #ffffff);
    transform: translateY(-1px);
  }

  .pill-dot { display: none; }

  /* =========================
     SECURITY HELPER (CANONICAL)
     ========================= */
  /* ANCHOR: SECURITY_HELPER */
  .payment-security {
    margin-top: 10px;
    display: flex;
    justify-content: flex-end;
    position: relative;
  }

  .security-badge {
    width: 32px;
    height: 32px;
    border-radius: 999px;
    background: #dbeafe;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #0f766e;
    font-size: 16px;
    box-shadow: 0 8px 20px rgba(15, 23, 42, 0.15);
    cursor: default;
  }

  .security-icon-btn {
    width: 32px;
    height: 32px;
    border-radius: 999px;
    border: none;
    background: #e0f2fe;
    color: #0f766e;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 6px 16px rgba(15, 23, 42, 0.18);
    font-size: 16px;
    cursor: pointer;
  }

  .security-icon-btn:focus-visible {
    outline: 2px solid #0f766e;
    outline-offset: 2px;
  }

  .security-bubble {
    position: absolute;
    top: 130%;
    left: 50%;
    transform: translate(-50%, 4px);
    background: #e0fdf4;
    color: #0f172a;
    padding: 10px 12px;
    border-radius: 12px;
    width: 260px;
    box-shadow: 0 16px 35px rgba(15, 23, 42, 0.2);
    font-size: 12px;
    line-height: 1.4;
    opacity: 0;
    pointer-events: none;
    transition:
      opacity 0.18s ease-out,
      transform 0.18s ease-out;
    z-index: 30;
  }

  .security-bubble strong {
    color: #0f172a;
    font-weight: 700;
    display: block;
    margin-bottom: 6px;
  }

  .payment-security:hover .security-bubble,
  .payment-security:focus-within .security-bubble {
    opacity: 1;
    pointer-events: auto;
    transform: translateY(0);
  }

  /* Agreement line next to payment button */
  .payment-agreement {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 4px;
    font-size: 12px;
    color: var(--muted);
    margin-left: 8px;
    margin-top: 10px;
    max-width: 420px;
  }

  .payment-agreement-label {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 6px 10px;
    margin-top: 0;
    border-radius: 10px;
    border: 1px solid transparent;
    background: #ffffff;
    cursor: pointer;
    transition:
      border-color 0.15s ease-out,
      box-shadow 0.15s ease-out,
      background 0.15s ease-out;
  }

  .payment-agreement-checkbox {
    width: 14px;
    height: 14px;
    margin-top: 0;
  }

  .payment-agreement-text {
    line-height: 1.3;
    white-space: nowrap;
    margin-top: 0;
  }

  @media (max-width: 640px) {
    .payment-agreement-text { white-space: normal; }
  }

  .payment-agreement.error .payment-agreement-label {
    border-color: #ef4444;
    box-shadow: 0 0 0 1px rgba(239, 68, 68, 0.45);
    background: linear-gradient(#fff5f5, #ffffff);
  }

  .terms-error {
    font-size: 11px;
    color: #b91c1c;
  }

  /* =========================
     SECTION 1: LINE ITEM GRID
     ========================= */

  /* === SECTION 1: LINE ITEM CARD OUTLINE (subtle separation) === */
  .section-body[data-section-body="1"] .dates-grid{
    border: 1px solid rgba(15, 28, 46, 0.10);
    border-radius: 16px;
    padding: 14px;
    margin-bottom: 14px;
    background: linear-gradient(180deg, rgba(255, 106, 61, 0.03), rgba(255, 255, 255, 0));
  }

  .dates-grid{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap: 32px;
    align-items: stretch;
  }

  /* ANCHOR: CHECKOUT_SECTION1_MOBILE_GRID */
  @media (max-width: 560px){
    .dates-grid{
      grid-template-columns: 1fr !important;
      gap: 14px !important;
    }

    .dates-right{
      align-items: flex-start !important;
    }

    .top-info-right{
      max-width: 100% !important;
      align-items: flex-start !important;
      text-align: left !important;
    }

    .top-info-right .field-label,
    .top-info-right .field-value{
      text-align: left !important;
    }

    .top-info-right .field-value{
      max-width: 100% !important;
      white-space: normal !important;
      overflow: visible !important;
      text-overflow: clip !important;
    }
  }

  .dates-right{
    display:flex;
    flex-direction:column;
    align-items:flex-end;
  }

  .dates-right .stay-confirm-row{
    margin-top:auto;
    width:100%;
    display:flex;
    justify-content:flex-end;
  }

  .dates-right .top-info-right{ text-align:right; }

  .dates-right .top-info-right .card-header-link{
    color:#ff6a3d;
  }

  .dates-left .field-row { margin-bottom: 12px; }

  /* === CHECKOUT SECTION 1 (Room & Price) ROW LAYOUT ===================== */

  .room-plan-row{
    display:flex;
    align-items:flex-end;
    gap:12px;
    margin: 10px 0 14px 0;
  }

  .rp-col{ min-width: 0; }
  .rp-label{ font-size: 12px; color: var(--muted); margin-bottom: 4px; }
  .rp-value{ font-size: 13px; color: var(--text); }

  .rp-arrow, .rp-op{
    flex: 0 0 auto;
    color: var(--muted);
    font-weight: 600;
    line-height: 1;
    padding-bottom: 2px;
  }

  .room-price-row{
    display:flex;
    align-items:flex-end;
    gap:12px;
    margin: 6px 0 14px 0;
  }

  /* Row 2: center only the VALUES under the labels */
  .room-price-row .rp-value{
    text-align:center;
    width:100%;
  }

  .room-price-row .rp-col{
    display:flex;
    flex-direction:column;
    align-items: center;
  }

  .room-price-row .rp-label{ align-self: flex-start; }

  .pill-outline{
    flex: 0 0 auto;
    padding: 8px 14px;
    border-radius: 9999px;
    border: 2px solid var(--bubble);
    background: #ffffff;
    color: var(--text);
    font-weight: 700;
    cursor: default;
  }

  .stay-confirm-row{
    margin-top: 14px;
    display:flex;
    align-items:center;
    justify-content:flex-end;
    gap:12px;
    width:100%;
  }

  .stay-remove-row{
    margin-top: 10px;
    display:flex;
    justify-content:flex-start;
  }

  .stay-confirm-row .btn-primary{ margin-left:auto; }

  #stayDatesInline{
    display:inline-block;
    white-space: nowrap;
  }

  #confirmRoomPriceBtn{ flex: 0 0 auto; }

  .top-info-row{
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
    gap:16px;
    margin-bottom: 10px;
  }

  .top-info-left{ flex: 1 1 auto; min-width: 0; }

  .top-info-right{
    display:flex;
    flex-direction:column;
    align-items:flex-end;
    text-align:right;
    max-width: 48%;
  }

  .top-info-right .field-label{ text-align:right; }

  .top-info-right .field-value{
    text-align:right;
    color:#111;
    font-weight:400;
    max-width: 240px;
    white-space: nowrap;
    overflow-wrap: normal;
    word-break: normal;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .rp-stack{
    margin-top: 12px;
    padding-top: 5px;
    border-top: 1px solid rgba(255,106,61,0.22);
  }

  .rp-stack .room-plan-row{
    padding-top: 5px;
    padding-bottom: 18px;
    border-bottom: 1px solid rgba(255,106,61,0.22);
  }

  .rp-stack .room-price-row{ padding-top: 10px; }

  #confirmRoomPriceBtn{ margin-top: 8px; }

  .dates-right .card-header-link {
    border: 0;
    background: transparent;
    color: var(--bubble);
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
  }

  #editDatesLink{ color:#ff6a3d; }

  /* =========================
     CHECKOUT DATES CARD (CANONICAL)
     - Removes duplicate driver/apply/shell definitions
     ========================= */

  .checkout-dates-card-wrapper{
    margin-top: 6px;
    display: block;
  }
  .checkout-dates-card-wrapper.hidden{ display:none; }

  .checkout-dates-card-wrapper .detail-date-bar{
    width: 100%;
    padding: 12px 14px;
    border-radius: 18px;
    border: 1px solid var(--border);
    background: #ffffff;
    box-shadow: 0 4px 12px rgba(15,23,42,0.06);

    display: flex;
    flex-direction: column;
    align-items: stretch;
    gap: 10px;
  }

  /* ANCHOR: CHECKOUT_DATES_HIDE_NATIVE_FIELDS */
  .dates-grid .detail-date-field{
    display: none !important;
  }

  /* driver (both class + id supported) */
  .checkout-dates-driver,
  #checkout-dates-driver{
    position: absolute;
    left: -9999px;
    width: 1px;
    height: 1px;
    opacity: 0;
    pointer-events: none;
  }

  .checkout-dates-display,
  #checkout-dates-display{
    display: inline-flex;
    align-items: center;
    gap: 10px;
    padding: 10px 14px;
    border-radius: 999px;
    border: 1px solid var(--border);
    background: #ffffff;
    cursor: pointer;
    font-size: 14px;
    color: var(--text);
    text-align: left;
    white-space: nowrap;
    width: 100%;
    justify-content: flex-start;
  }

  .checkout-dates-display:focus-visible,
  #checkout-dates-display:focus-visible{
    outline: 2px solid rgba(15,118,110,0.35);
    outline-offset: 2px;
  }

  .checkout-dates-display-icon{
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 22px;
  }

  #checkout-dates-apply{
    width: 100%;
    margin: 0 !important;
    transform: none !important;
    align-self: stretch;
    padding: 9px 12px;
    border-radius: 999px;
    border: 1px solid var(--bubble);
    background: transparent;
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    white-space: nowrap;
    text-align: center;
  }

  /* collapse into 1 column on small screens */
  @media (max-width: 760px) {
    .dates-grid { grid-template-columns: 1fr; }
    .dates-right { align-items: flex-start; }
  }

</style>

</head>
<body>
  <div class="page">
		<header>
			<div class="checkout-header-wrapper" style="
				display:flex;
				align-items:center;
				justify-content:space-between;
				padding:16px 24px;
				border-bottom:1px solid var(--border);
				background:#ffffff;
			">
				
				<!-- LEFT: LOGO -->
				<div style="display:flex;align-items:center;gap:10px;">
          <a class="logo" href="/" aria-label="Lolaelo home">
            <img
              src="/images/logo.png"
              alt="Lolaelo"
              class="logo-img"
              decoding="async"
              loading="eager"
            >
          </a>
				</div>

				<!-- CENTER: CHECKOUT TITLE -->
				<div style="
					flex:1;
					display:flex;
					justify-content:center;
					pointer-events:none;
					margin-left:-48px; /* counter logo width for true center */
				">
					<span style="
						font-size:20px;
						font-weight:600;
						color:#ff6a3d;
						letter-spacing:0.4px;
					">
						CHECKOUT
					</span>
				</div>

				<!-- RIGHT: STEP INDICATOR -->
				<div class="step-indicator" style="font-size:13px;color:var(--muted);white-space:nowrap;">
					Step 1 of 2 Â· Review and details
				</div>

			</div>
		</header>
    <main>
      <div class="layout">
        <!-- Left side: progressive sections -->
        <div>
          <!-- Section 1 - Room and Prices -->
          <div class="card" data-section="1">
            <div class="card-header">
              <div class="card-title">
                <div class="card-step active" data-step-indicator="1">1</div>
                Room & Price
              </div>
              <div class="card-status" data-step-status="1">
                Waiting for confirmation
              </div>
            </div>

            <div class="section-body" data-section-body="1">

              <!-- CONSOLIDATED TWO-COLUMN GRID (Left = Room/Price rows, Right = Dates editor card) -->
              <!-- ANCHOR: ROOM_PRICE_CARDS_ROOT -->
              <div id="roomPriceCardsRoot">
                <!-- ANCHOR: CHECKOUT_EMPTY_STATE -->
                  <div id="checkoutEmptyState"
                      style="display:none; padding:14px; border:1px solid #e5e7eb; border-radius:12px; background:#fff7ed;">
                    <div style="font-weight:700; color:#111827; margin-bottom:6px;">
                      Your cart is empty.
                    </div>
                    <div style="color:#374151; font-size:14px; line-height:1.35;">
                      You removed the last item from your checkout. To continue, browse hotels and select your dates.
                    </div>

                    <div style="margin-top:12px; display:flex; gap:10px; flex-wrap:wrap;">
                      <a href="/catalog.html"
                        class="btn-primary"
                        style="text-decoration:none; display:inline-flex; align-items:center; justify-content:center;">
                        Hotel Catalog
                      </a>
                      <div style="color:#6b7280; font-size:12px; line-height:1.35;">
                        Note: Checkout supports one property at a time. Multiple date windows for the same hotel are supported. Additionally, our dev team is working really hard to provide users the ability to checkout multiple properties in one checkout session but for now, we only allow one property per checkout session. 
                      </div>
                    </div>
                  </div>
                  <!-- END ANCHOR: CHECKOUT_EMPTY_STATE -->
                <div class="dates-grid" id="roomPriceCardTemplate">

                <!-- LEFT COLUMN -->
                <div class="dates-left">

                  <div class="top-info-row">
                    <div class="top-info-left">
                      <div class="field-label">Property name</div>
                      <div class="field-value">
                        <div id="propertyName"></div>
                        <div class="muted" id="propertyMeta"></div>
                        <span id="propertyIdValue" style="display:none;"></span>
                      </div>
                    </div>
                  </div>

                  <!-- Row 1 (existing): Room -> Rate plan -> # of Rooms -->
                <div class="rp-stack">
                  <div class="room-plan-row">
                    <div class="rp-col">
                      <div class="rp-label">Room</div>
                      <div class="rp-value">
                        <span id="roomName"></span>
                        <span id="roomIdValue" style="display:none;"></span>
                      </div>
                    </div>

                    <div class="rp-arrow">â†’</div>

                    <div class="rp-col">
                      <div class="rp-label">Rate Plan</div>
                      <div class="rp-value">
                        <span id="ratePlanName"></span>
                        <span id="ratePlanIdValue" style="display:none;"></span>
                      </div>
                    </div>

                    <div class="rp-col">
                      <div class="rp-label"># of Rooms</div>
                      <div class="rp-value">
                        <span id="roomQty">1</span>
                      </div>
                    </div>
                  </div>

                  <!-- Row 2: nights x avg price = total -->
                  <div class="room-price-row">
                    <div class="rp-col">
                      <div class="rp-label">Nights</div>
                      <div class="rp-value">
                        <span id="stayNights">0</span>
                      </div>
                    </div>

                    <div class="rp-op">Ã—</div>

                    <div class="rp-col">
                      <div class="rp-label"># of Rooms</div>
                      <div class="rp-value">
                        <span id="roomQty">1</span>
                      </div>
                    </div>

                    <div class="rp-op">Ã—</div>

                    <div class="rp-col">
                      <div class="rp-label">Avg. Price/Night</div>
                      <div class="rp-value">
                        <span id="avgNightPrice">$0</span>
                      </div>
                    </div>

                    <div class="rp-op">=</div>

                    <button
                      type="button"
                      class="pill-outline"
                      id="totalPill"
                      aria-label="Total room price"
                    >
                      $0
                    </button>
                  </div>
                </div>

                <!-- Row 3: remove (confirm moved to right column) -->
                <div class="stay-remove-row">
                  <button
                    type="button"
                    class="card-header-link"
                    id="removeLineItemBtn"
                    data-remove-lineitem="1"
                  >
                    Remove line item
                  </button>
                </div>

                </div>
                <!-- END LEFT COLUMN -->

                <!-- RIGHT COLUMN: DATE CARD (preserved) -->
                <div class="dates-right">

                  <div class="top-info-right">
                    <div class="field-label">Stay dates</div>
                    <div class="field-value">
                      <span id="stayDatesInline"></span>
                    </div>

                    <!-- Edit dates link (shows the preserved date card on the right) -->
                    <button class="card-header-link" id="editDatesLink" type="button">
                      Edit dates
                    </button>
                  </div>

                  <div id="checkoutDatesCardWrapper" class="checkout-dates-card-wrapper hidden">

                    <div id="checkout-date-bar" class="detail-date-bar">
                      <input
                        type="text"
                        id="checkout-dates-driver"
                        class="checkout-dates-driver"
                        aria-hidden="true"
                      />

                      <button
                        type="button"
                        id="checkout-dates-display"
                        class="checkout-dates-display"
                        aria-label="Edit stay dates"
                      >
                        <span class="checkout-dates-display-icon">ðŸ“…</span>
                        <span id="checkout-dates-display-label">Select dates</span>
                      </button>

                      <label class="detail-date-field">
                        <span>Check in</span>
                        <input type="date" id="checkout-checkin" />
                      </label>

                      <label class="detail-date-field">
                        <span>Check out</span>
                        <input type="date" id="checkout-checkout" />
                      </label>

                      <button
                        id="checkout-dates-apply"
                        class="btn-outline"
                        style="
                          border: 2px solid #ff6a3d;
                          color: #ff6a3d;
                          padding: 6px 18px;
                          border-radius: 9999px;
                          background: #ffffff;
                          font-weight: 600;
                          font-size: 13px;
                          cursor: pointer;
                        "
                      >
                        Update dates
                      </button>

                    </div>
                  </div>

                  <!-- Row 3: confirm (right column, bottom) -->
                  <div class="stay-confirm-row">
                    <button
                      type="button"
                      class="btn-primary"
                      id="confirmRoomPriceBtn"
                      data-confirm="1"
                    >
                      Confirm Room & Price
                    </button>
                  </div>

                </div>
                <!-- END RIGHT COLUMN -->

              </div>
            </div>
            <!-- END GRID -->

            </div>
          </div>

          <!-- Section 2 - Add-ons -->
          <div class="card" data-section="2">
            <div class="card-header">
              <div class="card-title">
                <div class="card-step" data-step-indicator="2">2</div>
                ADD-ONs
              </div>
              <div class="card-status" data-step-status="2">
                Locked until previous step
              </div>
            </div>

            <div class="section-body hidden" data-section-body="2">
              <p class="section-intro">
                Optional activities and extras selected by your hotel.
              </p>

              <div
                class="addons-explore-row"
                style="text-align:center; margin-bottom:12px;"
              >
                <button
                  type="button"
                  class="addons-explore-pill"
                  data-open-addons-modal
                  style="
                    padding: 8px 24px;
                    border-radius: 9999px;
                    border: 2px solid #0a8a85;
                    background: #ffffff;
                    color: #0a8a85;
                    font-weight: 600;
                    font-size: 14px;
                    cursor: pointer;
                    display: inline-block;
                  "
                >
                  Explore ADD-ONs
                </button>
              </div>

              <!-- Inline summary list (populated from selected add-ons) -->
              <div
                id="addonsList"
                class="addons-inline-summary"
                style="display:none; margin-top:12px;"
              ></div>

              <!-- Default empty message if property has no activities configured -->
              <p id="addonsEmptyMessage" class="muted" style="margin-top:12px;">
                No add-ons are available for this stay.
              </p>

              <div
                class="addons-confirm-row"
                style="
                  margin-top:12px;
                  display:flex;
                  align-items:center;
                  justify-content:space-between;
                  gap:12px;
                "
              >
                <!-- Left: primary action -->
                <button class="btn-primary" type="button" data-confirm="2">
                  Confirm add-ons
                </button>

                <!-- Right: pill-style total -->
                <div
                  id="addonsInlineTotalWrapper"
                  class="addons-inline-total"
                  style="display:none; font-size:13px; color:#374151;"
                >
                  <span class="addons-inline-total-pill">
                    <span class="addons-inline-total-label">
                      Add-ons total:
                    </span>
                    <span
                      id="addonsInlineTotal"
                      class="addons-inline-total-amount"
                    >
                      --
                    </span>
                  </span>
                </div>
              </div>
            </div> <!-- end section-body 2 -->
          </div>   <!-- end card (Section 2) -->

          <!-- Section 3 - Guest details -->
          <div class="card" data-section="3">
            <div class="card-header">
              <div class="card-title">
                <div class="card-step" data-step-indicator="3">3</div>
                Guest details
              </div>
              <div class="card-status" data-step-status="3">
                Locked until previous step
              </div>
            </div>
            <div class="section-body hidden" data-section-body="3">
            <div class="guest-form-grid">
              <div>
                <label for="firstName">First name</label>
                <input id="firstName" autocomplete="given-name" />
              </div>

              <div>
                <label for="lastName">Last name</label>
                <input id="lastName" autocomplete="family-name" />
              </div>

              <div>
                <label for="email">Email</label>
                <input id="email" type="email" autocomplete="email" />
              </div>

              <div>
                <label for="guestsCount">Number of guests</label>
                <input id="guestsCount" type="number" min="1" step="1" value="2" />
              </div>

              <div style="grid-column: 1 / -1;">
                <label for="phone">Mobile number</label>
                <div class="phone-row">
                  <select id="phoneCountry" class="phone-country">
                    <option value="+1">ðŸ‡ºðŸ‡¸ +1 (United States)</option>
                    <option value="+63">ðŸ‡µðŸ‡­ +63 (Philippines)</option>
                    <option value="+44">+44 (United Kingdom)</option>
                    <option value="+61">+61 (Australia)</option>
                    <option value="+65">+65 (Singapore)</option>
                    <option value="+81">+81 (Japan)</option>
                    <option value="+82">+82 (South Korea)</option>
                    <option value="+49">+49 (Germany)</option>
                    <option value="+33">+33 (France)</option>
                    <option value="+34">+34 (Spain)</option>
                    <option value="+39">+39 (Italy)</option>
                    <option value="+31">+31 (Netherlands)</option>
                    <option value="+63-other">Other</option>
                  </select>
                  <input
                    id="phone"
                    type="tel"
                    autocomplete="tel"
                    placeholder="9-digit mobile"
                    class="phone-input"
                  />
                </div>
              </div>
            </div>

              <div style="margin-top: 10px;">
                <label for="specialRequests">
                  Special request to hotel management (optional)
                </label>
                <textarea id="specialRequests"></textarea>
              </div>

              <div class="error-text" id="guestError" style="display: none;">
                Please fill in all guest details and contact information.
              </div>

              <button class="btn-primary" type="button" data-confirm="3">
                Confirm guest details
              </button>
            </div>
          </div>

          <!-- Section 4 - Payment method -->
          <div class="card" data-section="4">
            <div class="card-header">
              <div class="card-title">
                <div class="card-step" data-step-indicator="4">4</div>
                Payment method
              </div>
              <div class="card-status" data-step-status="4">
                Locked until previous step
              </div>
            </div>

            <div class="section-body hidden" data-section-body="4">
              <div class="field-row">
                
                <!-- TOP ROW: PAYMENT PILLS -->
                <div class="field-inline payment-options-row">
                  <!-- CARD / STRIPE -->
                  <div class="pill-wrap">
                    <div class="pill-caption">
                      Stripe â€“ Major CCs
                    </div>
                    <label class="pill-wrap-label">
                      <input
                        type="radio"
                        name="paymentMethod"
                        value="card"
                        class="payment-pill-input"
                        checked
                      />
                      <div class="pill">
                        <div class="pill-main">
                          <div class="card-logos">
														<img
															src="/images/cards/card_visa.png"
															alt="Visa, Mastercard, Apple Pay, Discover, Amex"
															class="card-logo-ticker"
														/>
                          </div>
                        </div>
                      </div>
                    </label>
                  </div>

                  <!-- PAYPAL -->
                  <div class="pill-wrap">
                    <div class="pill-caption">
                      (coming soon)
                    </div>
                    <label class="pill-wrap-label">
                      <input
                        type="radio"
                        name="paymentMethod"
                        value="paypal"
                        class="payment-pill-input"
                        disabled
                      />
                      <div class="pill">
                        <div class="pill-main">
                          <img
                            src="/images/cards/paypal.png"
                            alt="PayPal"
                          >
                        </div>
                      </div>
                    </label>
                  </div>

                  <!-- GCASH -->
                  <div class="pill-wrap">
                    <div class="pill-caption">
                      (coming soon)
                    </div>
                    <label class="pill-wrap-label">
                      <input
                        type="radio"
                        name="paymentMethod"
                        value="gcash"
                        class="payment-pill-input"
                        disabled
                      />
                      <div class="pill">
                        <div class="pill-main">
                          <img
                            src="/images/cards/gcash.png"
                            alt="GCash"
                          >
                        </div>
                      </div>
                    </label>
                  </div>
                </div>

                <!-- BOTTOM ROW: TEXT CAPTIONS UNDER PILLS -->
                <div class="field-inline payment-options-row" style="margin-top: 6px;">
                  <div style="min-width:190px;text-align:center;font-size:12px;color:#6b7280;">
                    <div>Visa â€“ MasterCard â€“ AMEX</div>
                    <div>ApplePay â€“ Discover</div>
                  </div>
                  <div style="min-width:190px;text-align:center;font-size:12px;color:#6b7280;">
                    PayPal
                  </div>
                  <div style="min-width:190px;text-align:center;font-size:12px;color:#6b7280;">
                    GCash
                  </div>
                </div>
              </div>

              <!-- SECURITY ICON + CONFIRM BUTTON + AGREEMENT -->
              <div style="display:flex; align-items:center; justify-content:flex-start; gap:14px; margin-top:16px; position:relative;">

                <!-- Confirm button -->
                <button class="btn-primary" type="button" data-confirm="4">
                  Proceed to secure payment
                </button>

                <!-- Security icon + bubble -->
                <div class="payment-security" style="position:relative;">
                  <button
                    class="security-icon-btn"
                    type="button"
                    aria-label="Security and payments"
                  >
                    ðŸ”’
                  </button>

                  <div class="security-bubble">
                    <strong>Secure checkout</strong>
                    Your payment is encrypted and processed by Stripe, the same
                    provider trusted by companies like Lyft and Airbnb.
                    Future options like PayPal and GCash will follow the same
                    security standards so your card details never touch our servers.
                  </div>
                </div>

                <!-- Terms / Privacy agreement -->
                <div class="payment-agreement">
                  <label class="payment-agreement-label" for="termsCheckbox">
                    <input
                      id="termsCheckbox"
                      type="checkbox"
                      class="payment-agreement-checkbox"
                    />
                    <span class="payment-agreement-text">
                      I agree to Lolaeloâ€™s
                      <a href="/public/terms.html" target="_blank" style="color:#0f766e; text-decoration:none;">
                        Terms of Use</a>
                       and
                      <a href="/public/privacy.html" target="_blank" style="color:#0f766e; text-decoration:none;">
                        Privacy Policy</a>.
                  </span>
                  </label>
                  <div id="termsError" class="terms-error" style="display:none;">
                    Agreement to the Terms of Use and Privacy Policy is required to continue.
                  </div>
                </div>
              </div>
						</div>
					</div>
				</div>

				<!-- Right side: booking summary -->
        <aside>

          <div class="card">
            <div class="summary-card-title">Your stay</div>

            <div class="summary-line" style="margin-bottom:12px;">
              <span>Property Name</span>
              <strong id="summaryProperty">Property</strong>
            </div>

            <!-- Room type hidden but intact for JS -->
            <div class="summary-line" style="display:none;">
              <span>Room type</span>
              <strong id="summaryRoom">Room</strong>
            </div>

            <!-- Rate plan hidden but intact for JS -->
            <div class="summary-line" style="display:none;">
              <span>Rate plan</span>
              <strong id="summaryPlan">Rate plan</strong>
            </div>

            <div class="summary-line" style="margin-bottom:12px;">
              <span>Dates</span>
              <strong id="summaryDates">Dates</strong>
            </div>

            <div class="summary-line" style="margin-bottom:6px;">
              <span># of Rooms</span>
              <strong id="summaryRooms">--</strong>
            </div>

            <div class="summary-line" style="margin-bottom:14px;">
              <span># of Nights</span>
              <strong id="summaryNightsVisible">--</strong>
            </div>

            <div class="summary-line" style="margin-bottom:14px;">
              <span>ADD-ONs</span>
              <strong id="summaryAddons">None selected</strong>
            </div>

            <hr style="border:0;border-top:1px solid #e5e5e5;margin:10px 0;">

            <div class="summary-total">
              <div>
                <div class="summary-total-label">Total</div>
              </div>
              <div class="summary-total-amount" id="summaryTotal">
                --
              </div>
            </div>

            <div class="breakdown-toggle" id="breakdownToggle">
              View detailed breakdown
            </div>
            <div class="breakdown" id="breakdownDetails">
            </div>

          </div>

        </aside>

      <div class="sticky-footer">
        <div class="sticky-inner">
          <div>

          </div>
            <button class="sticky-button" id="confirmAndPayButton" disabled>
              Proceed to secure payment
            </button>
        </div>
      </div>
    </main>
  </div>

  <script>
    function parseQuery() {
      const params = new URLSearchParams(window.location.search);

      // Raw value from URL only (do NOT resurrect checkout from localStorage)
      const propertyId = params.get("propertyId") || "";

      // --- qty: URL first, then durable fallback (checkout.selection.v1) ---
      const roomIdStr = params.get("roomId") || "";
      const planIdStr = params.get("ratePlanId") || params.get("plan") || "";
      let qtyStr = params.get("qty") || "";

      if (!qtyStr) {
        try {
          const raw = localStorage.getItem("checkout.selection.v1") || "";
          const sel = raw ? JSON.parse(raw) : null;

          const items = sel && Array.isArray(sel.items) ? sel.items : [];
          const roomIdNum = Number(roomIdStr);
          const planIdNum = Number(planIdStr);

          const hit = items.find(it => {
            const r = Number(it && (it.roomTypeId != null ? it.roomTypeId : it.roomId));
            const p = Number(it && (it.ratePlanId != null ? it.ratePlanId : it.planId));
            return Number.isFinite(r) && Number.isFinite(p) && r === roomIdNum && p === planIdNum;
          });

          if (hit && hit.qty != null) qtyStr = String(hit.qty);
        } catch (_) {}
      }

      return {
        propertyId,
        roomId: roomIdStr,
        start: params.get("start") || "",
        end: params.get("end") || "",

        // IDs
        ratePlanId: planIdStr,

        // Optional name fields (can be populated from catalog_details)
        propertyName: params.get("propertyName") || "",
        propertyLocation: params.get("propertyLocation") || "",
        roomName: params.get("roomName") || "",

        // NEW: qty
        qty: qtyStr || "1",

        // Rate plan display name â€“ prefer explicit name, fall back to planLabel
        ratePlanName:
          params.get("ratePlanName") ||
          params.get("planLabel") ||
          ""
      };
    }

    // =========================
    // CART v1 (Secondary Sprint)
    // =========================
    const CART_KEY = "checkout.cart.v1";
    const SELECTION_KEY = "checkout.selection.v1";

    // === ANALYTICS (V2) ===================================================
    const WA_ENDPOINT = "/api/analytics/event";
    const WA_SID_KEY  = "lolaelo_wa_sid";

    function waGetSid(){
      try { return localStorage.getItem(WA_SID_KEY) || ""; } catch (_) { return ""; }
    }
    function waSetSid(sid){
      try { if (sid) localStorage.setItem(WA_SID_KEY, sid); } catch (_) {}
    }

    async function waTrack(name, payload, activeMs){
      try {
        const body = {
          sid: waGetSid() || null,
          name: String(name || "").trim(),
          path: location.pathname,
          url: location.href,
          title: document.title || "",
          referrer: document.referrer || "",
          activeMs: Number.isFinite(activeMs) ? activeMs : 0,
          payload: payload && typeof payload === "object" ? payload : null
        };
        if (!body.name) return;

        const r = await fetch(WA_ENDPOINT, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body),
          keepalive: true
        }).catch(() => null);

        const j = r ? await r.json().catch(() => null) : null;
        if (j && j.ok && j.sid) waSetSid(String(j.sid));
      } catch (_) {}
    }
    // === ANALYTICS (V2) END ===============================================

    function safeJsonParse(raw) {
      try { return raw ? JSON.parse(raw) : null; } catch (_) { return null; }
    }

    function loadCartV1() {
      try {
        return safeJsonParse(localStorage.getItem(CART_KEY) || "");
      } catch (_) {
        return null;
      }
    }

    // Fire checkout page_view + start_checkout once per load
    document.addEventListener("DOMContentLoaded", () => {
      try {
        const q0 = parseQuery();
        const merged = coalesceQueryFromCart(q0);
        const q = merged && merged.q ? merged.q : q0;
        const cart = merged && merged.cart ? merged.cart : null;

        waTrack("page_view", { page: "checkout" }, 0);

        waTrack("start_checkout", {
          propertyId: q.propertyId || null,
          roomTypeId: q.roomId || null,
          ratePlanId: q.ratePlanId || null,
          start: q.start || null,
          end: q.end || null,
          qty: q.qty || null,
          cartMode: !!cart,
          cartItems: cart && Array.isArray(cart.items) ? cart.items.length : 0
        }, 0);
      } catch (_) {}
    });

    function coalesceQueryFromCart(q) {
      const qq = Object.assign({}, q || {});
      const cart = loadCartV1();
      const items = cart && Array.isArray(cart.items) ? cart.items : [];
      if (!items.length) return { q: qq, cart: null, active: null };

      // Active item = try match the URL selection first; otherwise fall back to first item
      let active = null;

      const wantPid   = qq.propertyId ? String(qq.propertyId) : "";
      const wantRoom  = qq.roomId ? String(qq.roomId) : "";
      const wantPlan  = qq.ratePlanId ? String(qq.ratePlanId) : "";
      const wantStart = qq.start ? String(qq.start) : "";
      const wantEnd   = qq.end ? String(qq.end) : "";

      active =
        items.find(it => {
          if (!it) return false;
          const pid  = it.propertyId != null ? String(it.propertyId) : "";
          const rid  = it.roomTypeId != null ? String(it.roomTypeId) : "";
          const plan = it.ratePlanId != null ? String(it.ratePlanId) : "";
          const s    = it.start != null ? String(it.start) : "";
          const e    = it.end != null ? String(it.end) : "";

          // Match the strongest signals first (pid + room + plan). Dates help when provided.
          if (wantPid && pid !== wantPid) return false;
          if (wantRoom && rid !== wantRoom) return false;
          if (wantPlan && plan !== wantPlan) return false;

          // If the URL includes dates, enforce them too.
          if (wantStart && s !== wantStart) return false;
          if (wantEnd && e !== wantEnd) return false;

          return true;
        }) || null;

      // If no exact match, prefer the most recently added item (cart-like behavior)
      if (!active) active = items[items.length - 1];

      // Fill missing query fields from cart (do not override URL when present)
      if (!qq.propertyId && active.propertyId != null) qq.propertyId = String(active.propertyId);
      if (!qq.roomId     && active.roomTypeId != null) qq.roomId = String(active.roomTypeId);
      if (!qq.ratePlanId && active.ratePlanId != null) qq.ratePlanId = String(active.ratePlanId);
      if ((!qq.qty || Number(qq.qty) <= 0) && active.qty != null) qq.qty = String(active.qty);

      if (!qq.start && active.start) qq.start = String(active.start);
      if (!qq.end   && active.end)   qq.end   = String(active.end);

      if (!qq.propertyName && active.propertyName) qq.propertyName = String(active.propertyName);
      if (!qq.propertyLocation && active.propertyLocation) qq.propertyLocation = String(active.propertyLocation);
      if (!qq.roomName && active.roomName) qq.roomName = String(active.roomName);
      if (!qq.ratePlanName && active.planLabel) qq.ratePlanName = String(active.planLabel);

      return { q: qq, cart, active };
    }

    function saveCartV1(cart) {
      try {
        localStorage.setItem(CART_KEY, JSON.stringify(cart));
        return true;
      } catch (_) {
        return false;
      }
    }

    // === DB-AUTHORITATIVE PROPERTY META (name/location) =======================
    function resolveDbPropertyMeta(details) {
      const d = details && typeof details === "object" ? details : {};
      const name =
        String(
          (d.meta && d.meta.property && d.meta.property.name) ||
          (d.property && d.property.name) ||
          d.name ||
          d.title ||
          ""
        ).trim();

      const location =
        String(
          (d.meta && d.meta.property && d.meta.property.location) ||
          (d.property && d.property.location) ||
          d.location ||
          ""
        ).trim();

      return { name, location };
    }

    function applyDbPropertyMetaToCartAndUI(propertyIdStr, meta) {
      const pid = String(propertyIdStr || "").trim();
      if (!pid) return;

      const name = (meta && meta.name) ? String(meta.name).trim() : "";
      const location = (meta && meta.location) ? String(meta.location).trim() : "";

      if (!name && !location) return;

      // 1) Update cart items for this propertyId (so clones + summary become consistent)
      let cart = null;
      try { cart = loadCartV1(); } catch (_) { cart = null; }
      if (cart && Array.isArray(cart.items)) {
        let touched = false;

        cart.items.forEach(it => {
          if (!it) return;
          if (String(it.propertyId || "") !== pid) return;

          // overwrite with DB truth (this enforces "DB pull only")
          if (name) { it.propertyName = name; touched = true; }
          if (location) { it.propertyLocation = location; touched = true; }
        });

        if (touched) saveCartV1(cart);
      }

      // 2) Update visible UI in-place (no re-render needed)
      const cards = Array.from(document.querySelectorAll('.section-body[data-section-body="1"] .dates-grid[data-lineid]'));
      // Only hide the "template" card if it is truly a template (no rendered lineId).
      // In cart mode with a single item, roomPriceCardTemplate IS the real card and must stay visible.
      const tpl = document.getElementById("roomPriceCardTemplate");
      if (tpl) {
        const hasLineId =
          !!tpl.getAttribute("data-lineid") ||
          !!tpl.getAttribute("data-lineId") ||
          !!(tpl.dataset && (tpl.dataset.lineid || tpl.dataset.lineId));

        // Hide only when it has NOT been tagged as a real rendered card.
        tpl.style.display = hasLineId ? "" : "none";
      }

      // Empty checkout state when there are no real rendered cards (re-evaluate after tpl visibility change)
      const cardsNow = Array.from(document.querySelectorAll('.section-body[data-section-body="1"] .dates-grid[data-lineid]'))
        .filter(el => (el instanceof HTMLElement) && getComputedStyle(el).display !== "none");

      const isEmpty = !cardsNow.length;
      setCheckoutEmptyStateVisible(isEmpty);
      cards.forEach(card => {
        const idEl = card.querySelector('[data-role="propertyIdValue"],[data-orig-id="propertyIdValue"],#propertyIdValue');
        const cardPid = idEl ? String(idEl.textContent || "").trim() : "";
        if (cardPid && cardPid !== pid) return;

        const nameEl = card.querySelector('[data-role="propertyName"],[data-orig-id="propertyName"],#propertyName');
        if (nameEl && name) nameEl.textContent = name;

        const metaEl = card.querySelector('[data-role="propertyMeta"],[data-orig-id="propertyMeta"],#propertyMeta');
        if (metaEl && location) metaEl.textContent = location;
      });

      // 3) Right-side summary
      try {
        const sp = document.getElementById("summaryProperty");
        if (sp && name) sp.textContent = name;
      } catch (_) {}
    }
    // === DB-AUTHORITATIVE PROPERTY META END ==================================

    function buildCartFromCurrentQuery(q) {
      const nowIso = new Date().toISOString();
      const lineId =
        "ln_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2, 8);

      return {
        version: 1,
        createdAt: nowIso,
        itinerary: {
          policy: "continuous_or_adjacent",
          currency: "PHP"
        },
        items: [
          {
            lineId,
            propertyId: q.propertyId || "",
            propertyName: q.propertyName || "",
            propertyLocation: q.propertyLocation || "",
            roomTypeId: q.roomId || "",
            roomName: q.roomName || "",
            ratePlanId: q.ratePlanId || "",
            planLabel: q.ratePlanName || "",
            qty: Number(q.qty || 1) || 1,
            start: q.start || "",
            end: q.end || ""
          }
        ]
      };
    }

    function migrateSelectionToCartIfNeeded(q) {
      // If cart already exists, do nothing.
      const existingCart = loadCartV1();
      if (existingCart && existingCart.version === 1 && Array.isArray(existingCart.items)) {
        return existingCart;
      }

      // NEW: If user arrived with a full selection in the URL but we have no cart yet
      // (common after cache wipe), bootstrap checkout.cart.v1 from the URL selection.
      const hasQuerySelection =
        q &&
        Number(q.propertyId) &&
        Number(q.roomId) &&
        Number(q.ratePlanId) &&
        q.start &&
        q.end;

      if (hasQuerySelection) {
        const cartFromUrl = buildCartFromCurrentQuery(q);
        saveCartV1(cartFromUrl);
        return cartFromUrl;
      }

      // If selection exists, create a cart (do not delete selection yet).
      let sel = null;
      try {
        sel = safeJsonParse(localStorage.getItem(SELECTION_KEY) || "");
      } catch (_) {
        sel = null;
      }
      if (!sel) return null;

      // Minimal migration: create cart from current query fields (stable + already in use today).
      const cart = buildCartFromCurrentQuery(q);
      saveCartV1(cart);
      return cart;
    }

    // Treat YYYY-MM-DD as a plain calendar date (no timezone)
    function parseLocalYMD(dateStr) {
      if (!dateStr) return null;
      const parts = dateStr.split("-");
      if (parts.length !== 3) return null;

      const year  = Number(parts[0]);
      const month = Number(parts[1]); // 1â€“12
      const day   = Number(parts[2]);

      if (!year || !month || !day) return null;
      const d = new Date(year, month - 1, day); // local midnight
      if (Number.isNaN(d.getTime())) return null;
      return d;
    }

    // Helper: format a Date as local YYYY-MM-DD (no timezone shift)
    function formatLocalYmd(d) {
      if (!d || !(d instanceof Date) || Number.isNaN(d.getTime())) return "";
      const y  = d.getFullYear();
      const m  = String(d.getMonth() + 1).padStart(2, "0");
      const dd = String(d.getDate()).padStart(2, "0");
      return `${y}-${m}-${dd}`;
    }

    function formatDate(dateStr) {
      const d = parseLocalYMD(dateStr);
      if (!d) return "";
      return d.toLocaleDateString(undefined, {
        year: "numeric",
        month: "short",
        day: "numeric"
      });
    }

    function diffNights(startStr, endStr) {
      const s = parseLocalYMD(startStr);
      const e = parseLocalYMD(endStr);
      if (!s || !e) return "";

      const ms = e.getTime() - s.getTime();
      const nights = Math.round(ms / (1000 * 60 * 60 * 24));
      return nights > 0 ? nights : "";
    }

    function formatCurrency(amount, currency) {
      const num = Number(amount);
      if (!Number.isFinite(num)) return "";

      const cur = currency || "USD";
      try {
        return new Intl.NumberFormat("en-US", {
          style: "currency",
          currency: cur,
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        }).format(num);
      } catch (_) {
        return "$" + num.toFixed(2);
      }
    }

    function renderNightlyBreakdown(nightsArr, currency) {
      const container = document.getElementById("breakdownDetails");
      if (!container) return;

      const cur = currency || (state && state.pricingCurrency) || "USD";

      // If cart mode, ignore nightsArr and aggregate across cart items using their per-card quotes.
      let isCartMode = false;
      let cart = null;
      try { cart = loadCartV1(); } catch (_) { cart = null; }
      if (cart && Array.isArray(cart.items) && cart.items.length) isCartMode = true;

      // Build a date-indexed aggregation: date -> { rooms, total }
      const byDate = new Map();

      function add(dateStr, rooms, amt) {
        const k = String(dateStr || "");
        if (!k) return;
        if (!byDate.has(k)) byDate.set(k, { rooms: 0, total: 0 });
        const o = byDate.get(k);
        o.rooms += rooms;
        o.total += amt;
      }

      if (isCartMode) {
        // Pull card-level quote nights from the DOM (each card already applied a quote)
        const cards = Array.from(
          document.querySelectorAll('.section-body[data-section-body="1"] .dates-grid[data-lineid]')
        );

        // Map lineId -> qty from cart
        const qtyByLine = new Map();
        cart.items.forEach(it => {
          const lid = String(it.lineId || "");
          const q = Math.max(1, Number.parseInt(String(it.qty || 1), 10) || 1);
          if (lid) qtyByLine.set(lid, q);
        });

        cards.forEach(card => {
          const lid = String(card.getAttribute("data-lineid") || "");
          const qn = qtyByLine.get(lid) || 1;

          // Prefer cached quote nights (set by applyCheckoutQuote/applyQuoteToCard)
          // Fallback to parsing from state.pricingNights only if needed
          let nights = null;

          try {
            // Some builds store JSON on card.dataset.quoteNights; if not present, ignore
            if (card.dataset && card.dataset.quoteNights) {
              nights = JSON.parse(card.dataset.quoteNights);
            }
          } catch (_) { nights = null; }

          // If dataset isn't present, we can scrape the per-night amounts from the DOM is not reliable,
          // so instead we re-fetch from the last quote payload stored on window (if present).
          if (!Array.isArray(nights)) {
            // As a fallback, use state.pricingNights ONLY when there is a single card
            nights = null;
          }

          // Best-effort: if we can't read per-card nights, use the per-card total spread evenly (still correct totals)
          if (!Array.isArray(nights)) {
            const lineTotal = Number(card.dataset ? card.dataset.lineTotal : NaN);
            const nn = Number(card.querySelector('[data-orig-id="stayNights"]')?.textContent || 0);
            const nightsCount = Number.isFinite(nn) && nn > 0 ? nn : 0;

            if (Number.isFinite(lineTotal) && lineTotal > 0 && nightsCount > 0) {
              // We donâ€™t know dates; skip in this fallback
              return;
            }
            return;
          }

          nights.forEach(n => {
            const dt = String(n.date || n.dt || n.day || "");
            const raw =
              n && n.amount !== undefined ? n.amount :
              n && n.price  !== undefined ? n.price  :
              n && n.value  !== undefined ? n.value  : 0;

            const amt = Number(raw);
            if (!dt || !Number.isFinite(amt)) return;
            add(dt, qn, amt * qn);
          });
        });
      } else {
        // Non-cart: use nightsArr and state.qty
        const qn = Math.max(1, Number.parseInt(String((state && state.qty) || 1), 10) || 1);
        (Array.isArray(nightsArr) ? nightsArr : []).forEach(n => {
          const dt = String(n.date || n.dt || n.day || "");
          const raw =
            n && n.amount !== undefined ? n.amount :
            n && n.price  !== undefined ? n.price  :
            n && n.value  !== undefined ? n.value  : 0;

          const amt = Number(raw);
          if (!dt || !Number.isFinite(amt)) return;
          add(dt, qn, amt * qn);
        });
      }

      // Render breakdown lines
      const dates = Array.from(byDate.keys()).sort();
      const parts = [];

      dates.forEach(d => {
        const rec = byDate.get(d);
        const rooms = rec.rooms || 0;
        const total = rec.total || 0;
        const avg = rooms > 0 ? (total / rooms) : 0;

        const label = formatDate(d) || d;
        const left = `${label} Ã— ${rooms} room${rooms === 1 ? "" : "s"} Ã— ${formatCurrency(avg, cur)}`;
        const right = formatCurrency(total, cur);

        parts.push(
          '<div class="breakdown-line">' +
            '<span>' + left + '</span>' +
            '<span></span>' +
            '<span>' + right + '</span>' +
          '</div>'
        );
      });

      // Stay total
      const stayTotalNum = dates.reduce((sum, d) => sum + (byDate.get(d)?.total || 0), 0);

      parts.push(
        '<div class="breakdown-line" style="margin-top:6px;font-weight:700;font-size:1.05rem;">' +
          '<span style="font-size:1.05rem;">Stay total</span>' +
          '<span></span>' +
          '<span style="font-size:1.05rem;">' + formatCurrency(stayTotalNum, cur) + '</span>' +
        '</div>'
      );

      // Spacer between Stay total and add-ons
      parts.push('<div class="breakdown-line" style="height:6px;"></div>');

      // Add-ons breakdown (existing)
      const addons = Array.isArray(state.selectedAddons) ? state.selectedAddons : [];
      const addonsSubtotalNum = Number(state.addonsSubtotal || 0);

      addons.forEach(function (item) {
        if (!item) return;
        const qty = Number(item.quantity || 0);
        const name = String(item.activity || item.name || item.label || "Add-on");
        if (!Number.isFinite(qty) || qty <= 0) return;
        const unit = Number(item.price || 0);
        const amt = unit * qty;
        const left = `${name} Â· Qty ${qty}`;
        const amtText = formatCurrency(amt, cur);
        parts.push(
          '<div class="breakdown-line">' +
            '<span>' + left + '</span>' +
            '<span></span>' +
            '<span>' + amtText + '</span>' +
          '</div>'
        );
      });

      parts.push(
        '<div class="breakdown-line" style="font-weight:700;font-size:1.05rem;margin-top:4px;">' +
          '<span style="font-size:1.05rem;">Add-ons total</span>' +
          '<span></span>' +
          '<span style="font-size:1.05rem;">' + formatCurrency(addonsSubtotalNum, cur) + '</span>' +
        '</div>'
      );

      container.innerHTML = parts.join("");
    }

    function renderAddonsInlineSummary(subtotalOverride) {
      const listEl       = document.getElementById("addonsList");
      const totalWrapper = document.getElementById("addonsInlineTotalWrapper");
      const totalSpan    = document.getElementById("addonsInlineTotal");

      if (!listEl) return;

      const selections = Array.isArray(state.selectedAddons)
        ? state.selectedAddons.filter(function (s) {
            const q = Number(s.quantity || 0);
            return q > 0;
          })
        : [];

      const cur = state.pricingCurrency || "USD";

      listEl.innerHTML = "";

      if (!selections.length) {
        listEl.style.display = "none";
        if (totalWrapper) totalWrapper.style.display = "none";
        if (totalSpan) totalSpan.textContent = "--";
        return;
      }

      listEl.style.display = "block";

      const ul = document.createElement("ul");
      ul.style.listStyle = "none";
      ul.style.padding = "0";
      ul.style.margin = "0";

      let subtotal = 0;

      selections.forEach(function (sel) {
        const li = document.createElement("li");
        li.style.display = "flex";
        li.style.justifyContent = "space-between";
        li.style.alignItems = "baseline";
        li.style.fontSize = "13px";
        li.style.marginBottom = "4px";

        const left = document.createElement("span");
        left.textContent =
          ((sel.activity || sel.name || sel.label || "Add-on")) +
          " Â· Qty " +
          (sel.quantity != null ? sel.quantity : 0);

        const right = document.createElement("span");
        const lt = Number(sel.lineTotal);
        if (Number.isFinite(lt) && lt > 0) {
          right.textContent = formatCurrency(lt, cur);
          subtotal += lt;
        } else {
          right.textContent = "--";
        }

        li.appendChild(left);
        li.appendChild(right);
        ul.appendChild(li);
      });

      listEl.appendChild(ul);

      const finalSubtotal =
        typeof subtotalOverride === "number" && subtotalOverride > 0
          ? subtotalOverride
          : subtotal;

      if (totalSpan) {
        totalSpan.textContent =
          finalSubtotal > 0 ? formatCurrency(finalSubtotal, cur) : "--";
      }
      if (totalWrapper) {
        totalWrapper.style.display = finalSubtotal > 0 ? "block" : "none";
      }
    }

    function recomputeSelectedAddons() {
      const modalBody = document.getElementById("addonsModalBody");
      const listEl    = document.getElementById("addonsList");

      // Use the same root container as renderAddons:
      // prefer modal body, fall back to inline list.
      const root = modalBody || listEl;
      if (!root) return;

      const qtyInputs = root.querySelectorAll(
        'input[type="number"][data-addon-index]'
      );
      const commentAreas = root.querySelectorAll(
        'textarea.addon-comment[data-addon-index]'
      );

      const commentsByIndex = {};
      commentAreas.forEach(function (ta) {
        const idxAttr = ta.getAttribute("data-addon-index");
        const idx = Number(idxAttr);
        if (!Number.isFinite(idx) || idx < 0) return;
        commentsByIndex[idx] = ta.value || "";
      });

      const selections    = [];
      const selectionsMap = {};
      let subtotal        = 0;

      qtyInputs.forEach(function (input) {
        const idxAttr = input.getAttribute("data-addon-index");
        const idx = Number(idxAttr);
        if (!Number.isFinite(idx) || idx < 0) return;

        const qty = Number(input.value || "0");
        if (!Number.isFinite(qty) || qty <= 0) {
          return;
        }

        const cfg = Array.isArray(state.addonsConfig)
          ? state.addonsConfig[idx]
          : null;
        if (!cfg) return;

        const rawPrice = cfg.price;
        const price =
          typeof rawPrice === "number"
            ? rawPrice
            : (rawPrice != null ? Number(rawPrice) : NaN);

        const lineTotal =
          !Number.isNaN(price) && Number.isFinite(price)
            ? price * qty
            : null;

        selections.push({
          index: idx,
          quantity: qty,
          activity: (cfg.activity || "").toString().trim(),
          uom: (cfg.uom || "").toString().trim(),
          price: !Number.isNaN(price) && Number.isFinite(price) ? price : null,
          lineTotal,
          travelerComment: commentsByIndex[idx] || ""
        });

        selectionsMap[idx] = qty;
        if (lineTotal != null && Number.isFinite(lineTotal)) {
          subtotal += lineTotal;
        }
      });

      state.selectedAddons   = selections;
      state.addonsSelections = selectionsMap;
      state.addonsSubtotal   = subtotal;          // <-- store add-ons subtotal

      const subtotalEl = document.getElementById("addonsModalSubtotal");
      if (subtotalEl) {
        if (subtotal > 0) {
          const cur = state.pricingCurrency || "USD";
          subtotalEl.textContent = formatCurrency(subtotal, cur);
        } else {
          subtotalEl.textContent = "--";
        }
      }

      // Inline summary under Section 3 (between Explore and Confirm)
      renderAddonsInlineSummary(subtotal);

      // Update final grand total (base + add-ons)
      updateGrandTotal();

      // Also refresh main summaries (Your stay)
      updateSummaries();
      updateAddonsSummary();

      // Refresh right-hand breakdown so it includes add-ons
      if (Array.isArray(state.pricingNights) && state.pricingNights.length) {
        renderNightlyBreakdown(
          state.pricingNights,
          state.pricingCurrency || "USD"
        );
      }
    }

    function updateGrandTotal() {
      const totalEl = document.getElementById("summaryTotal");
      if (!totalEl) return;

    let currency = state.pricingCurrency || "USD";
    let base = 0;

    // CART MODE: sum totals from each rendered card
    try {
      const cart = loadCartV1();
      const inCartMode = !!(cart && Array.isArray(cart.items) && cart.items.length);

      if (inCartMode) {
        const cards = Array.from(
          document.querySelectorAll('.section-body[data-section-body="1"] .dates-grid[data-lineid]')
        );

        cards.forEach((card) => {
          const v = Number(card.dataset ? card.dataset.lineTotal : NaN);
          if (Number.isFinite(v) && v > 0) base += v;

          const c = card.dataset ? String(card.dataset.lineCurrency || "") : "";
          if (c && !currency) currency = c;
        });
      }
    } catch (_) {}

    // FALLBACK (non-cart mode): keep existing behavior
    if (!Number.isFinite(base) || base <= 0) {
      if (typeof state.pricingTotal === "number" &&
          Number.isFinite(state.pricingTotal) &&
          state.pricingTotal > 0) {
        base = state.pricingTotal;
      } else if (typeof state.baseRoomTotal === "number" &&
                Number.isFinite(state.baseRoomTotal) &&
                state.baseRoomTotal > 0) {
        const qn = Math.max(1, Number.parseInt(String(state.qty || 1), 10) || 1);
        base = state.baseRoomTotal * qn;
      }
    }

      const addons = Number(state.addonsSubtotal || 0);

      // If we don't yet have a meaningful base, don't overwrite placeholder
      if (!Number.isFinite(base) || base <= 0) return;

      const grand = base + (Number.isFinite(addons) ? addons : 0);
      totalEl.textContent = formatCurrency(grand, currency);
    }

    const state = {
      propertyId: "",
      roomId: "",
      qty: 1,
      start: "",
      end: "",
      ratePlanId: "",
      propertyName: "",
      propertyLocation: "",
      roomName: "",
      ratePlanName: "",
      sectionConfirmed: { 1: false, 2: false, 3: false, 4: false },
      addonsConfig: [],
      addonsSelections: {},

      // Pricing / quote from /catalog/details
      pricingTotal: 0,
      pricingCurrency: "USD",
      pricingNights: [] // [{ date, amount }, ...]
    };

    // ANCHOR: PAYMENT_GRAND_TOTAL_HELPER
    function computeGrandTotalForPayment(){
      let currency = state.pricingCurrency || "USD";
      let base = 0;

      // CART MODE: sum totals from each rendered card (same as updateGrandTotal)
      try {
        const cart = loadCartV1();
        const inCartMode = !!(cart && Array.isArray(cart.items) && cart.items.length);

        if (inCartMode) {
          const cards = Array.from(
            document.querySelectorAll('.section-body[data-section-body="1"] .dates-grid[data-lineid]')
          );

          cards.forEach((card) => {
            const v = Number(card.dataset ? card.dataset.lineTotal : NaN);
            if (Number.isFinite(v) && v > 0) base += v;

            const c = card.dataset ? String(card.dataset.lineCurrency || "") : "";
            if (c && !currency) currency = c;
          });
        }
      } catch (_) {}

      // FALLBACK (non-cart)
      if (!Number.isFinite(base) || base <= 0) {
        if (typeof state.pricingTotal === "number" && Number.isFinite(state.pricingTotal) && state.pricingTotal > 0) {
          base = state.pricingTotal;
        } else if (typeof state.baseRoomTotal === "number" && Number.isFinite(state.baseRoomTotal) && state.baseRoomTotal > 0) {
          const qn = Math.max(1, Number.parseInt(String(state.qty || 1), 10) || 1);
          base = state.baseRoomTotal * qn;
        }
      }

      const addons = Number(state.addonsSubtotal || 0);
      const grand = base + (Number.isFinite(addons) ? addons : 0);

      return { currency, base, addons, grand };
    }
    // ANCHOR: PAYMENT_GRAND_TOTAL_HELPER END

    function updateSummaries() {
      // CART MODE: only update the right-side summary panel.
      try {
        const cart = loadCartV1();
        if (cart && Array.isArray(cart.items) && cart.items.length) {
          const items = cart.items.slice();

          // Property
          const propIds = Array.from(new Set(items.map(it => String(it.propertyId || "")))).filter(Boolean);
          const propLabel = (propIds.length <= 1)
            ? String(items[0].propertyName || items[0].propertyId || "Property")
            : "Multiple properties";
          const sp = document.getElementById("summaryProperty");
          if (sp) sp.textContent = propLabel;

          // Dates (earliest start -> latest end)
          const starts = items.map(it => String(it.start || "")).filter(Boolean).sort();
          const ends   = items.map(it => String(it.end   || "")).filter(Boolean).sort();
          const earliest = starts.length ? starts[0] : "";
          const latest   = ends.length ? ends[ends.length - 1] : "";

          const sd = document.getElementById("summaryDates");
          if (sd) {
            const sFmt = formatDate(earliest);
            const eFmt = formatDate(latest);
            sd.textContent = (sFmt && eFmt) ? (sFmt + " to " + eFmt) : "Dates";
          }

          // Rooms (sum qty)
          const roomsTotal = items.reduce((sum, it) => {
            const q = Math.max(1, Number.parseInt(String(it.qty || 1), 10) || 1);
            return sum + q;
          }, 0);
          const srooms = document.getElementById("summaryRooms");
          if (srooms) srooms.textContent = (roomsTotal === 1) ? "1 room" : `${roomsTotal} rooms`;

          // Nights (sum nights * qty)
          const nightsTotal = items.reduce((sum, it) => {
            const n = stayNightsFromRange(String(it.start || ""), String(it.end || ""));
            const q = Math.max(1, Number.parseInt(String(it.qty || 1), 10) || 1);
            return sum + (Number.isFinite(n) ? n : 0) * q;
          }, 0);

          const snVis = document.getElementById("summaryNightsVisible");
          if (snVis) snVis.textContent = (nightsTotal > 0) ? String(nightsTotal) : "--";

          const sn = document.getElementById("summaryNights");
          if (sn) sn.textContent = (nightsTotal > 0)
            ? (nightsTotal + " night" + (nightsTotal === 1 ? "" : "s"))
            : "--";

          return; // IMPORTANT: inside the function
        }
      } catch (_) {}

      // NON-CART MODE: keep existing legacy summary behavior below (do not change)
      // (leave the rest of your original updateSummaries() code as-is here)
    }

        function updateAddonsSummary() {
      // Count how many distinct add-ons have qty > 0
      const selections = state.addonsSelections || {};
      const selectedCount = Object.values(selections).reduce((acc, qty) => {
        const n = typeof qty === "number" ? qty : parseInt(qty, 10);
        return acc + (n > 0 ? 1 : 0);
      }, 0);

      const summaryEl = document.getElementById("summaryAddons");
      if (summaryEl) {
        summaryEl.textContent =
          selectedCount > 0
            ? selectedCount + " add-on" + (selectedCount > 1 ? "s" : "") + " selected"
            : "None selected";
      }
    }

    function renderAddons(addons) {
      const listEl    = document.getElementById("addonsList");
      const modalBody = document.getElementById("addonsModalBody");
      const emptyEl   = document.getElementById("addonsEmptyMessage");

      const rows = Array.isArray(addons) ? addons : [];
      state.addonsConfig = rows;

      // If neither container exists, nothing to do
      if (!listEl && !modalBody) return;

      // Clear both containers (we primarily use the modal body)
      if (listEl) listEl.innerHTML = "";
      if (modalBody) modalBody.innerHTML = "";

      if (!rows.length) {
        if (emptyEl) {
          emptyEl.textContent = "No add-ons are available for this stay.";
          emptyEl.style.display = "block";
        }
        return;
      }

      if (emptyEl) {
        emptyEl.style.display = "none";
      }

      // Prefer modal body; fall back to inline list if modal not present
      const target = modalBody || listEl;

      // ---------- Header row: 5 columns ----------
      const header = document.createElement("div");
      header.className = "addon-row addon-row-header";

      function makeHeaderCell(className, text) {
        const el = document.createElement("div");
        el.className = "addon-col " + className;
        el.textContent = text;
        return el;
      }

      header.appendChild(makeHeaderCell("addon-col-activity", "Activity"));
      header.appendChild(makeHeaderCell("addon-col-uom", "Unit"));
      header.appendChild(makeHeaderCell("addon-col-price", "Price per unit"));
      header.appendChild(makeHeaderCell("addon-col-qty", "Qty"));
      header.appendChild(makeHeaderCell("addon-col-total", "Total"));

      target.appendChild(header);

      // ---------- Data rows: 5 columns ----------
      rows.forEach(function (addon, idx) {
        const activity = (addon.activity || "").toString().trim() || "Add-on";
        const uom      = (addon.uom || "").toString().trim();
        const notes    = (addon.notes || "").toString().trim();
        const rawPrice = addon.price;

        const price =
          typeof rawPrice === "number"
            ? rawPrice
            : rawPrice != null
            ? Number(rawPrice)
            : NaN;

        const hasNumericPrice = !Number.isNaN(price) && Number.isFinite(price);
        const priceText = hasNumericPrice
          ? formatCurrency(price, state.pricingCurrency || "USD")
          : "Price TBD";

        const row = document.createElement("div");
        row.className = "addon-row";

        // Column 1: Activity (and optional notes)
        const colActivity = document.createElement("div");
        colActivity.className = "addon-col addon-col-activity";

        const titleEl = document.createElement("div");
        titleEl.className = "addon-title";
        titleEl.textContent = activity;
        colActivity.appendChild(titleEl);

        if (notes) {
          const notesEl = document.createElement("div");
          notesEl.className = "addon-notes";
          notesEl.textContent = notes;
          colActivity.appendChild(notesEl);
        }

        // Column 2: UoM
        const colUom = document.createElement("div");
        colUom.className = "addon-col addon-col-uom";
        colUom.textContent = uom || "â€”";

        // Column 3: Price per UoM
        const colPrice = document.createElement("div");
        colPrice.className = "addon-col addon-col-price";
        colPrice.textContent = priceText;

        // Column 4: Qty (with input)
        const colQty = document.createElement("div");
        colQty.className = "addon-col addon-col-qty";

        const key = String(idx);
        const currentQty =
          state.addonsSelections && typeof state.addonsSelections[key] === "number"
            ? state.addonsSelections[key]
            : 0;

        const qtyInput = document.createElement("input");
        qtyInput.type = "number";
        qtyInput.min = "0";
        qtyInput.step = "1";
        qtyInput.value = currentQty > 0 ? String(currentQty) : "0";
        qtyInput.setAttribute("data-addon-index", String(idx));

        colQty.appendChild(qtyInput);

        // Column 5: Subtotal for this row
        const colTotal = document.createElement("div");
        colTotal.className = "addon-col addon-col-total addon-line-total";

        function refreshLineTotal() {
          const q = parseInt(qtyInput.value, 10);
          if (!hasNumericPrice || isNaN(q) || q <= 0) {
            colTotal.textContent = "";
            return;
          }
          const total = q * price;
          colTotal.textContent = formatCurrency(
            total,
            state.pricingCurrency || "USD"
          );
        }

        qtyInput.addEventListener("input", function () {
          const val = parseInt(qtyInput.value, 10);
          if (isNaN(val) || val <= 0) {
            if (state.addonsSelections) {
              delete state.addonsSelections[key];
            }
          } else {
            if (!state.addonsSelections) state.addonsSelections = {};
            state.addonsSelections[key] = val;
          }
          refreshLineTotal();
          recomputeSelectedAddons();
        });

        // Prevent mouse-wheel from changing the value while scrolling the page
        qtyInput.addEventListener(
          "wheel",
          function (e) {
            e.preventDefault();
          },
          { passive: false }
        );

        // Initial subtotal render
        refreshLineTotal();

        row.appendChild(colActivity);
        row.appendChild(colUom);
        row.appendChild(colPrice);
        row.appendChild(colQty);
        row.appendChild(colTotal);

        target.appendChild(row);
      });

      // After initial render, compute subtotal + summary once
      recomputeSelectedAddons();
    }

    function openAddonsModal() {
      const backdrop = document.getElementById("addonsModalBackdrop");
      if (!backdrop) {
        console.warn("[addonsModal] backdrop not found");
        return;
      }

      // Make sure it is visible even if CSS is missing
      backdrop.style.display = "flex";
      backdrop.classList.add("is-open");
      backdrop.setAttribute("aria-hidden", "false");

      console.log("[addonsModal] open");
    }

    function closeAddonsModal() {
      const backdrop = document.getElementById("addonsModalBackdrop");
      if (!backdrop) return;

      backdrop.classList.remove("is-open");
      backdrop.setAttribute("aria-hidden", "true");
      backdrop.style.display = "none";

      console.log("[addonsModal] close");
    }

    // Delegate clicks for add-ons modal (open / close / apply)
    document.addEventListener("click", function (evt) {
      const target = evt.target;
      if (!(target instanceof HTMLElement)) return;

      // Open trigger (pill in section 3)
      if (target.closest("[data-open-addons-modal]")) {
        evt.preventDefault();
        openAddonsModal();
        return;
      }

      // Close triggers: explicit close buttons or clicking backdrop
      if (
        target.closest("[data-close-addons-modal]") ||
        target.id === "addonsModalBackdrop"
      ) {
        evt.preventDefault();
        closeAddonsModal();
        return;
      }

      // Apply: recompute selections + subtotal, then close
      if (target.closest("[data-apply-addons-modal]")) {
        evt.preventDefault();
        if (typeof recomputeSelectedAddons === "function") {
          recomputeSelectedAddons();
        }
        closeAddonsModal();
      }
    });

    // Helper: read IDs/dates from the URL so add-ons do not depend on state wiring
    function getCheckoutIdsFromQuery() {
      const qs = new URLSearchParams(location.search);
      const propertyId = qs.get("propertyId") || "";
      const start      = qs.get("start") || "";
      const end        = qs.get("end") || "";
      const ratePlanId = qs.get("ratePlanId");

      return {
        propertyId,
        start,
        end,
        ratePlanId: ratePlanId ? Number(ratePlanId) : null
      };
    }

    async function loadAddonsForProperty() {
      const q = parseQuery();

      // Prefer state.propertyId, otherwise use query param.
      // DO NOT coerce missing/blank to 0 - that's an invalid checkout state.
      const rawPropertyId =
        (state.propertyId != null && String(state.propertyId).trim()) ||
        (q.propertyId != null && String(q.propertyId).trim()) ||
        "";

      const propertyId = rawPropertyId ? Number(rawPropertyId) : NaN;

      if (!Number.isFinite(propertyId) || propertyId <= 0) {
        console.error("[checkout] invalid/missing propertyId", {
          rawPropertyId,
          href: location.href,
          statePropertyId: state.propertyId,
          qPropertyId: q.propertyId
        });

        // If cart is empty or user is just landing on /checkout.html, let the empty-state UI handle it.
        return;
      }

      // Dates: prefer the current state, fall back to query
      const start = state.start || q.start || "";
      const end   = state.end   || q.end   || "";

      if (!start || !end) {
        console.log("[checkout] loadAddonsForProperty missing params", { propertyId, start, end });
        return;
      }

      // Keep state in sync once we have a solid id
      state.propertyId = String(propertyId);

      try {
        const params = new URLSearchParams();
        params.set("propertyId", String(propertyId));
        params.set("start", start);
        params.set("end", end);

        // IMPORTANT: do not filter by ratePlanId here.
        // The DB uses its own internal rate plan IDs (8,11,12,...) which
        // don't match the front-end ids (1,2,3). Filtering here was
        // stripping out all room/price data.
        if (q.ratePlanId) params.set("ratePlanId", String(q.ratePlanId));

        const url = "/catalog/details?" + params.toString();
        console.log("[checkout] details URL", url);

        const resp = await fetch(url, {
          method: "GET",
          headers: { Accept: "application/json" }
        });

        if (!resp.ok) {
          console.warn("[checkout] /catalog/details for addons failed", resp.status);
          state.addonsConfig = [];
          renderAddons([]);
          return;
        }

        const data = await resp.json();

        // Debug: full /catalog/details payload used by checkout
        console.log("[checkout] details raw", data);
        window.__checkoutDetailsPayload = data;

        // Enforce DB-authoritative property labels (prevents blank/wrong names from URL/cart drift)
        const dbMeta = resolveDbPropertyMeta(data);
        applyDbPropertyMetaToCartAndUI(String(propertyId), dbMeta);

        // Keep state aligned (used for payment payload + any legacy surfaces)
        if (dbMeta && dbMeta.name) state.propertyName = String(dbMeta.name);
        if (dbMeta && dbMeta.location) state.propertyLocation = String(dbMeta.location);

        const addons = Array.isArray(data.addons) ? data.addons : [];
        state.addonsConfig = addons;
        console.log("[checkout] addons from details", {
          propertyId, start, end, count: addons.length, addons
        });
        renderAddons(addons);

        // Apply backend pricing quote if present, otherwise derive from rooms[].daily
        if (data && typeof data === "object" && data.checkoutQuote) {
          const quote = data.checkoutQuote;
          console.log("[checkout] applying checkoutQuote", quote);

          const baseTotal = Number(quote && quote.total);
          if (Number.isFinite(baseTotal)) state.baseRoomTotal = baseTotal;

          applyCheckoutQuote(quote);
        } else {
          try {
            const roomsArr = Array.isArray(data.rooms) ? data.rooms : [];
            if (!roomsArr.length) return;

            const qRoomId = q.roomId ? Number(q.roomId) : NaN;
            let chosen = null;

            if (Number.isFinite(qRoomId)) {
              chosen =
                roomsArr.find(r => {
                  const rtId = Number((r && (r.roomTypeId != null ? r.roomTypeId : r.id)));
                  return Number.isFinite(rtId) && rtId === qRoomId;
                }) || null;
            }
            if (!chosen) chosen = roomsArr[0];

            const daily = Array.isArray(chosen.daily) ? chosen.daily : [];
            const msPerDay = 24 * 60 * 60 * 1000;
            const startDate = new Date(start + "T00:00:00Z");
            const endDate   = new Date(end   + "T00:00:00Z");
            const nights = [];

            for (let t = startDate.getTime(); t < endDate.getTime(); t += msPerDay) {
              const iso = new Date(t).toISOString().slice(0, 10);
              const rec = daily.find(d => d && d.date === iso);
              if (!rec) continue;

              const val = rec.price != null ? Number(rec.price) : NaN;
              if (!Number.isFinite(val) || val <= 0) continue;

              nights.push({ date: iso, amount: val });
            }

            const total = nights.reduce((sum, n) => sum + n.amount, 0);
            if (!nights.length || !Number.isFinite(total) || total <= 0) return;

            const curRow = daily.find(d => d && d.currency) || null;
            const curCode = curRow && curRow.currency ? String(curRow.currency) : "USD";

            const quote = { source: "db", currency: curCode, total, nights };
            console.log("[checkout] applying derived checkoutQuote", quote);
            applyCheckoutQuote(quote);
          } catch (e) {
            console.warn("[checkout] failed to derive checkoutQuote from rooms", e);
          }
        }
      } catch (err) {
        console.error("[checkout] loadAddonsForProperty error", err);
        state.addonsConfig = [];
        renderAddons([]);
      }
    }

    // ================================
    // FETCH QUOTE FOR A SINGLE CARD
    // ================================
    async function getQuoteForRoom({ propertyId, roomId, start, end, ratePlanId }) {
      if (!propertyId || !roomId || !start || !end) {
        console.warn("[checkout] getQuoteForRoom missing params", {
          propertyId, roomId, start, end, ratePlanId
        });
        return null;
      }

      const qs = new URLSearchParams();
      qs.set("propertyId", String(propertyId));
      qs.set("roomId", String(roomId));
      qs.set("start", start);
      qs.set("end", end);

      // Ask backend for the selected plan quote
      if (ratePlanId != null && String(ratePlanId).trim()) {
        qs.set("ratePlanId", String(ratePlanId).trim());
      }

      const url = "/catalog/details?" + qs.toString();
      console.log("[checkout] card quote URL", url);

      const resp = await fetch(url, {
        headers: { Accept: "application/json" }
      });

      if (!resp.ok) {
        console.warn("[checkout] card quote fetch failed", resp.status);
        return null;
      }

      const data = await resp.json();
      return data && data.checkoutQuote ? data.checkoutQuote : null;
    }

    function applyQuoteToCard(cardEl, quote, qty) {
      if (!cardEl || !quote) return;

      const q = Math.max(1, Number(qty || 1));

      const total = Number(quote.total || 0);
      const nightsArr = Array.isArray(quote.nights) ? quote.nights : [];
      // Cache per-card nights for cart breakdown aggregation
      try { cardEl.dataset.quoteNights = JSON.stringify(nightsArr); } catch (_) {}

      const nights = nightsArr.length || 0;

      // Avg is per-night per-room (do NOT multiply by qty)
      const avg = nights > 0 ? (total / nights) : 0;

      // Total shown on the card should reflect qty rooms
      const totalScaled = total * q;

      const pickAll = (role, legacyId) => {
        const sel = [
          `[data-role="${role}"]`,
          `[data-orig-id="${role}"]`,
          `[id^="${legacyId}__li"]`,
          `#${legacyId}`
        ].join(",");
        return Array.from(cardEl.querySelectorAll(sel));
      };

      const cur = quote.currency || "";
      const fmtMoney = (v) => {
        const n = Number(v || 0);
        const s = n.toFixed(0);
        if (cur === "USD") return "$" + s;
        if (cur) return cur + " " + s;
        return "$" + s;
      };

      // Primary targets (data-role / legacy ids)
      const nightsNodes = pickAll("stayNights", "stayNights");
      const avgNodes    = pickAll("avgNightPrice", "avgNightPrice");
      const totalNodes  = pickAll("totalPill", "totalPill");

      // Fallback targets (current checkout card markup)
      // - Nights value cell
      // - Avg price/night value cell
      // - Total pill (circled)
      const nightsFallback = Array.from(cardEl.querySelectorAll(
        '[data-field="nights"], .nights-val, .stay-nights, [aria-label="Nights"], .pricing-row .nights'
      ));
      const avgFallback = Array.from(cardEl.querySelectorAll(
        '[data-field="avgNight"], .avg-night-val, .avgNight, .avg-night, .pricing-row .avg'
      ));
      const totalFallback = Array.from(cardEl.querySelectorAll(
        '[data-field="lineTotal"], .total-pill, .price-pill, .pill, .pricing-total'
      ));

      const setText = (nodes, text) => nodes.forEach(el => { if (el) el.textContent = text; });

      setText(nightsNodes.length ? nightsNodes : nightsFallback, String(nights));
      setText(avgNodes.length ? avgNodes : avgFallback, fmtMoney(avg));
      setText(totalNodes.length ? totalNodes : totalFallback, fmtMoney(totalScaled));

      console.log("[checkout] applyQuoteToCard wrote", {
        nights,
        avg,
        totalScaled,
        nightsTargets: nightsNodes.length,
        avgTargets: avgNodes.length,
        totalTargets: totalNodes.length,
        nightsFallback: nightsFallback.length,
        avgFallback: avgFallback.length,
        totalFallback: totalFallback.length
      });

      // Store numeric totals on the card so cart summary can sum across cards
      try {
        cardEl.dataset.lineTotal = String(totalScaled);         // numeric (qty-scaled)
        cardEl.dataset.lineCurrency = String(cur || "USD");     // currency hint
      } catch (_) {}

      // Refresh right summary total in cart mode
      try { updateGrandTotal(); } catch (_) {}
    }

    function applyCheckoutQuote(quote) {
      console.log("[checkout] applyCheckoutQuote source/isFinal", {
        source: quote && quote.source,
        isFinal: quote && quote.isFinal,
        currency: quote && quote.currency,
        total: quote && quote.total,
        nightsCount: quote && quote.nights ? quote.nights.length : 0
      });

      if (!quote || typeof quote !== "object") return;

      // Start from backend quote
      var nightsArr = Array.isArray(quote.nights)
        ? quote.nights.map(function (n) { return Object.assign({}, n); })
        : [];

      // 1) Base total from backend (before plan adjustments)
      var baseTotal = 0;
      if (typeof quote.total === "number" && Number.isFinite(quote.total)) {
        baseTotal = Number(quote.total);
      } else if (nightsArr.length) {
        baseTotal = nightsArr.reduce(function (sum, n) {
          var v = Number(
            n.amount !== undefined ? n.amount :
            n.price  !== undefined ? n.price  :
            n.value  !== undefined ? n.value  : 0
          );
          return sum + (Number.isFinite(v) ? v : 0);
        }, 0);
      }

      if (!Number.isFinite(baseTotal) || baseTotal <= 0) {
        // No valid total â€“ keep existing placeholder
        return;
      }

      // 2) Adjust for selected rate plan (legacy surface logic)
      // If backend says the quote is DB-final, do NOT re-adjust here.
      var adjustedNights = nightsArr;
      var totalNumeric = baseTotal;

      var isDbFinal = !!(quote && (quote.source === "db" || quote.isFinal === true));
      console.log("[checkout] applyCheckoutQuote isDbFinal", isDbFinal);

      if (!isDbFinal) {
        try {
          var q = parseQuery();
          var rpId = q && q.ratePlanId ? Number(q.ratePlanId) : NaN;

          function adjustNightAmount(amount, planId) {
            var base = Number(amount);
            if (!Number.isFinite(base)) return amount;

            // Keep these rules in sync with getPlanPriceForRoom in catalog_details.html
            if (planId === 1) return base;                       // Standard
            if (planId === 2) return Math.round(base * 0.9 * 100) / 100; // Non-refundable: -10%
            if (planId === 3) return base + 10;                  // With Breakfast: +10
            return base;
          }

          if (Number.isFinite(rpId) && nightsArr.length) {
            adjustedNights = nightsArr.map(function (n) {
              var raw = n.amount !== undefined ? n.amount :
                        n.price  !== undefined ? n.price  :
                        n.value  !== undefined ? n.value  : 0;
              var adj = adjustNightAmount(raw, rpId);
              var clone = Object.assign({}, n);
              clone.amount = adj;
              return clone;
            });

            totalNumeric = adjustedNights.reduce(function (sum, n) {
              var v = Number(n.amount);
              return sum + (Number.isFinite(v) ? v : 0);
            }, 0);
          }
        } catch (e) {
          console.warn("[checkout] applyCheckoutQuote adjust failed", e);
        }
      }

      // 3) Apply room quantity (multiplies room-only totals and nightly amounts)
      var qtyNum = 1;
      try {
        qtyNum = Number.parseInt(String(state.qty || 1), 10);
        if (!Number.isFinite(qtyNum) || qtyNum < 1) qtyNum = 1;
      } catch (_) {
        qtyNum = 1;
      }

      if (qtyNum > 1 && Array.isArray(adjustedNights) && adjustedNights.length) {
        adjustedNights = adjustedNights.map(function (n) {
          var clone = Object.assign({}, n);
          var raw = Number(
            clone.amount !== undefined ? clone.amount :
            clone.price  !== undefined ? clone.price  :
            clone.value  !== undefined ? clone.value  : 0
          );
          var scaled = Number.isFinite(raw) ? (raw * qtyNum) : 0;
          clone.amount = Math.round(scaled * 100) / 100;
          return clone;
        });
        totalNumeric = Math.round((Number(totalNumeric) * qtyNum) * 100) / 100;
      }

      var currency = quote.currency || "USD";

      state.pricingTotal = totalNumeric;
      state.pricingCurrency = currency;
      state.pricingNights = adjustedNights;

      // Update summary total amount
      var totalEl = document.getElementById("summaryTotal");
      if (totalEl) {
        totalEl.textContent = formatCurrency(totalNumeric, currency);
      }

      // Update nightly breakdown using adjusted nights
      renderNightlyBreakdown(adjustedNights, currency);

      // Recompute per-night average and caption based on new total
      updateSummaries();
    }

    async function loadAddonsConfig() {
      const ids = getCheckoutIdsFromQuery();
      const propertyId = ids.propertyId;
      const roomId = ids.roomId;
      const start = ids.start;
      const end = ids.end;
      const ratePlanId = ids.ratePlanId;

      if (!propertyId || !start || !end) {
        console.log("[checkout] loadAddonsConfig skipped (missing ids/dates)", ids);
        return;
      }

      try {
        const params = new URLSearchParams();
        params.set("propertyId", propertyId);
        params.set("start", start);
        params.set("end", end);

        // CRITICAL: ensure backend builds checkoutQuote for the correct room
        if (roomId) {
          params.set("roomId", String(roomId));
        }

        if (Number.isFinite(ratePlanId)) {
          params.set("ratePlanId", String(ratePlanId));
        }

        const resp = await fetch("/catalog/details?" + params.toString(), {
          headers: { Accept: "application/json" }
        });

        if (!resp.ok) {
          console.warn("[checkout] /catalog/details for config failed", resp.status);
          return;
        }

        const data = await resp.json();

        // Debug tap: inspect the full details payload in checkout
        console.log("[checkout] details raw", data);
        window.__checkoutDetailsPayload = data;

        const addons = Array.isArray(data.addons) ? data.addons : [];
        console.log("[checkout] loadAddonsConfig got addons", addons);

        if (typeof state === "object") {
          state.addonsConfig = addons;
        }

        // Optional pricing quote from /catalog/details
        if (data && typeof data === "object" && data.checkoutQuote) {
          applyCheckoutQuote(data.checkoutQuote);
        }
      } catch (err) {
        console.error("[checkout] loadAddonsConfig error", err);
      }
    }

    function setSectionState(section, status) {
      const stepCircle = document.querySelector('[data-step-indicator="' + section + '"]');
      const statusLabel = document.querySelector('[data-step-status="' + section + '"]');
      const body = document.querySelector('[data-section-body="' + section + '"]');
      if (!stepCircle || !statusLabel || !body) return;

      if (status === "active") {
        stepCircle.classList.add("active");
        stepCircle.classList.remove("completed");
        statusLabel.textContent = "Waiting for confirmation";
        statusLabel.classList.remove("completed");
        body.classList.remove("hidden");
      } else if (status === "completed") {
        stepCircle.classList.remove("active");
        stepCircle.classList.add("completed");
        statusLabel.textContent = "Confirmed";
        statusLabel.classList.add("completed");
        body.classList.add("hidden");
      } else {
        stepCircle.classList.remove("active");
        stepCircle.classList.remove("completed");
        statusLabel.textContent = "Locked until previous step";
        statusLabel.classList.remove("completed");
        body.classList.add("hidden");
      }
    }

    function refreshSections() {
      for (let i = 1; i <= 4; i++) {
        const isConfirmed = state.sectionConfirmed[i];
        if (i === 1) {
          setSectionState(1, isConfirmed ? "completed" : "active");
        } else {
          const prevDone = state.sectionConfirmed[i - 1];
          if (!prevDone) {
            setSectionState(i, "locked");
          } else {
            setSectionState(i, isConfirmed ? "completed" : "active");
          }
        }
      }
      const allConfirmed =
        state.sectionConfirmed[1] &&
        state.sectionConfirmed[2] &&
        state.sectionConfirmed[3] &&
        state.sectionConfirmed[4];
      document.getElementById("confirmAndPayButton").disabled = !allConfirmed;
    }

    function setCheckoutEmptyStateVisible(isEmpty) {
      const box = document.getElementById("checkoutEmptyState");
      if (!box) return;
      box.style.display = isEmpty ? "" : "none";
    }

    function syncEmptyCheckoutUIFromCart() {
      let cart = null;
      try { cart = loadCartV1(); } catch (_) { cart = null; }
      const items = cart && Array.isArray(cart.items) ? cart.items : [];

      const root = document.getElementById("roomPriceCardsRoot");
      const tpl  = document.getElementById("roomPriceCardTemplate");

      const isEmpty = !items.length;

      // Show/hide the empty state banner
      setCheckoutEmptyStateVisible(isEmpty);

      if (isEmpty) {
        // Hide the template card so the user doesn't see the $0 skeleton
        if (tpl) tpl.style.display = "none";

        // Remove any cloned cards
        if (root) root.querySelectorAll(".dates-grid.__li").forEach(n => n.remove());

        // Reset right-side summary to avoid misleading labels
        try {
          const sp = document.getElementById("summaryProperty");
          const sd = document.getElementById("summaryDates");
          const sr = document.getElementById("summaryRooms");
          const sn = document.getElementById("summaryNightsVisible");
          const st = document.getElementById("summaryTotal");

          if (sp) sp.textContent = "No property selected";
          if (sd) sd.textContent = "--";
          if (sr) sr.textContent = "--";
          if (sn) sn.textContent = "--";
          if (st) st.textContent = "--";
        } catch (_) {}

        // Prevent user from getting "stuck" on Section 1 confirm
        try {
          const btn = document.getElementById("confirmRoomPriceBtn");
          if (btn) btn.disabled = true;
        } catch (_) {}
      } else {
        // If not empty, ensure template is visible (it becomes the first real card)
        if (tpl) tpl.style.display = "";
        try {
          const btn = document.getElementById("confirmRoomPriceBtn");
          if (btn) btn.disabled = false;
        } catch (_) {}
      }

      return !isEmpty;
    }

    function normalizeRoomPriceCardsUI() {
      const cards = Array.from(
        document.querySelectorAll('.section-body[data-section-body="1"] .dates-grid')
      );
      if (!cards.length) return;

      const many = cards.length > 1;

      // Always control Remove visibility first (Remove must show on every card when 2+)
      cards.forEach((card) => {
        const removeBtn = card.querySelector('button[data-remove-lineitem="1"]');
        if (!removeBtn) return;

        // If Remove is inside a hidden confirm row on non-last cards, move it out.
        const row = removeBtn.closest(".stay-confirm-row");
        if (row) {
          removeBtn.remove();
          // Place it under the pricing row, before the confirm row area (keeps minimal layout)
          card.appendChild(removeBtn);
        }

        removeBtn.style.display = "";
      });

      // Singleton Confirm (SAFE): do NOT move/remove DOM nodes.
      // Just show confirm on the last card only.
      try {
        const lastIdx = cards.length - 1;

        cards.forEach((card, i) => {
          const row = card.querySelector(".stay-confirm-row");
          if (!row) return;

          row.style.display = (i === lastIdx) ? "flex" : "none";

          const confirmBtn = row.querySelector('button[data-confirm="1"]');
          if (confirmBtn) confirmBtn.style.display = "";
        });
      } catch (_) {}
    }

    function confirmRemoveLineItemUI(onYes) {
      // Remove existing modal if any
      const old = document.getElementById("removeLineItemConfirm");
      if (old) old.remove();

      const backdrop = document.createElement("div");
      backdrop.id = "removeLineItemConfirm";
      backdrop.style.position = "fixed";
      backdrop.style.left = "0";
      backdrop.style.top = "0";
      backdrop.style.right = "0";
      backdrop.style.bottom = "0";
      backdrop.style.background = "rgba(15, 28, 46, 0.35)";
      backdrop.style.display = "flex";
      backdrop.style.alignItems = "center";
      backdrop.style.justifyContent = "center";
      backdrop.style.zIndex = "9999";
      backdrop.style.padding = "18px";

      const card = document.createElement("div");
      card.style.background = "#fff";
      card.style.border = "1px solid rgba(15, 28, 46, 0.12)";
      card.style.borderRadius = "16px";
      card.style.maxWidth = "420px";
      card.style.width = "100%";
      card.style.boxShadow = "0 12px 30px rgba(15, 28, 46, 0.18)";
      card.style.padding = "16px 16px 14px 16px";
      card.style.fontFamily = "Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";

      const title = document.createElement("div");
      title.textContent = "Remove this line item?";
      title.style.fontWeight = "700";
      title.style.fontSize = "14px";
      title.style.color = "#0F1C2E";

      const body = document.createElement("div");
      body.textContent = "This will remove the room and rate plan from your checkout.";
      body.style.marginTop = "6px";
      body.style.fontSize = "13px";
      body.style.color = "rgba(15, 28, 46, 0.8)";
      body.style.lineHeight = "1.35";

      const actions = document.createElement("div");
      actions.style.display = "flex";
      actions.style.gap = "10px";
      actions.style.justifyContent = "flex-end";
      actions.style.marginTop = "12px";

      const noBtn = document.createElement("button");
      noBtn.type = "button";
      noBtn.textContent = "No";
      noBtn.className = "pill-outline"; // uses your existing aesthetic
      // Standardize modal button sizing (force pill, not circle)
      noBtn.style.minHeight = "22px";
      noBtn.style.minWidth  = "88px";   // <-- THIS is the key
      noBtn.style.padding   = "8px 22px";
      noBtn.style.borderRadius = "999px";
      noBtn.style.fontWeight = "600";
      noBtn.style.fontSize = "14px";
      noBtn.style.lineHeight = "1";
      noBtn.style.cursor = "pointer";


      const yesBtn = document.createElement("button");
      yesBtn.type = "button";
      yesBtn.textContent = "Yes, remove";
      yesBtn.className = "btn-primary"; // uses your existing aesthetic
      // Match "No" button height/padding so both look consistent
      yesBtn.style.minHeight = "40px";
      yesBtn.style.padding = "8px 18px";
      yesBtn.style.borderRadius = "999px";
      yesBtn.style.fontWeight = "600";
      yesBtn.style.fontSize = "14px";
      yesBtn.style.lineHeight = "1";

      function close() {
        backdrop.remove();
      }

      backdrop.addEventListener("click", (e) => {
        if (e.target === backdrop) close();
      });

      noBtn.addEventListener("click", () => close());
      yesBtn.addEventListener("click", () => {
        close();
        try { onYes && onYes(); } catch(_) {}
      });

      actions.appendChild(noBtn);
      actions.appendChild(yesBtn);

      card.appendChild(title);
      card.appendChild(body);
      card.appendChild(actions);

      backdrop.appendChild(card);
      document.body.appendChild(backdrop);
    }

    // Delegated remove handler
    document.addEventListener("click", (e) => {
      const btn = e.target.closest('button[data-remove-lineitem="1"]');
      if (!btn) return;

      const card = btn.closest(".dates-grid");
      if (!card) return;

      // We expect your render loop to set a line id on the card wrapper.
      const lineId =
        card.getAttribute("data-lineid") ||
        card.getAttribute("data-lineId") ||
        (card.dataset ? (card.dataset.lineid || card.dataset.lineId || card.dataset.lineId) : null);

      if (!lineId) {
        alert("Remove failed: missing lineId on this card wrapper (data-lineid).");
        return;
      }

      let cart = null;
      try { cart = JSON.parse(localStorage.getItem("checkout.cart.v1") || "null"); } catch (_) { cart = null; }
      if (!cart || !Array.isArray(cart.items)) return;

      cart.items = cart.items.filter(it => String(it.lineId) !== String(lineId));
      localStorage.setItem("checkout.cart.v1", JSON.stringify(cart));

      confirmRemoveLineItemUI(() => {
        try {
          const cart = loadCartV1();
          const items = cart && Array.isArray(cart.items) ? cart.items : [];

          const keep = items.filter(it => String(it && it.lineId) !== String(lineId));
          cart.items = keep;
          saveCartV1(cart);

          console.log("[checkout] removed lineId", lineId, "remaining", keep.length);
        } catch (e) {
          console.warn("[checkout] remove failed in confirm", e);
        }

        // IMPORTANT: avoid re-adding the removed line via URL->cart guard on reload.
        // Navigate to a URL that points to an existing remaining line (or clears selection).
        try {
          const cartAfter = loadCartV1();
          const remaining = cartAfter && Array.isArray(cartAfter.items) ? cartAfter.items : [];

          const qsNext = new URLSearchParams(location.search);

          if (remaining.length) {
            const it0 = remaining[0];

            qsNext.set("propertyId", String(it0.propertyId || ""));
            qsNext.set("roomId",     String(it0.roomTypeId || ""));
            qsNext.set("ratePlanId", String(it0.ratePlanId || ""));
            qsNext.set("qty",        String(it0.qty || 1));
            qsNext.set("start",      String(it0.start || ""));
            qsNext.set("end",        String(it0.end || ""));

            // Optional labels (safe)
            if (it0.propertyName) qsNext.set("propertyName", String(it0.propertyName));
            if (it0.propertyLocation) qsNext.set("propertyLocation", String(it0.propertyLocation));
            if (it0.roomName) qsNext.set("roomName", String(it0.roomName));
            if (it0.planLabel) qsNext.set("planLabel", String(it0.planLabel));
          } else {
            // No items left: clear selection params so nothing can be re-added
            ["propertyId","roomId","ratePlanId","qty","start","end","propertyName","propertyLocation","roomName","planLabel","plans"]
              .forEach(k => qsNext.delete(k));

            // NEW: show the empty-state UI immediately (avoid $0 skeleton flash)
            try { syncEmptyCheckoutUIFromCart(); } catch (_) {}
          }

          location.replace(`${location.pathname}?${qsNext.toString()}`);
          return;
        } catch (_) {}

        // Fallback
        location.reload();

      });
    });

    function suffixIdsInClone(rootEl, idx) {
      rootEl.querySelectorAll("[id]").forEach(function (el) {
        var orig = el.id;
        el.dataset.origId = orig;
        el.id = orig + "__li" + idx;
      });
    }

    function setCloneTextByOrigId(rootEl, origId, text) {
          var nodes = rootEl.querySelectorAll('[data-orig-id="' + origId + '"]');
          if (!nodes || !nodes.length) return;
          var val = text == null ? "" : String(text);
          nodes.forEach(function (el) { el.textContent = val; });
        }

    // Helper: render "Dec 16, 2025 to Dec 19, 2025" from YYYY-MM-DD
    function stayNightsFromRange(start, end) {
          try {
            if (!start || !end) return 0;
            const ps = String(start).split("-").map(n => parseInt(n, 10));
            const pe = String(end).split("-").map(n => parseInt(n, 10));
            if (ps.length !== 3 || pe.length !== 3) return 0;

            // Use UTC midnight to avoid timezone/DST shifting
            const ds = Date.UTC(ps[0], ps[1] - 1, ps[2]);
            const de = Date.UTC(pe[0], pe[1] - 1, pe[2]);
            const nights = Math.round((de - ds) / 86400000);

            return Number.isFinite(nights) && nights >= 0 ? nights : 0;
          } catch (_) {
            return 0;
          }
        }

    function renderRoomPriceCardsFromCart() {
      // Fallbacks: make these available even if helpers were moved/removed elsewhere
      const prettyStayRange = (window.prettyStayRange) ? window.prettyStayRange : function (start, end) {
        try {
          if (!start || !end) return "";
          const ps = String(start).split("-").map(n => parseInt(n, 10));
          const pe = String(end).split("-").map(n => parseInt(n, 10));
          if (ps.length !== 3 || pe.length !== 3) return `${start} to ${end}`;
          const ds = new Date(ps[0], ps[1] - 1, ps[2]);
          const de = new Date(pe[0], pe[1] - 1, pe[2]);
          const fmt = d => d.toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" });
          return `${fmt(ds)} to ${fmt(de)}`;
        } catch (_) {
          return `${start || ""} to ${end || ""}`;
        }
      };

      const stayNightsFromRange = (window.stayNightsFromRange) ? window.stayNightsFromRange : function (start, end) {
        try {
          if (!start || !end) return 0;
          const ps = String(start).split("-").map(n => parseInt(n, 10));
          const pe = String(end).split("-").map(n => parseInt(n, 10));
          if (ps.length !== 3 || pe.length !== 3) return 0;
          const ds = Date.UTC(ps[0], ps[1] - 1, ps[2]);
          const de = Date.UTC(pe[0], pe[1] - 1, pe[2]);
          const nights = Math.round((de - ds) / 86400000);
          return Number.isFinite(nights) && nights >= 0 ? nights : 0;
        } catch (_) {
          return 0;
        }
      };

      // === CARD ID â†’ ROLE NORMALIZER ===
      // Converts duplicate IDs inside cards into data-role attributes
      function normalizeCardRoles(card){
        card.querySelectorAll("[id]").forEach(el => {
          var orig = el.id;
          el.dataset.origId = orig;            // enables setCloneTextByOrigId()
          el.setAttribute("data-role", orig);  // enables data-role lookups
          el.removeAttribute("id");            // prevents duplicate IDs across cards
        });
      }

      var cart = loadCartV1();
        // Sort items by start date (earliest first), then end date
        function dayNum(ymd) {
          if (!ymd || typeof ymd !== "string") return Number.MAX_SAFE_INTEGER;
          const p = ymd.split("-");
          if (p.length !== 3) return Number.MAX_SAFE_INTEGER;
          return (Number(p[0]) * 10000) + (Number(p[1]) * 100) + Number(p[2]);
        }

        const itemsSorted = Array.isArray(cart && cart.items)
          ? cart.items.slice().sort((a, b) => {
              const as = dayNum(a.start);
              const bs = dayNum(b.start);
              if (as !== bs) return as - bs;
              const ae = dayNum(a.end);
              const be = dayNum(b.end);
              return ae - be;
            })
          : [];

      if (!cart || !Array.isArray(itemsSorted) || !itemsSorted.length) return;

      var root = document.getElementById("roomPriceCardsRoot");
      var tpl  = document.getElementById("roomPriceCardTemplate");
      if (!root || !tpl) return;
      // Normalize the template once so it does not keep global IDs
      try { normalizeCardRoles(tpl); } catch (_) {}

      // First (template) card must be populated from cart[0], NOT from URL-driven logic
      if (itemsSorted[0]) {
        const it0 = itemsSorted[0];

        // Tag template card
        if (it0.lineId) {
          tpl.dataset.lineId = it0.lineId;
          tpl.setAttribute("data-lineid", String(it0.lineId));
        }

        // Helper scoped to template
        const setTplText = (id, val) => {
          const el =
            tpl.querySelector("#" + id) ||
            tpl.querySelector('[data-orig-id="' + id + '"]') ||
            tpl.querySelector('[data-role="' + id + '"]');
          if (el) el.textContent = val == null ? "" : String(val);
        };

        // Populate template card fields
        setTplText("propertyName", it0.propertyName || "");
        setTplText("propertyMeta", it0.propertyLocation || "");
        setTplText("propertyIdValue", it0.propertyId || "");
        setTplText("roomName", it0.roomName || "");
        setTplText("roomIdValue", it0.roomTypeId || "");
        setTplText("ratePlanName", it0.ratePlanName || it0.planLabel || "");
        setTplText("ratePlanIdValue", it0.ratePlanId || "");

        // roomQty appears multiple times (template has 2 spots)
        tpl.querySelectorAll('[data-role="roomQty"],[data-orig-id="roomQty"],#roomQty').forEach(n => {
          n.textContent = it0.qty != null ? String(it0.qty) : "1";
        });

        setTplText("stayDatesInline", prettyStayRange(it0.start, it0.end));
        setTplText("stayNights", String(stayNightsFromRange(it0.start, it0.end)));

        // Apply pricing quote to template card
        (function(card, itemRef) {
          if (!itemRef) return;
        const pid = Number(
          itemRef.propertyId ||
          state.propertyId ||
          (parseQuery && parseQuery().propertyId) ||
          0
        );
        if (!pid) return;

          const qs = new URLSearchParams();
          qs.set("propertyId", String(pid));
          qs.set("plans", "2");

          if (itemRef.start) qs.set("start", String(itemRef.start));
          if (itemRef.end)   qs.set("end",   String(itemRef.end));

          const roomIdForQuote = itemRef.roomTypeId || itemRef.roomId;
          if (roomIdForQuote) qs.set("roomId", String(roomIdForQuote));

          // CRITICAL: request quote for the selected plan
          if (itemRef.ratePlanId != null && String(itemRef.ratePlanId).trim()) {
            qs.set("ratePlanId", String(itemRef.ratePlanId).trim());
          }

          // Critical: quote must be for the selected plan
          if (itemRef.ratePlanId != null && String(itemRef.ratePlanId).trim()) {
            qs.set("ratePlanId", String(itemRef.ratePlanId).trim());
          }

          qs.set("qty", String(itemRef.qty || 1));

          fetch("/catalog/details?" + qs.toString(), {
            credentials: "include",
            headers: { Accept: "application/json" }
          })
            .then(r => r.json())
            .then(data => {
              const quote = data && data.checkoutQuote ? data.checkoutQuote : null;
              console.log("[checkout] quote payload", {
                hasQuote: !!quote,
                checkoutQuote: quote,
                keys: quote ? Object.keys(quote) : null,
                raw: data
              });
              if (quote) {
                applyQuoteToCard(card, quote, itemRef.qty || 1);
              } else {
                // No quote, do not guess. Make it obvious to the traveler.
                try {
                  const avgEl = (card.querySelector('[data-role="avgNightPrice"],[data-orig-id="avgNightPrice"],#avgNightPrice')||null);
                  const totEl = (card.querySelector('[data-role="totalPill"],[data-orig-id="totalPill"],#totalPill')||null);
                  if (avgEl) avgEl.textContent = "Error";
                  if (totEl) totEl.textContent = "Pricing unavailable";
                } catch (_) {}
              }

              // Read back what the UI shows right after apply
              try {
                const avgNow = (card.querySelector('[data-role="avgNightPrice"],[data-orig-id="avgNightPrice"],#avgNightPrice')||{}).textContent;
                const totNow = (card.querySelector('[data-role="totalPill"],[data-orig-id="totalPill"],#totalPill')||{}).textContent;
                console.log("[checkout] after apply", { avgNow, totNow, lineId: card.getAttribute("data-lineid") });
              } catch (_) {}
            })
            .catch(err => console.warn("[checkout] card quote failed", err));
        })(tpl, it0);
      }

      // Remove any previously cloned cards.
      root.querySelectorAll(".dates-grid.__li").forEach(function (n) { n.remove(); });

      // Create clones for items[1..]
      for (var i = 1; i < itemsSorted.length; i++) {
        var item = itemsSorted[i];

        var clone = tpl.cloneNode(true);
        clone.classList.add("__li");
      const lid = item.lineId || ("line_" + i);
        clone.dataset.lineId = lid;
        clone.setAttribute("data-lineid", String(lid));

        // Suffix IDs inside clone to avoid duplicates
        suffixIdsInClone(clone, i);

        // Populate visible fields in the clone (display only for now)
        setCloneTextByOrigId(clone, "propertyName", item.propertyName || "");
        setCloneTextByOrigId(clone, "propertyMeta", item.propertyLocation || "");
        setCloneTextByOrigId(clone, "propertyIdValue", item.propertyId || "");
        setCloneTextByOrigId(clone, "roomName", item.roomName || "");
        setCloneTextByOrigId(clone, "roomIdValue", item.roomTypeId || "");
        setCloneTextByOrigId(clone, "ratePlanName", item.planLabel || "");
        setCloneTextByOrigId(clone, "ratePlanIdValue", item.ratePlanId || "");
        setCloneTextByOrigId(clone, "roomQty", item.qty != null ? item.qty : "");

        const datesEl = clone.querySelector('[data-orig-id="stayDatesInline"]');
        if (datesEl) datesEl.textContent = prettyStayRange(item.start, item.end);

        // Ensure nights is populated even before pricing quote returns
        setCloneTextByOrigId(clone, "stayNights", String(stayNightsFromRange(item.start, item.end)));

        root.appendChild(clone);
        // Fetch quote for this line item and apply to this card (scoped)
        (function(card, itemRef) {
          const pid = Number(
            itemRef.propertyId ||
            state.propertyId ||
            (parseQuery && parseQuery().propertyId) ||
            0
          );
          if (!pid) return;

          const qs = new URLSearchParams();
          qs.set("propertyId", String(pid));
          if (itemRef.start) qs.set("start", String(itemRef.start));
          if (itemRef.end)   qs.set("end",   String(itemRef.end));
          const roomIdForQuote = itemRef.roomTypeId || itemRef.roomId;
          if (roomIdForQuote) qs.set("roomId", String(roomIdForQuote));
          qs.set("qty", String(itemRef.qty || 1));

          fetch("/catalog/details?" + qs.toString(), {
            credentials: "include",
            headers: { Accept: "application/json" }
          })
            .then(r => r.json())
            .then(data => {
              let quote = (data && data.checkoutQuote) ? data.checkoutQuote : null;

              console.log("[checkout] quote payload", {
                hasQuote: !!quote,
                checkoutQuote: quote,
                keys: quote ? Object.keys(quote) : null,
                raw: data
              });

              // Fallback: derive from rooms[].daily when checkoutQuote is missing
              if (!quote) {
                try {
                  const roomsArr = Array.isArray(data?.rooms) ? data.rooms : [];
                  const start = String(itemRef.start || "");
                  const end   = String(itemRef.end || "");
                  const qRoomId = Number(itemRef.roomTypeId || itemRef.roomId);

                  if (roomsArr.length && start && end && Number.isFinite(qRoomId)) {
                    const chosen =
                      roomsArr.find(r => {
                        const rtId = Number((r && (r.roomTypeId != null ? r.roomTypeId : r.id)));
                        return Number.isFinite(rtId) && rtId === qRoomId;
                      }) || roomsArr[0];

                    const daily = Array.isArray(chosen?.daily) ? chosen.daily : [];
                    const msPerDay = 24 * 60 * 60 * 1000;
                    const startDate = new Date(start + "T00:00:00Z");
                    const endDate   = new Date(end   + "T00:00:00Z");
                    const nights = [];

                    for (let t = startDate.getTime(); t < endDate.getTime(); t += msPerDay) {
                      const iso = new Date(t).toISOString().slice(0, 10);
                      const rec = daily.find(d => d && d.date === iso);
                      if (!rec) continue;
                      const val = rec.price != null ? Number(rec.price) : NaN;
                      if (!Number.isFinite(val) || val <= 0) continue;
                      nights.push({ date: iso, amount: val });
                    }

                    const total = nights.reduce((sum, n) => sum + n.amount, 0);
                    if (nights.length && Number.isFinite(total) && total > 0) {
                      const curRow = daily.find(d => d && d.currency) || null;
                      const curCode = curRow && curRow.currency ? String(curRow.currency) : "USD";
                      quote = { source: "db", currency: curCode, total, nights };
                      console.log("[checkout] derived per-card quote from rooms.daily", quote);
                    }
                  }
                } catch (e) {
                  console.warn("[checkout] per-card daily fallback failed", e);
                }
              }

              if (quote) applyQuoteToCard(card, quote, itemRef.qty || 1);

              // Read back what the UI shows right after apply
              try {
                const avgNow = (card.querySelector('[data-role="avgNightPrice"],[data-orig-id="avgNightPrice"],#avgNightPrice')||{}).textContent;
                const totNow = (card.querySelector('[data-role="totalPill"],[data-orig-id="totalPill"],#totalPill')||{}).textContent;
                console.log("[checkout] after apply", { avgNow, totNow, lineId: card.getAttribute("data-lineid") });
              } catch (_) {}
            })
            .catch(err => console.warn("[checkout] card quote failed", err));
        })(clone, item);
      }

      // IMPORTANT: normalize AFTER cards are rendered (so remove/confirm visibility wins)
      try { normalizeRoomPriceCardsUI(); } catch (_) {}
    }

    // === CONFIRM DELEGATE WIRE (prevents dead Confirm when cards are cloned) ===
    if (!window.__checkoutConfirmDelegated) {
      window.__checkoutConfirmDelegated = true;

      document.addEventListener("click", function (e) {
        const btn = e.target && e.target.closest
          ? e.target.closest('button[data-confirm="1"]')
          : null;

        if (!btn) return;

        // Prevent any default behavior and make Confirm always work
        e.preventDefault();

        // Section 1 confirm
        try { handleConfirmClick(1); } catch (err) {
          console.warn("[checkout] confirm delegate failed", err);
        }
      }, true);
    }

    function handleConfirmClick(section) {

      // Guardrail: block confirming Section 1 if dates are past/invalid
      if (section === 1 && typeof validateStayDates === "function") {
        const v = validateStayDates(String(state.start || ""), String(state.end || ""));
        if (!v || !v.ok) {
          alert(
            v && v.reason === "start_in_past"
              ? "Check-in date cannot be in the past."
              : "Dates are invalid. Check-out must be after check-in."
          );
          return;
        }
      }

      // Guest details validation lives on section 4
      if (section === 3) {
        const firstName = document.getElementById("firstName").value.trim();
        const lastName = document.getElementById("lastName").value.trim();
        const email = document.getElementById("email").value.trim();
        const phone = document.getElementById("phone").value.trim();
        const errorEl = document.getElementById("guestError");

        if (!firstName || !lastName || !email || !phone) {
          if (errorEl) errorEl.style.display = "block";
          return;
        } else if (errorEl) {
          errorEl.style.display = "none";
        }
      } else if (section === 4) {
        // Terms / Privacy agreement is required before payment
        const checkbox = document.getElementById("termsCheckbox");
        const errorEl  = document.getElementById("termsError");
        const wrap     = document.querySelector(".payment-agreement");

        const isChecked = checkbox && checkbox.checked;

        if (!isChecked) {
          if (errorEl) errorEl.style.display = "block";
          if (wrap) wrap.classList.add("error");
          return; // do not mark section 5 as confirmed
        }

        // Clear error state when user has agreed
        if (errorEl) errorEl.style.display = "none";
        if (wrap) wrap.classList.remove("error");
      }

      state.sectionConfirmed[section] = true;
      refreshSections();

      // If user just confirmed Payment Method, immediately start Stripe Checkout.
      if (section === 4) {
        const btn = document.getElementById("confirmAndPayButton");
        if (btn && !btn.disabled) {
          setTimeout(() => btn.click(), 0);
        }
      }
    }

    // ANCHOR: ADDONS_MODAL_HANDLERS
    // Modal open / close / apply is handled via the global click
    // delegation above using:
    //   [data-open-addons-modal]
    //   [data-close-addons-modal]
    //   [data-apply-addons-modal]

    function initCheckout() {
      // === HARD GUARD: prevent double init/render (duplicate cards + $0 overwrite) ===
      if (window.__CHECKOUT_INIT_DONE__) {
        console.warn("[checkout] initCheckout blocked (already ran)");
        return;
      }
      window.__CHECKOUT_INIT_DONE__ = true;

      // === SINGLE-PROPERTY CHECKOUT ENFORCEMENT =============================
      // Allow multiple cards/date windows, but only for ONE property per checkout.
      try {
        const cart = loadCartV1();
        const items = (cart && Array.isArray(cart.items)) ? cart.items : [];

        const propIds = Array.from(
          new Set(items.map(it => String(it?.propertyId || "")).filter(Boolean))
        );

        if (propIds.length > 1) {
          const keepPid = propIds[0];

          cart.items = items.filter(it => String(it?.propertyId || "") === keepPid);
          saveCartV1(cart);

          console.warn("[checkout] multi-property cart detected; normalized to single property", {
            keepPropertyId: keepPid,
            removedPropertyIds: propIds.slice(1)
          });

          // Optional: simple user-facing notice (non-blocking)
          try {
            alert("Checkout supports one property at a time. Items from other properties were removed. You can book those properties in separate checkouts.");
          } catch (_) {}

          // Reload so UI re-renders from the normalized cart
          try { location.reload(); } catch (_) {}
          return;
        }
      } catch (e) {
        console.warn("[checkout] single-property enforcement failed (non-fatal)", e);
      }
      // === SINGLE-PROPERTY CHECKOUT ENFORCEMENT END =========================


      // === AFTER-SUCCESS HARD STOP (durable) ===
      (function(){
        try {
          const after = localStorage.getItem("checkout.afterSuccessAt");
          if (after) {
            localStorage.removeItem("checkout.cart.v1");
            localStorage.removeItem("checkout.selection.v1");
            localStorage.removeItem("checkout.lastPropertyId");
            localStorage.removeItem("checkout.lastDetailsUrl");
            // keep the flag so Back cannot resurrect checkout
            location.replace("/catalog.html");
            return;
          }
        } catch (_) {}
      })();

      const q0 = parseQuery();
      migrateSelectionToCartIfNeeded(q0);

      // Enforce single-property checkout:
      // - Allow multiple date windows/cards for the SAME property
      // - Reject URL selections for a DIFFERENT property (do not append)
      // - Keep checkout/cart/Stripe metadata property-consistent
      (function ensureQueryLineIsInCart() {

        const hasAll =
          q0 &&
          Number(q0.propertyId) &&
          Number(q0.roomId) &&
          Number(q0.ratePlanId) &&
          q0.start &&
          q0.end;

        if (!hasAll) return;

        const cart = loadCartV1();
        if (!cart || !Array.isArray(cart.items)) return;

        const propId = String(q0.propertyId);
        const roomId = String(q0.roomId);
        const planId = String(q0.ratePlanId);
        const start  = String(q0.start);
        const end    = String(q0.end);
        const qty    = Math.max(1, Number.parseInt(String(q0.qty || "1"), 10) || 1);

        // === SINGLE PROPERTY ENFORCEMENT (reject newest URL property) =========
        try {
          const existingPropIds = Array.from(
            new Set(cart.items.map(it => String(it && it.propertyId || "")).filter(Boolean))
          );

          // If cart already has a property and URL points to a different property, reject URL selection.
          if (existingPropIds.length >= 1 && existingPropIds[0] && existingPropIds[0] !== propId) {
            alert(
              "This checkout is limited to one property.\n\n" +
              "Youâ€™re free to book multiple date windows for the same hotel.\n\n" +
              "To book another property, finish this checkout and start a new one."
            );

            // Rewrite URL to the existing property's first line so we don't re-trigger this on refresh
            const keepPid = existingPropIds[0];
            const keepItem = cart.items.find(it => String(it && it.propertyId || "") === keepPid) || cart.items[0];

            try {
              const qsNext = new URLSearchParams(location.search);

              if (keepItem) {
                qsNext.set("propertyId", String(keepItem.propertyId || ""));
                qsNext.set("roomId",     String(keepItem.roomTypeId || ""));
                qsNext.set("ratePlanId", String(keepItem.ratePlanId || ""));
                qsNext.set("qty",        String(keepItem.qty || 1));
                qsNext.set("start",      String(keepItem.start || ""));
                qsNext.set("end",        String(keepItem.end || ""));

                if (keepItem.propertyName) qsNext.set("propertyName", String(keepItem.propertyName));
                if (keepItem.propertyLocation) qsNext.set("propertyLocation", String(keepItem.propertyLocation));
                if (keepItem.roomName) qsNext.set("roomName", String(keepItem.roomName));
                if (keepItem.planLabel) qsNext.set("planLabel", String(keepItem.planLabel));
              }

              location.replace(`${location.pathname}?${qsNext.toString()}`);
              return;
            } catch (_) {
              // If URL rewrite fails, still refuse the append
              return;
            }
          }
        } catch (_) {}
        // === SINGLE PROPERTY ENFORCEMENT END =================================

        // Consider it the â€œsame lineâ€ only if property+room+plan+dates match
        const existing = cart.items.find(it =>
          String(it.propertyId) === propId &&
          String(it.roomTypeId) === roomId &&
          String(it.ratePlanId) === planId &&
          String(it.start) === start &&
          String(it.end) === end
        );

        if (existing) {
          // If user re-clicked Book Now on same exact line, just sync qty + labels
          existing.qty = qty;
          if (q0.propertyName) existing.propertyName = String(q0.propertyName);
          if (q0.propertyLocation) existing.propertyLocation = String(q0.propertyLocation);
          if (q0.roomName) existing.roomName = String(q0.roomName);
          if (q0.ratePlanName) existing.planLabel = String(q0.ratePlanName);
          saveCartV1(cart);
          return;
        }

        // Append as a new line (same property allowed, multiple date windows allowed)
        const lineId =
          "ln_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2, 8);

        cart.items.push({
          lineId,
          propertyId: propId,
          propertyName: String(q0.propertyName || ""),
          propertyLocation: String(q0.propertyLocation || ""),
          roomTypeId: roomId,
          roomName: String(q0.roomName || ""),
          ratePlanId: planId,
          planLabel: String(q0.ratePlanName || ""),
          qty,
          start,
          end
        });

        saveCartV1(cart);
      })();

      const picked = coalesceQueryFromCart(q0);
      const q = picked.q;

      // optional state hooks for later steps (no UI impact now)
      state.cart = picked.cart;
      state.activeLine = picked.active;
      state.propertyId = q.propertyId;
      state.roomId = q.roomId;
      state.qty = Math.max(1, Number.parseInt(q.qty, 10) || 1);
      state.start = q.start;
      state.end = q.end;
      state.ratePlanId = q.ratePlanId;
      state.propertyName = q.propertyName;
      state.propertyLocation = q.propertyLocation;
      state.roomName = q.roomName;
      state.ratePlanName = q.ratePlanName;

      updateSummaries();
      refreshSections();
      renderRoomPriceCardsFromCart();

      // NEW: ensure empty-cart banner wins if cart is empty
      syncEmptyCheckoutUIFromCart();

      loadAddonsForProperty();
      normalizeRoomPriceCardsUI();

      // === STABILIZER: keep Section 1 open on initial load ====================
      // Sometimes async work during load re-adds `.hidden` to section bodies.
      // If Section 1 is not confirmed yet, force it back open so user can click Confirm.
      (function keepSection1OpenOnLoad(){
        function reopen(){
          try {
            if (state && state.sectionConfirmed && state.sectionConfirmed[1]) return;

            const body1 = document.querySelector('[data-section-body="1"]');
            if (body1) body1.classList.remove("hidden");

            const step1 = document.querySelector('[data-step-indicator="1"]');
            const status1 = document.querySelector('[data-step-status="1"]');

            if (step1){
              step1.classList.add("active");
              step1.classList.remove("completed");
            }
            if (status1){
              status1.textContent = "Waiting for confirmation";
              status1.classList.remove("completed");
            }
          } catch (_) {}
        }

        // Run immediately after paint, and again after async fetch/render work.
        setTimeout(reopen, 0);
        setTimeout(reopen, 250);
      })();
      // === STABILIZER END =====================================================

      // Allow clicking headers to reopen a section, but keep only one open
      document.querySelectorAll(".card-header").forEach(function (header) {
        header.addEventListener("click", function () {
          var card = header.closest(".card");
          if (!card) return;
          var section = Number(card.getAttribute("data-section"));
          if (!section) return;

          // Donâ€™t let user jump ahead if previous sections arenâ€™t confirmed
          for (var i = 1; i < section; i++) {
            if (!state.sectionConfirmed[i]) {
              return;
            }
          }

          // Open this section, close all others
          document.querySelectorAll("[data-section-body]").forEach(function (bodyEl) {
            var bodySection = Number(bodyEl.getAttribute("data-section-body"));
            if (bodySection === section) {
              bodyEl.classList.remove("hidden");
            } else {
              bodyEl.classList.add("hidden");
            }
          });
        });
      });

      (function wireEditDatesLinksAllCards() {
        // Wire all "Edit dates" links (template + clones)

        // Active line item for date edits
        state.activeLineIdForDates = state.activeLineIdForDates || null;

        document.addEventListener("click", function (e) {
          const link = e.target.closest(".dates-grid .top-info-right .card-header-link");
          if (!link) return;

          // Only handle the "Edit dates" links, not other links/buttons
          const isEdit =
            link.id === "editDatesLink" ||
            (link.dataset && link.dataset.origId === "editDatesLink") ||
            (typeof link.id === "string" && link.id.indexOf("editDatesLink__li") === 0);

          if (!isEdit) return;

          e.preventDefault();

          const card = link.closest(".dates-grid");
          if (!card) return;

          // Open the wrapper inside the clicked card (not the global/template wrapper)
          const wrap = card.querySelector('[data-orig-id="checkoutDatesCardWrapper"], #checkoutDatesCardWrapper');
          if (wrap) wrap.classList.remove("hidden");

          const lineId = card.getAttribute("data-lineid") || (card.dataset ? card.dataset.lineId : null);
          if (!lineId) {
            alert("Edit dates failed: missing data-lineid on this card.");
            return;
          }

          state.activeLineIdForDates = String(lineId);

          // Move the single real date editor into this card's right column
          const rightCol = card.querySelector(".dates-right");
          if (rightCol) rightCol.appendChild(wrap);

          wrap.classList.remove("hidden");
          wrap.scrollIntoView({ behavior: "smooth", block: "nearest" });

          // Load that line's dates into the editor (inputs + flatpickr)
          const cart = loadCartV1();
          const items = cart && Array.isArray(cart.items) ? cart.items : [];
          const it = items.find(x => String(x && x.lineId) === String(lineId));
          if (!it) return;

          state.start = String(it.start || "");
          state.end   = String(it.end || "");

          const inEl  = document.getElementById("checkout-checkin");
          const outEl = document.getElementById("checkout-checkout");
          if (inEl)  inEl.value = state.start;
          if (outEl) outEl.value = state.end;

          const rangeDriver2 = document.getElementById("checkout-dates-driver");
          const fp = rangeDriver2 && rangeDriver2._checkoutFp ? rangeDriver2._checkoutFp : null;
          if (fp && state.start && state.end) {
            fp.setDate([state.start, state.end], true);
            try { fp.open(); } catch (_) {}
          } else if (fp) {
            // still open picker even if dates are missing
            try { fp.open(); } catch (_) {}
          }

          const btn = document.getElementById("checkout-dates-display");
          if (btn) btn.focus();
        });
      })();

      // ANCHOR: CHECKOUT_DATES_DELEGATE_WIRE
      if (!window.__checkoutDatesDelegated) {
        window.__checkoutDatesDelegated = true;

        function resolveDatesCtxFromCard(card) {
          if (!card) return null;

          const wrap =
            card.querySelector('[data-orig-id="checkoutDatesCardWrapper"], #checkoutDatesCardWrapper');

          const rangeDriver =
            card.querySelector('[data-orig-id="checkout-dates-driver"], #checkout-dates-driver, .checkout-dates-driver');

          const displayBtn =
            card.querySelector('[data-orig-id="checkout-dates-display"], #checkout-dates-display, .checkout-dates-display');

          const displayLabel =
            card.querySelector('[data-orig-id="checkout-dates-display-label"], #checkout-dates-display-label');

          const applyBtn =
            card.querySelector('[data-orig-id="checkout-dates-apply"], #checkout-dates-apply, button[id^="checkout-dates-apply__li"]');

          return { wrap, rangeDriver, displayBtn, displayLabel, applyBtn };
        }

        function getActiveCardForDates(clickedEl) {
          // If user clicked inside a card, trust that card first
          if (clickedEl && clickedEl.closest) {
            const cardHit = clickedEl.closest(".dates-grid");
            if (cardHit) {
              const lid = cardHit.getAttribute("data-lineid") || "";
              if (lid) state.activeLineIdForDates = String(lid);
              return cardHit;
            }
          }

          // Otherwise use existing activeLineIdForDates
          const lineId = state && state.activeLineIdForDates ? String(state.activeLineIdForDates) : "";
          if (lineId) {
            const c = document.querySelector(`.dates-grid[data-lineid="${lineId}"]`);
            if (c) return c;
          }

          // fallback: first card
          const first = document.querySelector(".dates-grid");
          if (first) {
            const lid = first.getAttribute("data-lineid") || "";
            if (lid) state.activeLineIdForDates = String(lid);
          }
          return first;
        }

        document.addEventListener("click", function (e) {
          const pill = e.target && e.target.closest
            ? e.target.closest('.checkout-dates-display, #checkout-dates-display, [data-orig-id="checkout-dates-display"]')
            : null;

          if (!pill) return;

          const card = pill.closest(".dates-grid") || getActiveCardForDates(pill);
          const ctx = resolveDatesCtxFromCard(card);
          if (!ctx || !ctx.rangeDriver || !ctx.displayBtn) return;

          e.preventDefault();

          if (typeof window.flatpickr !== "function") return;
          // Hide native date inputs in this card when flatpickr is available
          const bar = card.querySelector('#checkout-date-bar, [data-orig-id="checkout-date-bar"]');
          if (bar) bar.classList.add("has-flatpickr");

          // Seed dates from the active cart line (preferred) or state fallback
          let seedStart = state && state.start ? parseLocalYMD(state.start) : null;
          let seedEnd   = state && state.end   ? parseLocalYMD(state.end)   : null;

          try {
            const lineId = state && state.activeLineIdForDates ? String(state.activeLineIdForDates) : null;
            const cartNow = loadCartV1();
            if (lineId && cartNow && Array.isArray(cartNow.items)) {
              const it = cartNow.items.find(x => String(x && x.lineId) === lineId);
              if (it) {
                seedStart = parseLocalYMD(String(it.start || "")) || seedStart;
                seedEnd   = parseLocalYMD(String(it.end || ""))   || seedEnd;
              }
            }
          } catch (_) {}

          // init once per driver
          if (!ctx.rangeDriver._checkoutFp) {
            ctx.rangeDriver._checkoutFp = flatpickr(ctx.rangeDriver, {
              mode: "range",
              dateFormat: "Y-m-d",
              minDate: "today",
              allowInput: false,
              clickOpens: false,
              closeOnSelect: false,
              enableTime: false,
              positionElement: ctx.displayBtn,
              appendTo: ctx.wrap || document.body,
              defaultDate: (seedStart && seedEnd)
                ? [formatLocalYmd(seedStart), formatLocalYmd(seedEnd)]
                : (seedStart ? [formatLocalYmd(seedStart)] : null),
              onChange: function (selectedDates, dateStr, instance) {
                const s = (selectedDates && selectedDates[0]) ? selectedDates[0] : null;
                const e = (selectedDates && selectedDates[1]) ? selectedDates[1] : null;

                // Update THIS card's pill label immediately (before Update dates)
                if (ctx.displayLabel) {
                  if (s && e) {
                    const mm = String(s.getMonth() + 1).padStart(2, "0");
                    const dd = String(s.getDate()).padStart(2, "0");
                    const yy = s.getFullYear();
                    const mm2 = String(e.getMonth() + 1).padStart(2, "0");
                    const dd2 = String(e.getDate()).padStart(2, "0");
                    const yy2 = e.getFullYear();
                    ctx.displayLabel.textContent = `${mm}/${dd}/${yy} to ${mm2}/${dd2}/${yy2}`;
                  } else if (s) {
                    const mm = String(s.getMonth() + 1).padStart(2, "0");
                    const dd = String(s.getDate()).padStart(2, "0");
                    const yy = s.getFullYear();
                    ctx.displayLabel.textContent = `${mm}/${dd}/${yy} to`;
                  } else {
                    ctx.displayLabel.textContent = "Select dates";
                  }
                }

                // Auto-close once the end date is selected
                if (s && e && instance && typeof instance.close === "function") {
                  instance.close();
                }
              }
            });
          }

          if (ctx.rangeDriver._checkoutFp && typeof ctx.rangeDriver._checkoutFp.open === "function") {
            ctx.rangeDriver._checkoutFp.open();
          }
        }, true);

        document.addEventListener("click", function (e) {
          const btn = e.target && e.target.closest
            ? e.target.closest('#checkout-dates-apply, [data-orig-id="checkout-dates-apply"], button[id^="checkout-dates-apply__li"]')
            : null;

          if (!btn) return;

          const card = btn.closest(".dates-grid") || getActiveCardForDates(btn);
          const ctx = resolveDatesCtxFromCard(card);
          if (!ctx) return;

          e.preventDefault();

          const fp = ctx.rangeDriver && ctx.rangeDriver._checkoutFp ? ctx.rangeDriver._checkoutFp : null;
          const sel = (fp && Array.isArray(fp.selectedDates)) ? fp.selectedDates : [];

          const s = sel[0] || parseLocalYMD(state.start) || null;
          let endDate = sel[1] || parseLocalYMD(state.end) || null;

          // Guardrail: no past dates
          if (typeof validateStayDates === "function") {
            const sYmd = s ? formatLocalYmd(s) : "";
            const eYmd = endDate ? formatLocalYmd(endDate) : "";
            const v = validateStayDates(sYmd, eYmd);
            if (!v || !v.ok) {
              alert(
                v && v.reason === "start_in_past"
                  ? "Check-in date cannot be in the past."
                  : "Dates are invalid. Check-out must be after check-in."
              );
              return;
            }
          }

          if (!s) return;

          if (!endDate || endDate <= s) {
            endDate = new Date(s.getTime());
            endDate.setDate(s.getDate() + 1);
          }

          const finalStart = formatLocalYmd(s);
          const finalEnd   = formatLocalYmd(endDate);

          const lineId = state.activeLineIdForDates ? String(state.activeLineIdForDates) : null;
          if (!lineId) return;

          const cartNow = loadCartV1();
          if (!cartNow || !Array.isArray(cartNow.items)) return;

          const idx = cartNow.items.findIndex(it => String(it && it.lineId) === lineId);
          if (idx < 0) return;

          const proposed = cartNow.items.map(x => Object.assign({}, x));
          proposed[idx].start = finalStart;
          proposed[idx].end   = finalEnd;

          // keep your continuity rule intact (same as existing block)
          function dayNum(ymd) {
            if (!ymd || typeof ymd !== "string") return Number.MAX_SAFE_INTEGER;
            const p = ymd.split("-");
            if (p.length !== 3) return Number.MAX_SAFE_INTEGER;
            return (Number(p[0]) * 10000) + (Number(p[1]) * 100) + Number(p[2]);
          }
          const sorted = proposed.slice().sort((a,b) => dayNum(a.start) - dayNum(b.start) || dayNum(a.end) - dayNum(b.end));
          for (let i = 1; i < sorted.length; i++) {
            const prevEnd = dayNum(sorted[i - 1].end);
            const curStart = dayNum(sorted[i].start);
            if (curStart > prevEnd) {
              alert("This checkout supports one trip at a time. Dates must be continuous or back-to-back (no gaps).");
              return;
            }
          }

          cartNow.items = proposed;
          saveCartV1(cartNow);

          // hide wrapper in the active card
          if (ctx.wrap) ctx.wrap.classList.add("hidden");

          const qsNext = new URLSearchParams(location.search);
          qsNext.set("start", finalStart);
          qsNext.set("end", finalEnd);

          const active = cartNow.items[idx];
          if (active) {
            qsNext.set("propertyId", String(active.propertyId || ""));
            qsNext.set("roomId",     String(active.roomTypeId || ""));
            qsNext.set("ratePlanId", String(active.ratePlanId || ""));
            qsNext.set("qty",        String(active.qty || 1));
          }

          location.assign(`${location.pathname}?${qsNext.toString()}`);
        }, true);
      }

      document.querySelectorAll("[data-confirm]").forEach(function (btn) {
        btn.addEventListener("click", function () {
          const section = Number(btn.getAttribute("data-confirm"));
          handleConfirmClick(section);
        });
      });

      const breakdownToggle = document.getElementById("breakdownToggle");
      const breakdownDetails = document.getElementById("breakdownDetails");
      if (breakdownToggle && breakdownDetails) {
        breakdownToggle.addEventListener("click", function () {
          breakdownDetails.classList.toggle("visible");
        });
      }

      const confirmAndPayButton = document.getElementById("confirmAndPayButton");
      if (confirmAndPayButton) {
        // Original Stripe Checkout handler (kept as-is)
        confirmAndPayButton.addEventListener("click", async function () {
          if (confirmAndPayButton.disabled) return;

          confirmAndPayButton.disabled = true;
          confirmAndPayButton.textContent = "Redirecting to secure payment.";

          try {
          const pay = computeGrandTotalForPayment();

          // ANCHOR: PAYLOAD_CARTITEMS_DEBUG
          const cartItemsPayload = (function(){
            try {
              const cart = loadCartV1();
              if (!cart || !Array.isArray(cart.items)) return [];

              const baseItems = cart.items.map(it => ({
                roomTypeId: it.roomTypeId,
                ratePlanId: it.ratePlanId,
                qty: Number(it.qty || it.quantity || 1),
                currency: (it.currency || state.pricingCurrency || "USD"),
                lineId: String(it.lineId || it.id || ""),
                lineTotal: Number(it.lineTotal || it.total || 0) || 0,
                checkInDate: it.checkIn || it.checkInDate || "",
                checkOutDate: it.checkOut || it.checkOutDate || ""
              }));

              const cards = Array.from(
                document.querySelectorAll('.section-body[data-section-body="1"] .dates-grid[data-lineid]')
              );

              const byLineIdTotal = new Map();
              const byLineIdDates = new Map();

              cards.forEach(card => {
                const lineId = String(card.getAttribute("data-lineid") || "");
                if (!lineId) return;

                const v = Number(card.dataset ? card.dataset.lineTotal : NaN);
                if (Number.isFinite(v)) byLineIdTotal.set(lineId, v);

                const wrap = card.closest(".tile, .card, .dates-grid, .section-block, .room-card, .checkout-card") || card.parentElement || card;

                const candidates = Array.from(wrap.querySelectorAll("*"))
                  .map(el => (el && el.textContent ? el.textContent.trim() : ""))
                  .filter(t => /[A-Za-z]{3,9}\s+\d{1,2},\s+\d{4}\s+to\s+[A-Za-z]{3,9}\s+\d{1,2},\s+\d{4}/.test(t));

                const range = candidates.length ? candidates[0] : "";

                function parseMDYToUTCDate(s){
                  const m = s.match(/^([A-Za-z]{3,9})\s+(\d{1,2}),\s+(\d{4})$/);
                  if (!m) return null;
                  const monStr = m[1].toLowerCase();
                  const day = Number(m[2]);
                  const year = Number(m[3]);
                  const months = {
                    jan:0,january:0,feb:1,february:1,mar:2,march:2,apr:3,april:3,may:4,
                    jun:5,june:5,jul:6,july:6,aug:7,august:7,sep:8,september:8,
                    oct:9,october:9,nov:10,november:10,dec:11,december:11
                  };
                  const mon = months[monStr];
                  if (mon === undefined) return null;
                  return new Date(Date.UTC(year, mon, day, 0, 0, 0));
                }

                if (range && range.includes(" to ")) {
                  const parts = range.split(" to ").map(s => s.trim());
                  if (parts.length === 2) {
                    const d1 = parseMDYToUTCDate(parts[0]);
                    const d2 = parseMDYToUTCDate(parts[1]);
                    if (d1 && d2) {
                      byLineIdDates.set(lineId, {
                        checkInDate: d1.toISOString().slice(0,10),
                        checkOutDate: d2.toISOString().slice(0,10)
                      });
                    }
                  }
                }
              });

              return baseItems.map(it => {
                const domTotal = byLineIdTotal.get(it.lineId);
                const domDates = byLineIdDates.get(it.lineId);
                return {
                  roomTypeId: it.roomTypeId,
                  ratePlanId: it.ratePlanId,
                  qty: it.qty,
                  currency: it.currency,
                  lineTotal: Number.isFinite(domTotal) ? domTotal : it.lineTotal,
                  checkInDate: (domDates && domDates.checkInDate) ? domDates.checkInDate : (it.checkInDate || state.start),
                  checkOutDate: (domDates && domDates.checkOutDate) ? domDates.checkOutDate : (it.checkOutDate || state.end)
                };
              });
            } catch (e) {
              console.log("[pay] cartItemsPayload build failed:", e);
              return [];
            }
          })();

          console.log("[pay] cartItemsPayload len:", cartItemsPayload.length, cartItemsPayload);
          // ANCHOR: PAYLOAD_CARTITEMS_DEBUG END

          const response = await fetch("/api/payments/create-checkout-session", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              // booking identifiers (server canonical)
              sid: (function(){ try { return localStorage.getItem("lolaelo_wa_sid") || ""; } catch(_) { return ""; } })(),

              partnerId: state.propertyId,
              roomTypeId: state.roomId,
              ratePlanId: state.ratePlanId,
              checkInDate: state.start,
              checkOutDate: state.end,
              qty: Number(state.qty || 1),

              // legacy identifiers (for checkout_success compatibility)
              propertyId: state.propertyId,
              roomId: state.roomId,
              start: state.start,
              end: state.end,
              propertyName: state.propertyName,
              roomName: state.roomName,
              ratePlanName: state.ratePlanName,

              // guest details (authoritative)
              travelerFirstName: (document.getElementById("firstName")?.value || "").trim(),
              travelerLastName:  (document.getElementById("lastName")?.value || "").trim(),
              travelerEmail:     (document.getElementById("email")?.value || "").trim(),
              travelerPhone:     ((document.getElementById("phoneCountry")?.value || "") + (document.getElementById("phone")?.value || "")).trim(),
              guestsCount:       Math.max(1, parseInt(String(document.getElementById("guestsCount")?.value || "1"), 10)),

              // totals (authoritative, matches the right-side UI)
              currency: "USD",
              totalCents: Math.round(Number(pay.grand || 0) * 100),

              cartItems: cartItemsPayload,

              // addons
              addons: (Array.isArray(state.selectedAddons) ? state.selectedAddons : []).map(a => ({
                addOnId: Number(a.addOnId ?? a.id ?? a.addonId ?? a.addOnID ?? 0),
                activity: a.activity,
                uom: a.uom,
                unitPrice: Number(a.unitPrice ?? a.price ?? 0),
                qty: Number(a.qty ?? a.quantity ?? 1),
                lineTotal: Number(a.lineTotal ?? 0),
                comment: a.travelerComment || a.comment || ""
              }))
            })
          });

            if (!response.ok) throw new Error("Failed to start payment");
            const data = await response.json();
            if (data && data.url) {
              window.location.href = data.url;
            } else {
              throw new Error("Missing redirect URL");
            }
          } catch (err) {
            console.error("Error starting Stripe Checkout", err);
            confirmAndPayButton.disabled = false;
            confirmAndPayButton.textContent = "Proceed to secure payment";
            alert("Could not start payment. Please try again.");
          }
        });
      }
    }

      const changePlanLink = document.getElementById("changePlanLink");
      if (changePlanLink) {
        changePlanLink.addEventListener("click", function (e) {
          e.preventDefault();

          // Deterministic navigation (no browser back stack dependency)
          // Prefer the most recent catalog_details url if present; otherwise fall back to catalog.
          const lastDetails = localStorage.getItem("checkout.lastDetailsUrl");
          if (lastDetails && typeof lastDetails === "string") {
            window.location.href = lastDetails;
            return;
          }

          window.location.href = "/catalog.html";
        });
      }

      const addonsList = document.getElementById("addonsList");
      if (addonsList) {
        addonsList.addEventListener("input", function (ev) {
          const target = ev.target;
          if (!target) return;

          const isQty =
            target.tagName === "INPUT" &&
            target.getAttribute("type") === "number" &&
            target.getAttribute("data-addon-index") != null;

          const isComment =
            target.tagName === "TEXTAREA" &&
            target.classList.contains("addon-comment") &&
            target.getAttribute("data-addon-index") != null;

          if (!isQty && !isComment) return;

          recomputeSelectedAddons();
        });
      }

    // Run init once when DOM is ready (THIS MUST BE OUTSIDE initCheckout)
    document.addEventListener("DOMContentLoaded", initCheckout);

    // BFCache guard: if user navigates back/forward and the page is restored from cache,
    // block returning to checkout after success, otherwise force a real reload.
    window.addEventListener("pageshow", function (e) {
      try {
        const after = localStorage.getItem("checkout.afterSuccessAt");
        if (after) {
          localStorage.removeItem("checkout.cart.v1");
          localStorage.removeItem("checkout.selection.v1");
          localStorage.removeItem("checkout.lastPropertyId");
          localStorage.removeItem("checkout.lastDetailsUrl");
          // keep the flag so Back cannot resurrect checkout
          location.replace("/catalog.html");
          return;
        }
      } catch (_) {}
    });
  </script>

	  <script>
    (function () {
      const tickerImg = document.querySelector(".card-logo-ticker");
      if (!tickerImg) return;

      // TODO: make sure these 5 files exist in /assets on lolaelo.com
      const logos = [
        "/images/cards/card_visa.png",
        "/images/cards/card_mastercard.png",
        "/images/cards/card_applepay.png",
        "/images/cards/card_discover.png",
        "/images/cards/card_amex.png",
      ];

      let index = 0;
      setInterval(() => {
        index = (index + 1) % logos.length;
        tickerImg.src = logos[index];
      }, 1500);
    })();
  </script>

  <!-- ANCHOR: ADDONS_MODAL -->
  <div id="addonsModalBackdrop" class="addons-modal-backdrop" style="display:none;">
    <div class="addons-modal">
      <div class="addons-modal-header">
        <h2 class="addons-modal-title">Explore add-ons</h2>
        <button
          type="button"
          class="addons-modal-close"
          id="addonsModalCloseBtn"
          data-close-addons-modal
        >
          Ã—
        </button>
      </div>

      <div class="addons-modal-body" id="addonsModalBody">
        <!-- Rows will be injected here -->
      </div>

      <div class="addons-modal-footer">
        <div class="addons-modal-subtotal">
          Add-ons total: <span id="addonsModalSubtotal">--</span>
        </div>
        <div class="addons-modal-actions">
          <button
            type="button"
            class="btn-secondary"
            id="addonsModalCancelBtn"
            data-close-addons-modal
          >
            Cancel
          </button>
          <button
            type="button"
            class="btn-primary"
            id="addonsModalApplyBtn"
            data-apply-addons-modal
          >
            Apply add-ons
          </button>
        </div>
      </div>
    </div>
  </div>

  <style>
    .section-intro {
      margin: 0 0 12px;
      font-size: 0.9rem;
      color: #4b5563; /* darker, readable */
    }

    .addons-explore-pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 10px 22px;
      border-radius: 999px;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      border: 2px solid transparent;
      background:
        linear-gradient(#ffffff, #ffffff) padding-box,
        linear-gradient(135deg, #0f766e, #14b8a6) border-box;
      color: #0f766e;
      transition:
        box-shadow 0.15s ease,
        transform 0.05s ease;
      margin-bottom: 16px;
    }

    .addons-explore-pill:hover {
      box-shadow: 0 4px 10px rgba(15, 118, 110, 0.18);
      transform: translateY(-1px);
    }

    .addons-explore-pill:active {
      transform: translateY(0);
      box-shadow: 0 2px 5px rgba(15, 118, 110, 0.2);
    }

    /* Modal backdrop */
    .addons-modal-backdrop {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(15, 23, 42, 0.35);
      z-index: 50;
    }

    .addons-modal-backdrop.is-open {
      display: flex;
    }

    /* Wider modal: ~1.5x previous width */
    .addons-modal {
      width: 100%;
      max-width: 1080px;
      max-height: 80vh;
      background: #ffffff;
      border-radius: 16px;
      box-shadow: 0 20px 40px rgba(15, 23, 42, 0.25);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .addons-modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 24px;
      border-bottom: 1px solid #e5e7eb;
    }

    .addons-modal-title {
      margin: 0;
      font-size: 1rem;
      font-weight: 600;
    }

    .addons-modal-close {
      border: none;
      background: transparent;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      color: #6b7280;
    }

    .addons-modal-close:hover {
      color: #111827;
    }

    #addonsModalBackdrop .addons-modal-body {
      padding: 16px 80px;        /* wider left/right indent */
      overflow-y: auto;          /* scroll only vertically */
      overflow-x: hidden;        /* prevent sideways scrolling */
      font-size: 14px;           /* modal text slightly larger */
      box-sizing: border-box;    /* padding stays consistent */
    }

    /* Inline add-ons total pill under Section 3 */
    #addonsInlineTotalWrapper .addons-inline-total-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 14px;
      border-radius: 999px;
      border: 1px solid #e5e7eb;
      background: #f9fafb;
      font-size: 13px;
    }

    #addonsInlineTotalWrapper .addons-inline-total-amount {
      font-weight: 600;
      color: #111827;
    }

    .addons-modal-intro {
      margin: 0 0 12px;
      font-size: 0.9rem;
      color: #4b5563;
    }

    .addons-modal-footer {
      padding: 12px 24px 16px;
      border-top: 1px solid #e5e7eb;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 8px; /* subtotal above buttons */
    }

    .addons-modal-subtotal {
      font-weight: 600;
      font-size: 14px;
    }

    .addons-modal-actions {
      display: flex;
      gap: 10px;
    }

    /* Buttons inside modal only */
    #addonsModalBackdrop .btn-primary {
      padding: 7px 22px;
      min-height: 40px;
      border-radius: 999px;
      background: linear-gradient(135deg, #ff6a3d, #ff7a4c);
      color: #ffffff;
      border: none;
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
    }

    #addonsModalBackdrop .btn-secondary {
      padding: 10px 24px;
      min-height: 40px;
      border-radius: 999px;
      border: 1px solid #d1d5db;
      background: #ffffff;
      cursor: pointer;
      font-size: 14px;
    }

    /* Column layout inside modal body â€“ 5 columns:
       Activity Â· Unit Â· Price per unit Â· Qty Â· Total
       (use fr units so everything contracts inside the modal width) */
    #addonsModalBackdrop .addon-row,
    #addonsModalBackdrop .addon-row-header {
      display: grid;
      grid-template-columns: 3fr 1.1fr 1.3fr 1fr 1.3fr; /* tighter Unit/Total */
      column-gap: 6px;                                 /* smaller gaps */
      align-items: center;
      padding: 8px 0;
      font-size: 14px;
      box-sizing: border-box;
      width: 100%;
    }

    #addonsModalBackdrop .addon-row-header {
      border-bottom: 1px solid #e5e7eb;
      margin-bottom: 4px;
      padding-bottom: 4px;
      font-weight: 600;
    }

    #addonsModalBackdrop .addon-col-activity {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    #addonsModalBackdrop .addon-col-activity .addon-title {
      font-weight: 500;
    }

    #addonsModalBackdrop .addon-col-activity .addon-meta {
      font-size: 12px;
      color: #6b7280;
    }

    #addonsModalBackdrop .addon-col-uom,
    #addonsModalBackdrop .addon-col-price,
    #addonsModalBackdrop .addon-col-qty,
    #addonsModalBackdrop .addon-col-total {
      font-size: 13px;
      color: #111827;
      white-space: nowrap;
    }

    #addonsModalBackdrop .addon-col-price {
      white-space: nowrap;
    }

    #addonsModalBackdrop .addon-col-qty {
      display: flex;
      flex-direction: column;
      align-items: center; /* center Qty under header */
      gap: 4px;
    }

    #addonsModalBackdrop .addon-col-qty label {
      font-size: 12px;
      color: #6b7280;
    }

    #addonsModalBackdrop .addon-col-qty input {
      width: 72px;
      padding: 4px 6px;
      border-radius: 8px;
      border: 1px solid #d1d5db;
      text-align: center;
      font-size: 13px;
      -moz-appearance: textfield;
      appearance: textfield;
    }

    #addonsModalBackdrop .addon-col-total {
      text-align: right;
      font-size: 13px;
      font-weight: 500;
    }

    /* ANCHOR: ADDONS_MODAL_MOBILE_OPTIMIZE */
    @media (max-width: 560px){

      /* Modal container sizing */
      #addonsModalBackdrop .addons-modal{
        width: calc(100vw - 24px);
        max-width: calc(100vw - 24px);
        max-height: calc(100vh - 24px);
      }

      /* Body padding: remove desktop "table indent" */
      #addonsModalBackdrop .addons-modal-body{
        padding: 12px 14px !important; /* overrides 16px 80px */
      }

      /* Convert table grid into stacked cards per row */
      #addonsModalBackdrop .addon-row-header{
        display: none !important;
      }

      #addonsModalBackdrop .addon-row{
        display: grid !important;
        grid-template-columns: 1fr 1fr !important;
        grid-template-areas:
          "activity activity"
          "uom      price"
          "qty      total";
        gap: 8px 10px !important;
        padding: 12px 0 !important;
        border-bottom: 1px solid #e5e7eb;
      }

      #addonsModalBackdrop .addon-col-activity{ grid-area: activity; }
      #addonsModalBackdrop .addon-col-uom{ grid-area: uom; }
      #addonsModalBackdrop .addon-col-price{ grid-area: price; text-align: right; }
      #addonsModalBackdrop .addon-col-qty{ grid-area: qty; align-items: flex-start !important; }
      #addonsModalBackdrop .addon-col-total{ grid-area: total; text-align: right; }

      #addonsModalBackdrop .addon-col-qty input{
        width: 100% !important;
        max-width: 120px;
        text-align: left !important;
      }

      /* Footer actions: stack buttons full width */
      #addonsModalBackdrop .addons-modal-actions{
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }

      #addonsModalBackdrop .addons-modal-actions .btn-secondary,
      #addonsModalBackdrop .addons-modal-actions .btn-primary{
        width: 100%;
        justify-content: center;
      }
    }

  </style>
  <!-- END ANCHOR: ADDONS_MODAL -->

  <script>
  // === Date Guardrails (no past dates) ===
  function parseYmd(s){
    // Accepts YYYY-MM-DD only
    const m = String(s || "").trim().match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (!m) return null;
    const y = Number(m[1]), mo = Number(m[2]), d = Number(m[3]);
    const dt = new Date(y, mo - 1, d);
    // Validate rollover
    if (dt.getFullYear() !== y || (dt.getMonth() + 1) !== mo || dt.getDate() !== d) return null;
    // Normalize to local midnight
    dt.setHours(0,0,0,0);
    return dt;
  }

  function todayLocal(){
    const t = new Date();
    t.setHours(0,0,0,0);
    return t;
  }

  function validateStayDates(startStr, endStr){
    const start = parseYmd(startStr);
    const end = parseYmd(endStr);
    const t = todayLocal();

    if (!start || !end) return { ok:false, reason:"invalid_format" };
    if (end.getTime() <= start.getTime()) return { ok:false, reason:"end_before_start" };
    if (start.getTime() < t.getTime()) return { ok:false, reason:"start_in_past" };
    // Optional hard rule: disallow checkout in past too (covered by start rule, but explicit)
    if (end.getTime() < t.getTime()) return { ok:false, reason:"end_in_past" };

    return { ok:true };
  }

  function setBtnEnabled(btn, enabled){
    if (!btn) return;
    btn.disabled = !enabled;
    btn.style.opacity = enabled ? "" : "0.55";
    btn.style.pointerEvents = enabled ? "" : "none";
  }

  function showDateError(containerEl, msg){
    if (!containerEl) return;
    let el = containerEl.querySelector(".date-guard-error");
    if (!el){
      el = document.createElement("div");
      el.className = "date-guard-error";
      el.style.marginTop = "10px";
      el.style.color = "#b91c1c";
      el.style.fontSize = "13px";
      el.style.fontWeight = "600";
      containerEl.appendChild(el);
    }
    el.textContent = msg || "";
    el.style.display = msg ? "block" : "none";
  }

  function guardDatesOrDisable(opts){
    // opts: { startStr, endStr, btns: [..], containerEl }
    const v = validateStayDates(opts.startStr, opts.endStr);
    const ok = !!v.ok;

    for (const b of (opts.btns || [])) setBtnEnabled(b, ok);

    if (ok){
      showDateError(opts.containerEl, "");
      return true;
    }

    const msg =
      v.reason === "start_in_past" ? "Check-in date cannot be in the past." :
      v.reason === "end_before_start" ? "Check-out must be after check-in." :
      v.reason === "invalid_format" ? "Invalid date format." :
      "Invalid dates.";

    showDateError(opts.containerEl, msg);
    return false;
  }
</script>
</body>
</html>

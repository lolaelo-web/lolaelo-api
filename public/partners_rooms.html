<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Partners · Rooms & Availability</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'><rect width='16' height='16' fill='%234f8cff'/></svg>" type="image/svg+xml">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/css/extranet.css">
  <!-- FP: MN8-no-overlap -->
  <!-- FP: MN9-dist-source -->

  <style>
    :root{
      --bg:#0b0d12; --panel:#121621; --panel-2:#161b28; --text:#e7ecf3; --muted:#98a3b3;
      --brand:#4f8cff; --accent:#ffb86b; --ok:#2ecc71; --warn:#f39c12; --err:#e74c3c;
      --border:#222a3a; --chip:#1e2536; --header-h:56px;
    }
    *{ box-sizing:border-box; }
    body{ margin:0; background:var(--bg); color:var(--text);
      font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; overflow:hidden; }
    header{ display:flex; gap:12px; align-items:center; padding:14px 18px; height:var(--header-h);
      border-bottom:1px solid var(--border); background:var(--panel); position:sticky; top:0; z-index:5; }
    header h1{ font-size:16px; margin:0; letter-spacing:.2px; white-space:nowrap; }
    .spacer{ flex:1; }
    .header-actions{ display:flex; gap:8px; align-items:center; }
    .header-actions .note{ white-space:nowrap; }

    .wrap{ display:grid; grid-template-columns:300px 1fr; height:calc(100vh - var(--header-h)); overflow:hidden; }
    .left{ border-right:1px solid var(--border); background:var(--panel); display:flex; flex-direction:column; min-width:0; }
    .right{ background:var(--panel-2); display:flex; flex-direction:column; min-width:0; }
    
    .toolbar{ display:flex; gap:8px; padding:10px; border-bottom:1px solid var(--border); background:var(--panel); }
    .toolbar input,.toolbar select{ background:var(--chip); border:1px solid var(--border); color:var(--text); padding:8px 10px; border-radius:8px; }
    /* ANCHOR: LOCAL_CSS — scope button/input rules so .btn/.input from extranet.css win */
    .toolbar button:not(.btn){ background:var(--brand); border:0; color:#fff; padding:8px 12px; border-radius:8px; cursor:pointer; }
    .toolbar button.secondary:not(.btn){ background:transparent; border:1px solid var(--border); color:var(--text); }

    .list{ flex:1; overflow:auto; padding:8px; }
    .room{ padding:10px; border:1px solid var(--border); border-radius:10px; background:var(--panel-2);
      margin-bottom:8px; display:flex; justify-content:space-between; align-items:center; cursor:pointer; }
    .room.active{ outline:2px solid var(--brand); } /* changed from var(--accent) to var(--brand) */
    .room .name{ font-weight:600; }
    .room .meta{ color:var(--muted); font-size:12px; }
    .room .actions{ display:flex; gap:6px; }
    .room .actions button{ padding:6px 8px; font-size:12px; border-radius:8px; }
    #add-room{ padding:8px 10px; font-weight:600; }

    .right .controls{ display:flex; flex-wrap:wrap; gap:8px; padding:10px;
      border-bottom:1px solid var(--border); background:var(--panel); align-items:center; }
    .controls input:not(.input){ background:var(--chip); border:1px solid var(--border); color:var(--text); padding:8px 10px; border-radius:8px; }
    .controls .group{ display:flex; gap:6px; align-items:center; }
    .controls .group label{ color:var(--muted); font-size:12px; }
    .controls .flag{ display:flex; gap:6px; align-items:center; color:var(--muted); font-size:12px; }

    .calendar{ flex:1; overflow:auto; padding:12px; }
    .cal-grid{ display:grid; grid-auto-flow:column; grid-auto-columns:140px; gap:10px; }
    .day{ background:var(--panel); border:1px solid var(--border); border-radius:10px; padding:8px; min-height:120px; display:flex; flex-direction:column; gap:6px; }
    .day .date{ font-weight:600; font-size:12px; color:var(--muted); }
    /* ANCHOR: DAY_FOCUS_CSS */
    .day:focus-within{
      box-shadow: 0 0 0 2px var(--brand);
    }

    /* ANCHOR: WEEKEND_BADGE_CSS */
    .day .date .we-badge{
      display:inline-block;
      background: var(--accent);
      color: #000;            /* black text */
      font-weight:700;
      font-size:10px;
      line-height:14px;
      padding:0 6px;
      border-radius:6px;
      margin-right:6px;
      vertical-align:baseline;
    }

    /* ANCHOR: DIRTY_BADGE_CSS */
    .day.is-dirty .date::after{
      content:"";
      display:inline-block;
      width:6px; height:6px;
      margin-left:6px;
      border-radius:50%;
      background: var(--accent); /* subtle orange */
      vertical-align:middle;
    }

    /* Make horizontal scroll feel intentional in the calendar area */
    .calendar{ overscroll-behavior: contain; }

    /* ANCHOR: CAL_LOADING_CSS */
    @keyframes spin { to { transform: rotate(360deg); } }

    .calendar.loading {
      position: relative;
    }

    .calendar.loading::after {
      content:"";
      position:absolute;
      inset:0;
      background:rgba(0,0,0,.18);
      border-radius:10px;
    }

    .calendar.loading::before {
      content:"";
      position:absolute;
      top:50%; left:50%;
      width:28px; height:28px;
      margin:-14px 0 0 -14px;
      border:3px solid rgba(255,255,255,.25);
      border-top-color: var(--brand);
      border-radius:50%;
      animation: spin .8s linear infinite;
      z-index:1;
    }

    /* ANCHOR: DAY_FLASH */
    @keyframes dayFlash {
      0%   { box-shadow: 0 0 0 0 rgba(79,140,255,.0); }
      30%  { box-shadow: 0 0 0 4px rgba(79,140,255,.25); }
      100% { box-shadow: 0 0 0 0 rgba(79,140,255,.0); }
    }
    .day.flash {
      animation: dayFlash 1.2s ease-out 1;
    }

    .chip{ background:var(--chip); border:1px solid var(--border); padding:6px 8px; border-radius:10px; font-size:12px;
      display:grid; grid-template-columns: 1fr minmax(64px, 90px); align-items:center; gap:8px; min-width:0; }
    .chip .tag{ color:var(--muted); font-size:11px; }
    .chip input{ width:100%; text-align:right; background:transparent; border:0; color:var(--text);
      padding:4px 0; outline:none; font-variant-numeric:tabular-nums; overflow:hidden; text-overflow:clip; white-space:nowrap; min-width:0; }
    .chip input[data-kind="open"]{    padding-right: 0.25ch; }
    .chip input[data-kind="price"]{   padding-right: 0; }
    .chip input[data-kind="minstay"]{ padding-right: 0.25ch; }
    /* ANCHOR: INV_CELL_WIDTH_5CH */
    .chip input[data-kind="open"],
    .chip input[data-kind="minstay"]{
      width: 10.5ch;          /* ~5 digits visible with small breathing room */
      padding-left: 0.25ch;  /* keep symmetric tiny padding */
    }

    /* ANCHOR: DAY_CELL_VALUE_OFFSETS — center-ish numeric values inside day tiles */
    #cal-grid .chip .money{ 
      justify-content: center;          /* center the $ + input row only inside calendar tiles */
    }

    #cal-grid .chip input[data-kind="open"]{
      text-align: center;
    }

    #cal-grid .chip .money input[data-kind="price"]{
      text-align: center;
      width: 8ch;                        /* keep a stable field width for centering */
    }

    #cal-grid .chip input[data-kind="minstay"]{
      text-align: center;
      transform: translateX(-2ch); 
    }

    /* bulk controls (top row) */
    #inv-open,
    #inv-minstay{
      width: 5ch;            /* same visual cap for bulk fields */
    }
    .chip input.error{ outline:1px solid var(--err); }

    /* Bulk Price input error state */
    #price.error{ outline:1px solid var(--err); }

    /* Bulk Inventory input error state */
    #inv-open.error,
    #inv-minstay.error{ outline:1px solid var(--err); }

    .chip .money{ display:flex; justify-content:flex-end; align-items:center; gap:6px; }
    .chip .money .prefix{ color:var(--muted); font-weight:600; user-select:none; }
    .chip .money input{ flex:1 1 auto; width:auto; min-width:0; }

    input[type=number]{ appearance:textfield; -moz-appearance:textfield; }
    input[type=number]::-webkit-outer-spin-button,
    input[type=number]::-webkit-inner-spin-button{ -webkit-appearance:none; margin:0; }

    button:not(.btn){ background:var(--brand); color:#fff; border:0; border-radius:8px; padding:8px 12px; cursor:pointer; }
    button.secondary:not(.btn){ background:transparent; border:1px solid var(--border); color:var(--text); }
    .btn-accent{ background:var(--accent); color:#0b0d12; }
    .btn-accent:hover{ filter:brightness(1.05); }

    .note{ color:var(--muted); font-size:12px; padding:0 10px; }
    .error{ color:var(--err); }
    .ok{ color:var(--ok); }
    .warn{ color:var(--warn); }
    code.k{ background:var(--chip); padding:2px 6px; border-radius:6px; }
    .disabled{ opacity:.6; pointer-events:none; }

    /* ANCHOR: TOAST_CSS */
    .toast-wrap{ position:fixed; right:16px; bottom:16px; display:flex; flex-direction:column; gap:8px; z-index:9999; }
    .toast{ background:var(--panel-2); border:1px solid var(--border); color:var(--text); padding:10px 12px; border-radius:10px; box-shadow:0 8px 20px rgba(0,0,0,.35); opacity:0; transform:translateY(8px); transition:opacity .18s ease, transform .18s ease; font-size:13px; }
    .toast.in{ opacity:1; transform:translateY(0); }
    .toast.ok{ border-color:rgba(46,204,113,.45); }
    .toast.warn{ border-color:rgba(243,156,18,.6); }
    .toast.error{ border-color:rgba(231,76,60,.6); }

    /* Let shared .btn control background; ensure white text */
    #save{ color:#fff; }
    #save:disabled{ opacity:.6; cursor:not-allowed; }

    #apply-price:disabled,
    #apply-inv:disabled{ opacity:.6; cursor:not-allowed; }

    .month-nav{ display:flex; align-items:center; gap:8px; padding:10px; border-bottom:1px solid var(--border); background:var(--panel); }
    .month-nav .nav-btn{ border:1px solid var(--border); background:var(--chip); padding:.25rem .5rem; border-radius:.5rem; line-height:1.2; cursor:pointer; color:var(--text); }
    .month-nav .nav-btn:hover{ filter:brightness(1.05); }
    .month-nav .month-label{ font-weight:600; letter-spacing:.2px; min-width:8rem; text-align:center; user-select:none; cursor:default; color:var(--text); }
    .month-select{ display:none; }

    /* Modal (Edit Room) */
    .modal{ position:fixed; inset:0; display:none; place-items:center; background:rgba(0,0,0,.45); z-index:50; }
    .modal.open{ display:grid; }
    .dialog{ width:min(520px, calc(100vw - 24px)); background:var(--panel-2); border:1px solid var(--border); border-radius:12px; box-shadow:0 12px 26px rgba(0,0,0,.45); }
    .dialog header{ display:flex; align-items:center; justify-content:space-between; padding:12px 14px; border-bottom:1px solid var(--border); background:var(--panel); }
    .dialog header h3{ margin:0; font-size:15px; }
    .dialog .body{ padding:14px; display:grid; gap:12px; }
    .dialog .row{ display:grid; grid-template-columns:140px 1fr; gap:10px; align-items:center; }
    .dialog input:not(.input){ background:var(--chip); border:1px solid var(--border); color:var(--text); padding:9px 10px; border-radius:8px; width:100%; }
    .dialog footer{ display:flex; gap:8px; justify-content:flex-end; padding:12px 14px; border-top:1px solid var(--border); background:var(--panel); }
    .muted{ color:var(--muted); font-size:12px; }
    .warn-msg{ color:var(--warn); font-size:12px; }

    /* RATE_PLAN_FILTER (moved under Price group) */
    .rate-plan-selector{ display:grid; grid-template-columns: 1fr; gap:4px; align-self:flex-start; min-width:220px; }
    .rate-plan-selector label{ color:var(--muted); font-size:12px; line-height:1; margin-left:2px; }
    #ratePlanSelect{ min-width:200px; }

  /* Header actions: allow wrapping and reduce button height */
  .header-actions{ flex-wrap:wrap; }
  .header-actions .btn{ height:32px; padding:6px 10px; line-height:18px; }

  /* Price row: Price | Apply | Rate plan | Copy — always below Range/Inventory */
  .controls .group.price-group{
    /* force its own line below Range/Inventory */
    flex: 1 0 100%;
    width: 100%;
    
    display:grid;
    grid-template-columns: auto auto auto 1fr;
    grid-template-areas: "price apply plan copy";
    column-gap:12px;
    row-gap:10px;
    align-items:end;
  }
    /* Inventory row: its own line below Range, above Price */
    .controls .group.inventory-group{
      flex: 1 0 100%;
      width: 100%;
    }
    /* ANCHOR: INV_BULK_WIDTH_5CH */
    #inv-open,
    #inv-minstay{
      box-sizing: border-box;      /* explicit; global * is already border-box */
      padding-left: 4px !important;
      padding-right: 4px !important;  /* override theme padding if needed */
      width: calc(10ch + 8px);      /* ≈ 5ch content + 4px L/R padding */
    }

  /* Price block (label + input stacked), 8-char visual width */
  .price-field{ grid-area:price; display:grid; grid-template-rows:auto auto; gap:6px; }
  #price{ width:12ch; }

  /* Rate plan block (label + select stacked) */
  .rate-plan-selector{ grid-area:plan; display:grid; grid-template-rows:auto auto; gap:6px; align-self:end; min-width:220px; }
  .rate-plan-selector label{ color:var(--muted); font-size:12px; line-height:1; margin-left:2px; }
  #ratePlanSelect{ min-width:220px; }

  /* Actions placement */
  #apply-price{ grid-area:apply; justify-self:start; align-self:end; }
  #copy-link{ grid-area:copy;  justify-self:start; align-self:end; }

  </style>
</head>
<body>
  <header>
    <h1>Rooms & Availability</h1>
    <div class="spacer"></div>
    <div class="header-actions"><!-- ANCHOR: HEADER_ACTIONS -->

      <!-- RATE_PLAN_FILTER END -->
      <span id="status" class="note">Ready.</span>
      <span id="dirty-count" class="note">No changes</span>
      <button id="save" class="btn" disabled>Save changes</button>
      <button id="discard" class="secondary btn btn-secondary-outline" disabled>Discard changes</button>
      <button id="back" class="secondary btn btn-secondary-outline" onclick="location.href='/partners_app.html'">Back to menu</button>
    </div>
  </header>

  <div class="wrap">
    <aside class="left">
      <div class="toolbar"><!-- ANCHOR: TOOLBAR_ADD_ROOM -->
        <button id="add-room" class="secondary btn btn-secondary-outline">+ Add room type</button>
      </div>
      <div class="list" id="rooms-list"></div>
    </aside>

    <section class="right">
      <div id="month-nav" class="month-nav" role="group" aria-label="Month navigator">
        <button id="month-prev" class="nav-btn" type="button" aria-label="Previous month">◀</button>
        <span id="month-label" class="month-label" title="Month">Sep 2025</span>
        <select id="month-select" class="month-select" aria-label="Select month"></select>
        <button id="month-today" class="nav-btn" type="button" aria-label="Jump to today">Today</button>
        <button id="month-next" class="nav-btn" type="button" aria-label="Next month">▶</button>
      </div>

      <div class="controls">
        <div class="group">
          <label>Range</label>
          <input type="date" id="range-start" class="input" />
          <input type="date" id="range-end" class="input" />
          <button type="button" id="range-7"  class="secondary btn btn-secondary-outline">7d</button>
          <button type="button" id="range-14" class="secondary btn btn-secondary-outline">14d</button>
          <button type="button" id="range-21" class="secondary btn btn-secondary-outline">21d</button>
        </div>
        <div class="group inventory-group">
          <label>Inventory</label>
          <input type="number" id="inv-open" class="input" min="0" placeholder="roomsOpen" />
          <input type="number" id="inv-minstay" class="input" min="1" placeholder="minStay" />
          <span class="flag"><input type="checkbox" id="inv-closed" /> Closed</span>
          <button id="apply-inv" class="secondary btn btn-secondary-outline" title="Applies immediately (auto-saves)">Apply Inventory</button>
        </div>
        <div class="group price-group">
          <div class="price-field">
            <label>Price</label>
            <input id="price" class="input" placeholder="149.00" inputmode="decimal" maxlength="8" />
          </div>

          <button id="apply-price" class="secondary btn btn-secondary-outline" title="Applies immediately (auto-saves)">Apply Price</button>

          <div class="rate-plan-selector">
            <label for="ratePlanSelect">Rate plan</label>
            <select id="ratePlanSelect" class="input">
              <option value="1">Standard (1)</option>
            </select>
          </div>

          <button id="copy-link" class="secondary btn btn-secondary-outline" type="button" title="Copy the current link with room, date range, and plan">Copy link</button>
        </div>
          </div> <!-- CLOSES .controls -->

          <div class="calendar">
            <div id="cal-grid" class="cal-grid"></div>
          </div>

    </section>
  </div>

  <!-- Edit Room Modal -->
  <div id="edit-modal" class="modal" aria-modal="true" role="dialog" aria-labelledby="edit-title">
    <div class="dialog">
      <header>
        <h3 id="edit-title">Edit room</h3>
        <span class="muted" id="edit-id"></span>
      </header>
      <div class="body">
        <div class="row">
          <label for="edit-name" class="muted">Name</label>
          <input id="edit-name" class="input" autocomplete="off" />
        </div>
        <div class="row">
          <label for="edit-base" class="muted">Base price (USD)</label>
          <input id="edit-base" class="input" inputmode="decimal" autocomplete="off" />
        </div>
        <div class="row">
          <label for="edit-max" class="muted">Max capacity</label>
          <input id="edit-max" class="input" type="number" min="1" step="1" />
        </div>
        <div class="row">
          <label for="edit-active" class="muted">Status</label>
          <select id="edit-active" class="input">
            <option value="true">Active</option>
            <option value="false">Inactive</option>
          </select>
        </div>
        <div class="warn-msg" id="edit-warn" style="display:none;"></div>
      </div>
      <footer>
        <button id="edit-cancel" class="secondary btn btn-secondary-outline" type="button">Cancel</button>
        <button id="edit-save" class="btn" type="button">OK</button>
      </footer>
    </div>
  </div>

<script>
(() => {
  /* ===== Month window core ===== */
  const WEEK_START = 1;
  let visibleWeeks = 3;
  let currentMonth = (() => { const d=new Date(); return new Date(d.getFullYear(), d.getMonth(), 1); })();
  let currentAnchor = null;

  const el = (id) => document.getElementById(id);
  const status = el("status");
  const roomsList = el("rooms-list");
  const calGrid = el("cal-grid");
  const monthPrevBtn = el("month-prev");
  const monthNextBtn = el("month-next");

  let currentRoomTypeId = null;
  let currentRangeStart = null, currentRangeEnd = null;

  // Reason/note for rate plan load outcome (used for UI messaging)
  let lastRatePlanLoadNote = '';

  let busy = false;
  window.addEventListener('beforeunload', function(e){
    if (pendingRoomUpdates.size > 0 || dirty.size > 0){
      e.preventDefault();
      e.returnValue = '';
    }
  });
  const pendingRoomUpdates = new Map(); // roomId -> payload
  const readOnlyRoomField = new Map();  // roomId -> true

  const clamp = (v,min,max)=>Math.min(Math.max(v,min),max);
  const toNumber = (v) => {
    if (v === null || v === undefined || v === "") return NaN;
    const n = Number(String(v).replace(/[^0-9.-]/g, ""));
    return Number.isFinite(n) ? n : NaN;
  };
  const fmtUSD = (v) => { const n = toNumber(v); if (!Number.isFinite(n)) return ""; return "$" + n.toFixed(2); };
  const iso = (d)=>d.toISOString().slice(0,10);
  const todayISO = ()=>iso(new Date());
  const API_BASE = (location.origin.includes('lolaelo-api.onrender.com') ? '' : 'https://lolaelo-api.onrender.com');

  /* ANCHOR: CTX_HELPERS */
  const LS_CTX = 'rooms_ctx_v1';
  function saveCtx(){
    try{
      localStorage.setItem(LS_CTX, JSON.stringify({
        roomId: currentRoomTypeId,
        start: currentRangeStart,
        end:   currentRangeEnd,
        ratePlanId: currentRatePlanId
      }));
    }catch(_){}
  }
  function loadCtx(){
    try{
      const raw = localStorage.getItem(LS_CTX);
      if (!raw) return null;
      const j = JSON.parse(raw);
      return (j && typeof j === 'object') ? j : null;
    }catch(_){ return null; }
  }
  function startOfWeek(dt, weekStart=WEEK_START){
    const d=new Date(dt.getFullYear(),dt.getMonth(),dt.getDate());
    const diff=(d.getDay()-weekStart+7)%7; d.setDate(d.getDate()-diff); d.setHours(0,0,0,0); return d;
  }
  function addWeeks(dt,n){ const d=new Date(dt.getFullYear(),dt.getMonth(),dt.getDate()); d.setDate(d.getDate()+n*7); return d; }
  function monthLabel(dt){ return dt.toLocaleString(undefined,{month:"short",year:"numeric"}); }
  function computeWindowFromAnchor(){
    const base=currentAnchor??new Date();
    const start=startOfWeek(base);
    const end=new Date(addWeeks(start,visibleWeeks).getTime()-86400000);
    return { startISO: iso(start), endISO: iso(end) };
  }
  function setMonthLabel(){
    const lbl=el("month-label");
    const rs=(typeof currentRangeStart==="string"&&currentRangeStart)?currentRangeStart:iso(currentAnchor??new Date());
    const start=new Date(rs+"T00:00:00Z");
    if (lbl) lbl.textContent=monthLabel(start);
  }
  function applyMonthWindowToRange({rerender=false}={}){
    const {startISO,endISO}=computeWindowFromAnchor();
    const t=todayISO();
    let s=startISO<t?t:startISO;
    const minDays=(visibleWeeks*7)-1;
    let e=endISO;
    if (e<=s){ const sDate=new Date(s+"T00:00:00Z"); const eDate=new Date(sDate.getTime()+minDays*86400000); e=iso(eDate); }
    const rs=el("range-start"), re=el("range-end");
    if (rs&&re){ rs.value=s; re.value=e; }
    currentAnchor=new Date(s+"T00:00:00Z");
    currentRangeStart=s; currentRangeEnd=e;
    saveCtx();
      if (typeof updateURLFromState==='function') updateURLFromState();
      if (rerender) void renderCalendar();
  }

  /* ANCHOR: DEEPLINK_HELPERS */
  function updateURLFromState(mode='replace'){
    try{
      const qs = new URLSearchParams(location.search);
      if (currentRoomTypeId != null) qs.set('room', String(currentRoomTypeId));
      if (currentRangeStart) qs.set('start', currentRangeStart);
      if (currentRangeEnd)   qs.set('end',   currentRangeEnd);
      if (currentRatePlanId != null) qs.set('plan', String(currentRatePlanId));
      const next = location.pathname + '?' + qs.toString() + location.hash;
      if (mode === 'push') history.pushState(null, '', next);
      else history.replaceState(null, '', next);
    }catch(_){}
  }

  window.updateURLFromState = updateURLFromState;

  (function ensureToken(){
    const hashToken = new URLSearchParams(location.hash.slice(1)).get('token');
    if (hashToken) localStorage.setItem('partnerToken', hashToken);
  })();
  const token =
    localStorage.getItem("partnerToken") ||
    localStorage.getItem("lolaelo_session") || "";
  const baseHeaders = { "Content-Type": "application/json" };
  const authHeaders = token
    ? { ...baseHeaders, "Authorization": "Bearer " + token, "x-partner-token": token }
    : baseHeaders;

  /* ANCHOR: AUTH_FETCH */
  function authFetch(url, opts = {}) {
    const finalUrl = (typeof url === 'string' && url.startsWith('/')) ? (API_BASE + url) : url;
    const merged = { ...opts, headers: { ...(opts.headers||{}), ...authHeaders } };
    return fetch(finalUrl, merged).then(async (r) => {
      if (r.status === 401) {
        const hasToken = !!localStorage.getItem('partnerToken');
        setStatus(hasToken ? "Auth failed. Check token or permissions." : "Not signed in.", "warn");
        const s = document.getElementById('status');
        if (s) {
          s.innerHTML = (hasToken
            ? 'Auth failed. <a href="/partners_login.html" style="color:#4f8cff">Open login</a>'
            : 'Not signed in. <a href="/partners_login.html" style="color:#4f8cff">Open login</a>');
        }
      }
      return r;
    });
  }

  /* ANCHOR: FETCH_RETRY_HELPER */
  async function fetchWithRetry(url, opts = {}, attempts = 2, delayMs = 800){
    let lastResp;
    for (let i = 0; i < attempts; i++){
      try{
        const resp = await authFetch(url, opts);
        if (resp.status >= 500 && resp.status < 600){
          lastResp = resp;
          console.warn('Retryable status', resp.status, url);
        } else {
          return resp;
        }
      } catch (err){
        console.warn('Network error, retrying', url, err);
      }
      if (i < attempts - 1) await new Promise(r => setTimeout(r, delayMs));
    }
    return lastResp;
  }

  /* ANCHOR: RATE_PLAN_FETCH */
  const RATEPLANS_FETCH_ENABLED = false;  // set to true when /extranet/property/rateplans is live
  async function fetchRatePlansSafe(){
    lastRatePlanLoadNote = '';
    // Hard short-circuit: avoid any network call (prevents 404 log noise)
    if (!RATEPLANS_FETCH_ENABLED){
      lastRatePlanLoadNote = 'Rate plans endpoint disabled — using Standard (1).';
      return [{ id: 1, name: 'Standard (1)' }];
    }

    try{
      const r = await authFetch('/extranet/property/rateplans');
      if (!r) {
        lastRatePlanLoadNote = 'Network error loading rate plans — using Standard (1).';
        return [{ id: 1, name: 'Standard (1)' }];
      }
      if (r.status === 401 || r.status === 403){
        lastRatePlanLoadNote = 'Auth error loading rate plans — please sign in. Using Standard (1).';
        return [{ id: 1, name: 'Standard (1)' }];
      }
      if (!r.ok){
        lastRatePlanLoadNote = `Server error ${r.status} loading rate plans — using Standard (1).`;
        return [{ id: 1, name: 'Standard (1)' }];
      }
      const arr = await r.json();
      if (Array.isArray(arr) && arr.length){
        return arr
          .filter(p => p && p.id != null)
          .map(p => ({ id: Number(p.id), name: String(p.name || p.code || `Plan ${p.id}`) }));
      } else {
        lastRatePlanLoadNote = 'No rate plans found — using Standard (1).';
        return [{ id: 1, name: 'Standard (1)' }];
      }
    }catch(_){
      lastRatePlanLoadNote = 'Unexpected error loading rate plans — using Standard (1).';
      return [{ id: 1, name: 'Standard (1)' }];
    }
  }

  function populateRatePlanDropdown(plans){
    const sel = document.getElementById('ratePlanSelect');
    if (!sel) return;
    const desired = Number(currentRatePlanId) || (plans[0]?.id ?? 1);
    sel.innerHTML = '';
    for (const p of plans){
      const opt = document.createElement('option');
      opt.value = String(p.id);
      opt.textContent = p.name || `Plan ${p.id}`;
      sel.appendChild(opt);
    }
    sel.value = String(desired);
  }

  function setStatus(msg, cls=""){ status.className="note "+cls; status.textContent=msg; }

  /* ANCHOR: RIGHT_ACTIVE_TOGGLE */
  function setRightActive(flag){
    const r = document.querySelector('section.right');
    if (r) r.classList.toggle('active-room', !!flag);
  }

  /* ANCHOR: TOAST_HELPER */
  function toast(msg, kind='ok', ms=2500){
    try{
      let wrap = document.getElementById('toasts');
      if (!wrap){
        wrap = document.createElement('div');
        wrap.id = 'toasts';
        wrap.style.position='fixed';
        wrap.style.right='16px';
        wrap.style.bottom='16px';
        wrap.style.display='flex';
        wrap.style.flexDirection='column';
        wrap.style.gap='8px';
        wrap.style.zIndex='9999';
        document.body.appendChild(wrap);
      }
      const css = getComputedStyle(document.documentElement);
      const panel2 = css.getPropertyValue('--panel-2').trim() || '#161b28';
      const border = css.getPropertyValue('--border').trim() || '#222a3a';
      const text   = css.getPropertyValue('--text').trim()   || '#e7ecf3';

      const n = document.createElement('div');
      n.textContent = String(msg);
      n.setAttribute('role','status');
      n.style.background = panel2;
      n.style.border = '1px solid ' + border;
      n.style.color = text;
      n.style.padding = '10px 12px';
      n.style.borderRadius = '10px';
      n.style.boxShadow = '0 8px 20px rgba(0,0,0,.35)';
      n.style.fontSize = '13px';
      n.style.opacity = '0';
      n.style.transform = 'translateY(8px)';
      n.style.transition = 'opacity .18s ease, transform .18s ease';

      if (kind==='error') n.style.borderColor = 'rgba(231,76,60,.6)';
      else if (kind==='warn') n.style.borderColor = 'rgba(243,156,18,.6)';
      else if (kind==='ok') n.style.borderColor = 'rgba(46,204,113,.45)';

      wrap.appendChild(n);
      requestAnimationFrame(()=>{ n.style.opacity='1'; n.style.transform='translateY(0)'; });
      setTimeout(()=>{
        n.style.opacity='0'; n.style.transform='translateY(8px)';
        setTimeout(()=> n.remove(), 200);
      }, ms);
    }catch(_){}
  }

    /* ANCHOR: DIRTY_BADGE_HELPER */
    function updateDayDirtyBadge(dateISO){
      const card = document.getElementById('day-' + dateISO);
      if (!card) return;
      const o = dirty.get(dateISO);
      // “effective change” if any field is a number, boolean, or non-empty string
      const hasAny = !!o && Object.values(o).some(v =>
        typeof v === 'number' || typeof v === 'boolean' || (typeof v === 'string' && v !== '')
      );
      card.classList.toggle('is-dirty', hasAny);
    }

  function disableWhileBusy(flag){
    busy=!!flag;
    document.querySelectorAll("button, input").forEach(x=>{
      if (x.id!=="back") x.classList.toggle("disabled", busy);
      x.disabled = busy && x.id!=="back";
    });
  }
  function validateRangeOrWarn(){
    const s=el("range-start").value, e=el("range-end").value;
    if (!s||!e){ setStatus("Enter a start and end date.","error"); return false; }
    if (e<s){ setStatus("End date cannot be before start date.","error"); return false; }
    const t=todayISO(); if (s<t){ setStatus("Start date must be today or later.","error"); return false; }
    return true;
  }
  const dirty = new Map();
  function setDirty(date, kind, value){
    if (!dirty.has(date)) dirty.set(date, {});
    const o = dirty.get(date);
    o[kind] = value;

    // prune if no effective changes remain
    const hasAny = Object.values(o).some(v =>
      typeof v === 'number' || typeof v === 'boolean' || (typeof v === 'string' && v !== '')
    );
    if (!hasAny) dirty.delete(date);

    updateDayDirtyBadge(date);
    updateDirtyUI();
  }
  function updateDirtyUI(){
    const nGrid = dirty.size;
    const nRooms = pendingRoomUpdates.size;
    const invalidCount = document.querySelectorAll('.chip input.error').length;
    const totalChanges = nGrid + nRooms;

    // Build counts string
    const parts = [];
    if (nGrid)  parts.push(`${nGrid} day${nGrid>1?'s':''} changed`);
    if (nRooms) parts.push(`${nRooms} room edit${nRooms>1?'s':''}`);
    if (invalidCount) parts.push(`${invalidCount} error${invalidCount>1?'s':''}`);

    // Buttons
    const saveBtn = el("save");
    const discardBtn = el("discard");
    if (saveBtn)   saveBtn.disabled   = (totalChanges===0) || busy || (invalidCount>0);
    if (discardBtn) discardBtn.disabled = (totalChanges===0) || busy;

    // Friendlier message with CTA, while keeping counts
    let msg = "No changes";
    if (invalidCount > 0){
      msg = `Fix ${invalidCount} error${invalidCount>1?'s':''} to enable Save` + (totalChanges ? ` — ${parts.join(" + ")}` : "");
    } else if (totalChanges > 0){
      msg = `Unsaved: ${parts.join(" + ")} — click Save or Discard`;
    }

    el("dirty-count").textContent = msg;
  }

  // ANCHOR: DEBOUNCE_DIRTY_UI
  // Debounce updateDirtyUI to avoid thrashing during rapid input
  {
    const _updateDirtyUI = updateDirtyUI;  // keep original
    let t = null;
    function debounced(){ clearTimeout(t); t = setTimeout(_updateDirtyUI, 50); }
    // Replace the global reference so all existing calls are debounced
    updateDirtyUI = debounced;
  }

  /* ===== Rooms list & edit modal ===== */
  function openEditModal(rt){
    const m = el('edit-modal');
    el('edit-id').textContent = `#${rt.id}`;
    el('edit-name').value = rt.name ?? '';

    const basePlain = String(rt.basePrice ?? '').replace(/[^0-9.]/g,'');
    el('edit-base').value = basePlain;

    const maxEl = el('edit-max');
    if (maxEl) maxEl.value = (rt.occupancy ?? rt.maxGuests ?? 2);

    const activeSel = el('edit-active');
    if (activeSel) activeSel.value = String(!!rt.active);

    el('edit-warn').style.display = 'none';
    m.classList.add('open');

    // Autofocus first field and prevent background scroll
    try { el('edit-name')?.focus(); el('edit-name')?.select?.(); } catch(_){}
    const prevOverflow = document.body.style.overflow;
    document.body.style.overflow = 'hidden';

    // Key handlers: Enter => OK, Esc => Cancel
    const onKey = (ev) => {
      if (ev.key === 'Escape') {
        ev.preventDefault();
        el('edit-cancel').click();
      } else if (ev.key === 'Enter') {
        // Save on Enter unless focused element is a button/select
        const tag = (ev.target?.tagName || '').toLowerCase();
        if (tag === 'input' || tag === 'textarea') {
          ev.preventDefault();
          el('edit-save').click();
        }
      }
    };
    m.addEventListener('keydown', onKey);

    const onSave = async () => {
      const nameVal   = el('edit-name').value.trim();
      const baseVal   = el('edit-base').value.trim();
      const maxValStr = (el('edit-max')?.value ?? '').trim();
      const maxVal    = maxValStr === '' ? NaN : parseInt(maxValStr, 10);
      const activeVal = (el('edit-active')?.value === 'true');

      const payload = {};

      if (nameVal && nameVal !== rt.name) payload.name = nameVal;

      if (baseVal !== "") {
        const n = Number(baseVal);
        if (!Number.isFinite(n) || n < 0) { setStatus("Base price must be a non-negative number.","error"); return; }
        if (Number(rt.basePrice) !== n) payload.basePrice = n.toFixed(2);
      }

      if (!Number.isNaN(maxVal)) {
        if (!Number.isFinite(maxVal) || maxVal < 1) { setStatus("Max capacity must be ≥ 1.","error"); return; }
        const prevG = Number(rt.occupancy ?? rt.maxGuests);
        if (!Number.isFinite(prevG) || prevG !== maxVal) {
          payload.occupancy = maxVal;
          payload.maxGuests = maxVal;
        }
      }

      if (typeof rt.active !== 'undefined' && activeVal !== !!rt.active) {
        payload.active = activeVal;
      }

      if (!Object.keys(payload).length) { m.classList.remove('open'); return; }

      pendingRoomUpdates.set(rt.id, payload);
      updateDirtyUI();
      setStatus("Room changes queued — click Save changes to apply.", "warn");
      m.classList.remove('open');
      el('edit-save').removeEventListener('click', onSave);
      m.removeEventListener('keydown', onKey);
      document.body.style.overflow = prevOverflow;
    };

    el('edit-save').addEventListener('click', onSave, { once:true });
  }

  el('edit-cancel').addEventListener('click', ()=>{
    const m = el('edit-modal');
    m.classList.remove('open');
    try { m.removeEventListener('keydown', onKey); } catch(_){}
    document.body.style.overflow = '';
  });
    el('edit-modal').addEventListener('click', (e)=>{
    if (e.target.id==='edit-modal'){
      const m = el('edit-modal');
      m.classList.remove('open');
      try { m.removeEventListener('keydown', onKey); } catch(_){}
      document.body.style.overflow = '';
    }
  });

  async function loadRooms(){
    roomsList.innerHTML = "";
    const res = await authFetch("/extranet/property/rooms");
    if (!res.ok){ setStatus("Failed to load rooms ("+res.status+")","error"); return; }
    const data = await res.json();
    data.sort((a,b)=>String(a.name).localeCompare(String(b.name), undefined, {sensitivity:'base'}));
    if (!Array.isArray(data)) return;

    data.forEach(rt=>{
      const div = document.createElement("div");
      div.className = "room" + (rt.id === currentRoomTypeId ? " active" : "");
      const base = fmtUSD(rt.basePrice);
      const maxGuests = (rt.occupancy ?? rt.maxGuests ?? 2);
      const roBadge = readOnlyRoomField.get(rt.id) ? ` <span class="warn" title="Server treated base/max as read-only">[read-only]</span>` : "";
      const isActive = !!(rt.active ?? rt.isActive ?? (rt.status === 'ACTIVE'));
      div.innerHTML = `
        <div>
          <div class="name">${rt.name}</div>
          <div class="meta">
            Base ${base || "-"} · Max ${maxGuests}${roBadge}
            ${isActive
              ? '<span class="badge" style="margin-left:6px;">Active</span>'
              : '<span class="badge" style="margin-left:6px; background:#3a2430; color:#ffd7d7; border-color:var(--line);">Inactive</span>'}
          </div>
        </div>
        <div class="actions">
          <button type="button" class="secondary btn btn-secondary-outline" data-act="edit" data-id="${rt.id}">Edit</button>
          <button type="button" class="secondary btn btn-secondary-outline" data-act="del"  data-id="${rt.id}">Delete</button>
        </div>`;

      // Open room on card click, ignore button clicks
      div.addEventListener("click", async (e)=>{
        if (e.target.closest("button")) return;
        currentRoomTypeId = rt.id;
        saveCtx();
        updateURLFromState('push');
        if (dirty.clear) dirty.clear();

        // highlight right pane
        setRightActive(true);

        await renderCalendar();
        await loadRooms();
      });

      const editBtn = div.querySelector('button[data-act="edit"]');
      const delBtn  = div.querySelector('button[data-act="del"]');

      if (editBtn) editBtn.addEventListener("click", (e)=>{
        e.preventDefault(); e.stopPropagation();
        openEditModal(rt);
      });

      if (delBtn) delBtn.addEventListener("click", async (e)=>{
        e.preventDefault(); e.stopPropagation();
        if (!confirm("Delete this room type?")) return;
        const r = await authFetch(`/extranet/property/rooms/${rt.id}`, { method:"DELETE" });
        if (r.status === 204){
          if (currentRoomTypeId === rt.id) {
            currentRoomTypeId = null;
            setRightActive(false); // remove highlight
          }
          setStatus("Room deleted","ok");
          await loadRooms();
          calGrid.innerHTML = "";
        } else {
          setStatus("Delete failed ("+r.status+")","error");
        }
      });

      roomsList.appendChild(div);
    });
  }

    // Add Room
    el("add-room").addEventListener("click", async ()=>{
      const name=(prompt("Room type name (e.g., Deluxe Queen):")||"").trim();
      if (!name){ setStatus("Name is required.","warn"); return; }
      let p = prompt("Base price in USD (e.g., 129.00):") || "";
      p = p.replace(/[^0-9.]/g,"");
      const basePrice = Number(p);
      if (!Number.isFinite(basePrice) || basePrice < 0){ setStatus("Enter a valid non-negative price.","error"); return; }

      disableWhileBusy(true);
      const res = await authFetch("/extranet/property/rooms", {
        method:"POST",
        body: JSON.stringify({ name, basePrice: basePrice.toFixed(2), maxGuests: 2, description: "" })
      });
      disableWhileBusy(false);
      if (!res.ok){ setStatus("Create failed ("+res.status+")","error"); return; }
      const created = await res.json();
      currentRoomTypeId = created.id;
      setStatus("Room created","ok");
      await loadRooms();
      await renderCalendar();
    });

    // Range defaults + listeners
    function prepareRangeDefaults(){
      const start=new Date(); const end=new Date(start); end.setMonth(end.getMonth()+6);
      const s=iso(start), e=iso(end);
      if (!el("range-start").value) el("range-start").value=s;
      if (!el("range-end").value)   el("range-end").value=e;
      currentRangeStart=el("range-start").value; currentRangeEnd=el("range-end").value;
    }
    ["range-start","range-end"].forEach(id=>{
      el(id).addEventListener("change", ()=>{
        if (!validateRangeOrWarn()) return;
        currentRangeStart = el("range-start").value;
        currentRangeEnd   = el("range-end").value;
        saveCtx();
        updateURLFromState();
        scheduleRender(220);
      });
    });

    // ANCHOR: RANGE_GUARD_CONSTRAINTS
    (function guardRangePickers(){
      const rs = el("range-start");
      const re = el("range-end");
      if (!rs || !re) return;

      const ONE_DAY = 86400000;
      const iso = (d)=>d.toISOString().slice(0,10);
      const todayISO = ()=> iso(new Date());

      // Set initial constraints
      rs.min = todayISO();
      // keep end's min in sync with start
      const syncEndMin = ()=> { re.min = rs.value || todayISO(); };

      function ensureWindow(){
        // Keep ~3-week window if user collapses range
        if (!rs.value) rs.value = todayISO();
        if (!re.value || re.value < rs.value){
          const s = new Date(rs.value+"T00:00:00Z");
          const e = new Date(s.getTime() + (21-1)*ONE_DAY);
          re.value = iso(e);
        }
      }

      // On load/init
      syncEndMin();
      ensureWindow();

      // When start changes: push end if needed, sync min
      rs.addEventListener("change", ()=>{
        syncEndMin();
        if (!re.value || re.value < rs.value){
          const s = new Date(rs.value+"T00:00:00Z");
          const e = new Date(s.getTime() + (21-1)*ONE_DAY);
          re.value = iso(e);
        }
      });

      // When end changes: if end < start, snap back to ~3 weeks
      re.addEventListener("change", ()=>{
        if (re.value && rs.value && re.value < rs.value){
          const s = new Date(rs.value+"T00:00:00Z");
          const e = new Date(s.getTime() + (21-1)*ONE_DAY);
          re.value = iso(e);
        }
      });
    })();

    // ANCHOR: RANGE_QUICK_SELECTS
    (function wireQuickRange(){
      const rs = el("range-start");
      const re = el("range-end");
      const b7  = document.getElementById("range-7");
      const b14 = document.getElementById("range-14");
      const b21 = document.getElementById("range-21");
      if (!rs || !re) return;

      const ONE_DAY = 86400000;
      const iso = (d)=>d.toISOString().slice(0,10);

      function setRangeDays(days){
        // start: current rs (or today if empty / past-guard bumps it)
        if (!rs.value){
          const t = new Date();
          rs.value = iso(new Date(t.getFullYear(), t.getMonth(), t.getDate()));
        }
        // end: start + (days-1)
        const s = new Date(rs.value + "T00:00:00Z");
        const e = new Date(s.getTime() + (days-1)*ONE_DAY);
        re.value = iso(e);

        // sync state + URL + render (debounced if available)
        currentRangeStart = rs.value;
        currentRangeEnd   = re.value;
        saveCtx();
        updateURLFromState();
        if (typeof scheduleRender === 'function') scheduleRender(120);
        else if (typeof renderCalendar === 'function') renderCalendar();
      }

      b7?.addEventListener('click',  ()=> setRangeDays(7));
      b14?.addEventListener('click', ()=> setRangeDays(14));
      b21?.addEventListener('click', ()=> setRangeDays(21));
    })();

    // ANCHOR: BULK_PRICE_VALIDATE
    (function wireBulkPriceValidation(){
      const priceEl = el("price");
      if (!priceEl) return;

      const moneyRx = /^(\d+)(\.\d{1,2})?$/;
      function isValidMoney(v){
        if (v === "") return true; // empty is neutral
        if (!moneyRx.test(v)) return false;
        const n = parseFloat(v);
        return Number.isFinite(n) && n >= 0;
      }
      function formatMoney2(v){
        const n = parseFloat(v);
        return Number.isFinite(n) ? n.toFixed(2) : v;
      }

      priceEl.addEventListener("input", () => {
        const v = priceEl.value.trim();
        if (v === "") { priceEl.classList.remove("error"); return; }
        priceEl.classList.toggle("error", !isValidMoney(v));
      });

      // On blur (Tab / click away), normalize to two decimals if valid
      priceEl.addEventListener("blur", () => {
        const v = priceEl.value.trim();
        if (v !== "" && isValidMoney(v)){
          priceEl.value = formatMoney2(v);
          priceEl.classList.remove("error");
        }
      });
    })();

    // ANCHOR: BULK_INVENTORY_VALIDATE
    (function wireBulkInventoryValidation(){
      const invOpenEl = document.getElementById("inv-open");
      const minStayEl = document.getElementById("inv-minstay");

      function validateRoomsOpen(){
        if (!invOpenEl) return;
        const v = invOpenEl.value.trim();
        if (v === "") { invOpenEl.classList.add("error"); return false; } // required
        const n = Number(v);
        const ok = Number.isFinite(n) && n >= 0;
        invOpenEl.classList.toggle("error", !ok);
        return ok;
      }

      function validateMinStay(){
        if (!minStayEl) return true;
        const v = minStayEl.value.trim();
        if (v === "") { minStayEl.classList.remove("error"); return true; } // optional
        const n = Number(v);
        const ok = Number.isFinite(n) && n >= 1;
        minStayEl.classList.toggle("error", !ok);
        return ok;
      }

      // Live validate while typing
      if (invOpenEl) invOpenEl.addEventListener("input", validateRoomsOpen);
      if (minStayEl) minStayEl.addEventListener("input", validateMinStay);

      // Normalize on blur to integers
      if (invOpenEl) invOpenEl.addEventListener("blur", ()=>{
        if (!validateRoomsOpen()) return;
        const n = Math.floor(Number(invOpenEl.value.trim()));
        invOpenEl.value = String(n);
        invOpenEl.classList.remove("error");
      });
      if (minStayEl) minStayEl.addEventListener("blur", ()=>{
        if (!validateMinStay()) return;
        const v = minStayEl.value.trim();
        if (v === "") return; // optional
        const n = Math.floor(Number(v));
        minStayEl.value = String(n);
        minStayEl.classList.remove("error");
      });
    })();

    // ANCHOR: APPLY_BTNS_STATE
    (function wireApplyButtonsState(){
      const priceEl = el("price");
      const invOpenEl = el("inv-open");
      const minStayEl = el("inv-minstay");
      const closedEl = el("inv-closed");
      const applyPriceBtn = el("apply-price");
      const applyInvBtn = el("apply-inv");

      const moneyRx = /^(\d+)(\.\d{1,2})?$/;

      function validPrice(){
        const v = (priceEl?.value ?? "").trim();
        if (v === "") return false;
        if (!moneyRx.test(v)) return false;
        const n = parseFloat(v);
        return Number.isFinite(n) && n >= 0;
      }
      function validInventory(){
        const ro = (invOpenEl?.value ?? "").trim();
        const ms = (minStayEl?.value ?? "").trim();
        // roomsOpen: required, integer >=0
        if (ro === "") return false;
        const roN = Number(ro);
        if (!Number.isFinite(roN) || roN < 0) return false;
        // minStay: optional, but if present must be integer >=1
        if (ms !== ""){
          const msN = Number(ms);
          if (!Number.isFinite(msN) || msN < 1) return false;
        }
        // closed checkbox is always okay
        return true;
      }
      function rangeIsValid(){
        const s = el("range-start")?.value, e = el("range-end")?.value;
        return !!(s && e && e >= s);
      }

      function refresh(){
        if (applyPriceBtn) applyPriceBtn.disabled = !(currentRoomTypeId && rangeIsValid() && validPrice());
        if (applyInvBtn)   applyInvBtn.disabled   = !(currentRoomTypeId && rangeIsValid() && validInventory());
      }

      // Hook inputs that affect validity
      ["range-start","range-end","price","inv-open","inv-minstay","inv-closed"].forEach(id=>{
        const n = el(id);
        if (n) ["input","change","blur"].forEach(ev=> n.addEventListener(ev, refresh));
      });

      // Also refresh after room selection and calendar renders
      const _renderCalendar = window.renderCalendar;
      window.renderCalendar = async function(){
        const r = await _renderCalendar();
        refresh();
        return r;
      };

      // initial
      refresh();
    })();

    // ANCHOR: APPLY_ON_ENTER
    (function wireApplyOnEnter(){
      const priceEl = document.getElementById("price");
      const invOpenEl = document.getElementById("inv-open");
      const invMinStayEl = document.getElementById("inv-minstay");
      const applyPriceBtn = document.getElementById("apply-price");
      const applyInvBtn = document.getElementById("apply-inv");

      function maybeClick(btn){
        if (btn && !btn.disabled) btn.click();
      }

      // Enter in Price -> Apply Price
      if (priceEl){
        priceEl.addEventListener("keydown", (e)=>{
          if (e.key === "Enter"){
            e.preventDefault();
            maybeClick(applyPriceBtn);
          }
        });
      }

      // Enter in Inventory -> Apply Inventory
      [invOpenEl, invMinStayEl].forEach(el=>{
        if (!el) return;
        el.addEventListener("keydown", (e)=>{
          if (e.key === "Enter"){
            e.preventDefault();
            maybeClick(applyInvBtn);
          }
        });
      });
    })();

    // ANCHOR: SCROLL_TO_DATE
  function scrollToDate(isoDate){
    try{
      const card = document.getElementById(`day-${isoDate}`);
      const wrap = document.querySelector('.calendar');
      if (card && wrap){
        card.scrollIntoView({ block: 'nearest', inline: 'start' });
      }
    }catch(_){}
  }

  // ANCHOR: CAL_LOADING_HELPERS
  function setCalLoading(on){
    try{
      const wrap = document.querySelector('.calendar');
      if (!wrap) return;
      wrap.classList.toggle('loading', !!on);
    }catch(_){}
  }

  // ANCHOR: FLASH_DATES_HELPER
  function flashDates(dates){
    try{
      dates.forEach(d=>{
        const el = document.getElementById(`day-${d}`);
        if (!el) return;
        el.classList.remove('flash'); // restart animation if already present
        // force reflow to allow re-adding the class
        void el.offsetWidth;
        el.classList.add('flash');
        setTimeout(()=> el.classList.remove('flash'), 1400);
      });
    }catch(_){}
  }

  // ANCHOR: CAL_WHEEL_HORIZONTAL
  (function enableHorizontalWheel(){
    const wrap = document.querySelector('.calendar');
    if (!wrap) return;

    wrap.addEventListener('wheel', (e) => {
      // If the user holds Shift, let the browser do its default horizontal scroll.
      if (e.shiftKey) return;

      // Convert vertical wheel movement to horizontal scrolling.
      // Only if there actually is horizontal overflow.
      const canScrollX = wrap.scrollWidth > wrap.clientWidth;
      if (!canScrollX) return;

      // If vertical overflow exists and user is actively scrolling vertically inside the calendar,
      // don't hijack it (rare for this layout, but safe).
      const canScrollY = wrap.scrollHeight > wrap.clientHeight;
      if (canScrollY && Math.abs(e.deltaY) < Math.abs(e.deltaX)) return;

      e.preventDefault(); // we’re handling it
      wrap.scrollLeft += (e.deltaY || e.deltaX);
    }, { passive: false });
  })();

  // ANCHOR: RENDER_DEBOUNCE
  let _renderT = null;
  function scheduleRender(delayMs = 220){
    if (_renderT) clearTimeout(_renderT);
    _renderT = setTimeout(async ()=>{
      _renderT = null;
      try { await renderCalendar(); } catch(_){}
    }, delayMs);
  }

  // ANCHOR: BLOCK_WHEEL_ON_NUMBER
  (function blockWheelOnNumberInputs(){
    function stopWheel(e){
      // Only block when the event target is the input itself
      // or inside a .chip to avoid interfering elsewhere.
      const t = e.target;
      if (!(t instanceof HTMLElement)) return;
      const isNum = t.matches('input[type="number"]');
      const inChip = t.closest('.chip');
      const isBulkInv = t.id === 'inv-open' || t.id === 'inv-minstay';
      if (isNum && (inChip || isBulkInv)){
        e.preventDefault();
      }
    }
    // Delegate on the calendar + controls areas
    const cal = document.querySelector('.calendar');
    const ctrls = document.querySelector('.controls');
    if (cal)   cal.addEventListener('wheel', stopWheel, { passive:false });
    if (ctrls) ctrls.addEventListener('wheel', stopWheel, { passive:false });
  })();

  // ANCHOR: CAL_GRID_KB_NAV
  (function wireCalendarKeyboardNav(){
    const cal = document.getElementById('cal-grid');
    if (!cal) return;

    const KIND_ORDER = ['open','price','minstay','closed'];
    const ONE_DAY_MS = 86400000;

    function parseISO(s){ return new Date(s + 'T00:00:00Z'); }
    function iso(d){ return d.toISOString().slice(0,10); }

    function nextDate(isoStr, delta){
      const d = parseISO(isoStr);
      return iso(new Date(d.getTime() + delta*ONE_DAY_MS));
    }

    function focusCell(dateISO, kind){
      const container = document.getElementById('day-' + dateISO);
      if (!container) return false;
      // Ensure target day is visible in the horizontal scroller
      try {
        if (typeof scrollToDate === 'function') scrollToDate(dateISO);
        else container.scrollIntoView({ block: 'nearest', inline: 'nearest' });
      } catch(_) {}
      const sel = (kind === 'price')
        ? container.querySelector('.money input[data-kind="price"]')
        : container.querySelector(`input[data-kind="${kind}"]`);
      if (!sel) return false;
      sel.focus(); sel.select?.();
      return true;
    }


    cal.addEventListener('keydown', (e) => {
      const t = e.target;
      if (!(t instanceof HTMLElement)) return;
      const chipInput = t.closest('.chip')?.querySelector('input,textarea');
      if (!chipInput) return;

      const kind = chipInput.getAttribute('data-kind');     // 'open' | 'price' | 'minstay' | 'closed'
      const dateISO = chipInput.getAttribute('data-date');
      if (!kind || !dateISO) return;

      const k = e.key;
      if (!['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Enter'].includes(k)) return;

      // Always commit current field before moving (ensures 2-decimals / int normalization)
      function commitCurrent(){
        chipInput.dispatchEvent(new Event('blur', { bubbles:false }));
      }

      // Prevent default page scroll / form submit and stop other handlers from double-processing
      e.preventDefault();
      e.stopImmediatePropagation();

      if (k === 'ArrowLeft'){
        commitCurrent();
        const prev = nextDate(dateISO, -1);
        focusCell(prev, kind);
        return;
      }
      if (k === 'ArrowRight'){
        commitCurrent();
        const next = nextDate(dateISO, +1);
        focusCell(next, kind);
        return;
      }
      // Enter = move DOWN within same day; Shift+Enter = move UP
      if (k === 'Enter' && e.shiftKey){
        // Move UP within the day (no toggle on closed)
        if (kind !== 'closed') commitCurrent();
        const idx = KIND_ORDER.indexOf(kind);
        const upKind = KIND_ORDER[Math.max(0, idx - 1)];
        if (upKind !== kind) focusCell(dateISO, upKind);
        return;
      }

      if (k === 'Enter'){
        if (kind === 'closed'){
          // Toggle checkbox and STAY on the same cell (Space also toggles natively)
          if (chipInput.type === 'checkbox') {
            chipInput.checked = !chipInput.checked;
            chipInput.dispatchEvent(new Event('change', { bubbles: false }));
          }
          return;
        }
        // Commit then move DOWN within the same day
        commitCurrent();
        const idx = KIND_ORDER.indexOf(kind);
        const downKind = KIND_ORDER[Math.min(KIND_ORDER.length - 1, idx + 1)];
        if (downKind !== kind) focusCell(dateISO, downKind);
        return;
      }
      if (k === 'ArrowUp'){
        const idx = KIND_ORDER.indexOf(kind);
        const upKind = KIND_ORDER[Math.max(0, idx - 1)];
        if (upKind !== kind) focusCell(dateISO, upKind);
        return;
      }
      if (k === 'ArrowDown'){
        const idx = KIND_ORDER.indexOf(kind);
        const downKind = KIND_ORDER[Math.min(KIND_ORDER.length - 1, idx + 1)];
        if (downKind !== kind) focusCell(dateISO, downKind);
        return;
      }
    }, { capture:true });
  })();

  // Calendar render
  async function renderCalendar(){
    calGrid.innerHTML = "";
    if (!currentRoomTypeId){ setStatus("Pick a room type on the left.",""); return; }
    prepareRangeDefaults();
    if (!validateRangeOrWarn()) return;

    const invUrl = `/extranet/property/rooms/${currentRoomTypeId}/inventory?start=${currentRangeStart}&end=${currentRangeEnd}`;
    const prcUrl = `/extranet/property/rooms/${currentRoomTypeId}/prices?start=${currentRangeStart}&end=${currentRangeEnd}&ratePlanId=${encodeURIComponent(currentRatePlanId)}`;

    if (localStorage.getItem('rooms_debug') === '1'){
      console.debug("Calendar fetch URLs", {
        roomId: currentRoomTypeId, invUrl, prcUrl,
        start: currentRangeStart, end: currentRangeEnd, ratePlanId: currentRatePlanId
      });
    }

    disableWhileBusy(true);
    setStatus("Loading calendar…", "");
    setCalLoading(true);
    const [invRes, prcRes] = await Promise.all([
      fetchWithRetry(invUrl, {}, 2, 800),
      fetchWithRetry(prcUrl, {}, 2, 800)
    ]);
    setCalLoading(false);
    disableWhileBusy(false);

    let invRows = []; let prcRows = [];
    if (invRes && invRes.ok){ try{ invRows = await invRes.json(); } catch(_){} }
    else { try{ const b = invRes ? await invRes.text() : ""; console.warn("Inventory load failed", { url: invUrl, status: invRes?.status, body: b.slice(0,500) }); } catch(_){} }

    if (prcRes && prcRes.ok){ try{ prcRows = await prcRes.json(); } catch(_){} }
    else { try{ const b = prcRes ? await prcRes.text() : ""; console.warn("Prices load failed", { url: prcUrl, status: prcRes?.status, body: b.slice(0,500) }); } catch(_){} }

    if (!(invRes?.ok) || !(prcRes?.ok)){
      setStatus(`Loaded with partial data (${invRes?.status ?? "ERR"}/${prcRes?.status ?? "ERR"})`, "warn");
      toast('Loaded with partial data', 'warn');
    }

    const invByDate = new Map(invRows.map(r => [String(r.date).slice(0,10), r]));
    const prcByDate = new Map(prcRows.map(r => [String(r.date).slice(0,10), r]));

    const ONE_DAY = 86400000;
    const daysBetween = (startISO,endISO) => {
      const s = new Date(startISO+"T00:00:00Z"); const e = new Date(endISO+"T00:00:00Z");
      const arr = []; for (let d = new Date(s); d <= e; d = new Date(d.getTime()+ONE_DAY)) arr.push(iso(d));
      return arr;
    };
    const days = daysBetween(currentRangeStart, currentRangeEnd);

    days.forEach(d => {
      const inv = invByDate.get(d);
      const prc = prcByDate.get(d);
      const invOpen    = inv ? clamp(Number(inv.roomsOpen)||0, 0, 9999) : 0;
      const invMinStay = inv && inv.minStay ? clamp(Number(inv.minStay)||1, 1, 365) : "";
      const isClosed   = !!(inv && inv.isClosed);

      const card = document.createElement("div");
      card.className = "day";
      card.id = `day-${d}`;         
      card.setAttribute('data-date', d);
      /* INSERT — ANCHOR: WEEKEND_FLAG */
      const _dow = new Date(d + "T00:00:00Z").getDay();
      const isWE = (_dow === 0 || _dow === 6);
      card.innerHTML = `
        <div class="date">${isWE ? '<span class="we-badge" aria-label="Weekend">WE</span>' : ''} ${d}</div>

        <div class="chip" title="Rooms Open">
          <span class="tag">Open</span>
          <input type="number" min="0" value="${invOpen}" data-date="${d}" data-kind="open">
        </div>

        <div class="chip" title="Price (USD)">
          <span class="tag">Price</span>
          <div class="money">
            <span class="prefix">$</span>
            <input type="text" value="${prc ? Number(prc.price).toFixed(2) : ""}" data-date="${d}" data-kind="price">
          </div>
        </div>

        <div class="chip" title="Min Stay">
          <span class="tag">MinStay</span>
          <input type="number" min="1" value="${invMinStay}" data-date="${d}" data-kind="minstay">
        </div>

        <div class="chip" title="Closed">
          <span class="tag">Closed</span>
          <input type="checkbox" ${isClosed ? 'checked' : ''} data-date="${d}" data-kind="closed">
        </div>
      `;

      // ANCHOR: DIRTY_BADGE_ON_RENDER
      if (dirty.has(d)) card.classList.add('is-dirty');

      ['open','price','minstay','closed'].forEach(kind => {
        const input = card.querySelector(`input[data-kind="${kind}"]`);
        if (!input) return;
        const eventName = (kind === 'closed') ? 'change' : 'input';

        input.addEventListener(eventName, () => {
          const date = input.getAttribute('data-date');

          if (kind === 'closed'){
            setDirty(date, 'isClosed', !!input.checked);
            updateDirtyUI();
            return;
          }

          let val = input.value;

          if (kind === 'open' || kind === 'minstay'){
            if (val === ''){
              input.classList.remove('error');
              setDirty(date, kind === 'open' ? 'roomsOpen' : 'minStay', undefined);
              updateDirtyUI();
              return;
            }
            const n = Number(val);
            if (!Number.isFinite(n) || n < (kind === 'open' ? 0 : 1)){
              input.classList.add('error');
              updateDirtyUI();
              return;
            }
            input.classList.remove('error');
            setDirty(date, kind === 'open' ? 'roomsOpen' : 'minStay', Math.floor(n));
            updateDirtyUI();
            return;
          }

          if (kind === 'price'){
            if (val === ''){
              input.classList.remove('error');
              setDirty(date, 'price', undefined);
              updateDirtyUI();
              return;
            }
            const ok = /^(\d+)(\.\d{1,2})?$/.test(val) && parseFloat(val) >= 0;
            if (!ok){
              input.classList.add('error');
              updateDirtyUI();
              return;
            }
            input.classList.remove('error');
            setDirty(date, 'price', parseFloat(val).toFixed(2));
            updateDirtyUI();
          }
        });
      });

      const priceEl = card.querySelector(`input[data-kind="price"]`);
      if (priceEl){
        priceEl.addEventListener('blur', () => {
          const v = priceEl.value.trim();
          if (v === ''){ updateDirtyUI(); return; }
          const ok = /^(\d+)(\.\d{1,2})?$/.test(v) && parseFloat(v) >= 0;
          if (ok){
            priceEl.value = parseFloat(v).toFixed(2);
            priceEl.classList.remove('error');
          } else {
            priceEl.classList.add('error');
          }
          updateDirtyUI();
        });
      }

      const openEl = card.querySelector(`input[data-kind="open"]`);
      if (openEl){
        openEl.addEventListener('blur', () => {
          const v = openEl.value.trim();
          if (v === ''){ updateDirtyUI(); return; }
          const n = Number(v);
          if (Number.isFinite(n) && n >= 0){
            openEl.value = String(Math.floor(n));
            openEl.classList.remove('error');
          } else {
            openEl.classList.add('error');
          }
          updateDirtyUI();
        });
      }

      const minEl = card.querySelector(`input[data-kind="minstay"]`);
      if (minEl){
        minEl.addEventListener('blur', () => {
          const v = minEl.value.trim();
          if (v === ''){ updateDirtyUI(); return; }
          const n = Number(v);
          if (Number.isFinite(n) && n >= 1){
            minEl.value = String(Math.floor(n));
            minEl.classList.remove('error');
          } else {
            minEl.classList.add('error');
          }
          updateDirtyUI();
        });
      }

      /* ANCHOR: CARD_FOCUS_TRACK */
      (function wireCardFocusTrack(){
        ['open','price','minstay','closed'].forEach(kind=>{
          const input = card.querySelector(`input[data-kind="${kind}"]`);
          if (!input) return;
          input.addEventListener('focus', ()=>{
            const dateISO = input.getAttribute('data-date');
            if (!dateISO) return;
            window.__lastCellFocus = { dateISO, kind };
          });
        });
      })();

      calGrid.appendChild(card);
    });

    // Scroll to the first day in the current window (range start)
    if (currentRangeStart) scrollToDate(currentRangeStart);

    updateDirtyUI();
    if (!status.className.includes("ok")) setStatus("Calendar ready.","");
  }

  /* ANCHOR: RESTORE_LAST_FOCUS */
  (function refocusAfterRender(){
    const last = window.__lastCellFocus;
    if (!last) return;

    // Ensure the target day is visible before refocusing
    try {
      if (typeof scrollToDate === 'function') scrollToDate(last.dateISO);
    } catch(_) {}

    const sel = (last.kind === 'price')
      ? document.querySelector(`#day-${last.dateISO} .money input[data-kind="price"]`)
      : document.querySelector(`#day-${last.dateISO} input[data-kind="${last.kind}"]`);

    if (sel) { try { sel.focus(); sel.select?.(); } catch(_){} }
  })();

  // expose for MN hardfix nav
  window.renderCalendar = renderCalendar;

  function shiftWeeks(deltaWeeks){
    const rsInput=el("range-start");
    const seed=(rsInput && rsInput.value) ? rsInput.value
      : (typeof currentRangeStart==="string"&&currentRangeStart) ? currentRangeStart
      : todayISO();
    const nextStart=new Date(seed+"T00:00:00Z");
    nextStart.setDate(nextStart.getDate() + (deltaWeeks * 7));
    currentAnchor=nextStart;
    applyMonthWindowToRange({ rerender:true });
    setMonthLabel();
  }
  if (monthPrevBtn) monthPrevBtn.addEventListener("click",()=>shiftWeeks(-visibleWeeks));
  if (monthNextBtn) monthNextBtn.addEventListener("click",()=>shiftWeeks(+visibleWeeks));

  // Bulk inventory
  el("apply-inv").addEventListener("click", async ()=>{
    if (!currentRoomTypeId) return setStatus("Select a room type.","error");
    if (!validateRangeOrWarn()) return;
    const start=el("range-start").value, end=el("range-end").value;
    const roomsOpenN=toNumber(el("inv-open").value);
    const minStayN=el("inv-minstay").value ? toNumber(el("inv-minstay").value) : NaN;
    const isClosed=!!el("inv-closed").checked;
    if (!Number.isFinite(roomsOpenN) || roomsOpenN<0) return setStatus("roomsOpen must be a non-negative number","error");
    if (el("inv-minstay").value && (!Number.isFinite(minStayN) || minStayN<1)) return setStatus("minStay must be ≥ 1","error");

    const ONE_DAY=86400000;
    const dates=[]; { const s=new Date(start+"T00:00:00Z"); const e=new Date(end+"T00:00:00Z");
      for(let d=new Date(s); d<=e; d=new Date(d.getTime()+ONE_DAY)) dates.push(iso(d)); }
    const items=dates.map(d=>{ const o={date:d,isClosed,roomsOpen:Math.floor(roomsOpenN)}; if (Number.isFinite(minStayN)) o.minStay=Math.floor(minStayN); return o; });

    disableWhileBusy(true);
    const res=await authFetch(`/extranet/property/rooms/${currentRoomTypeId}/inventory/bulk`,{ method:"POST", body:JSON.stringify({items}) });
    disableWhileBusy(false);
    if (!res.ok){ setStatus("Inventory apply failed ("+res.status+")","error"); toast('Inventory apply failed', 'error'); return; }
    // Success UI
    setStatus(`Prices applied to ${js.upserted ?? js.count ?? items.length} day(s) — saved automatically; no need to click “Save changes”.`, "ok");
    toast('Prices applied (auto-saved)', 'ok');

    // Immediately fetch back the same window to verify server state
    try {
      const verifyUrl = `/extranet/property/rooms/${currentRoomTypeId}/prices?start=${start}&end=${end}&ratePlanId=${encodeURIComponent(ratePlanId)}`;
      const verifyRes = await authFetch(verifyUrl);
      const verifyRows = verifyRes.ok ? await verifyRes.json() : [];
      console.log("PRC verify GET url:", verifyUrl);
      console.log("PRC verify GET rows:", verifyRows);
    } catch (e) {
      console.warn("PRC verify GET failed:", e);
    }

    // Re-render UI and flash the affected dates
    await renderCalendar();
    flashDates(dates);

  });

    // Bulk prices (validates & auto-formats)
  el("apply-price").addEventListener("click", async ()=>{
    if (!currentRoomTypeId) return setStatus("Select a room type.","error");
    if (!validateRangeOrWarn()) return;

    const priceEl = el("price");
    const raw = (priceEl?.value ?? "").trim();
    const moneyRx = /^(\d+)(\.\d{1,2})?$/;

    if (!raw || !moneyRx.test(raw) || parseFloat(raw) < 0){
      if (priceEl) priceEl.classList.add("error");
      return setStatus("Enter a valid non-negative price","error");
    }

    // Normalize to two decimals for both UI and payload
    const priceFixed = parseFloat(raw).toFixed(2);
    if (priceEl){ priceEl.value = priceFixed; priceEl.classList.remove("error"); }

    // Validate rate plan id from dropdown
    const ddl = document.getElementById('ratePlanSelect');
    const ratePlanId = ddl ? Number(ddl.value) : NaN;
    if (!Number.isFinite(ratePlanId)) {
      setStatus("Please select a valid rate plan.","error");
      return;
    }

    const start=el("range-start").value, end=el("range-end").value;
    const ONE_DAY=86400000;
    const dates=[]; { const s=new Date(start+"T00:00:00Z"); const e=new Date(end+"T00:00:00Z");
      for(let d=new Date(s); d<=e; d=new Date(d.getTime()+ONE_DAY)) dates.push(iso(d)); }

    // Build normalized items (coerce to Number and round to 2dp)
    const items=dates.map(d=>{
      const n = Number(priceFixed);
      return Number.isFinite(n) ? { date:d, price: Math.round(n * 100) / 100, ratePlanId } : null;
    }).filter(Boolean);

    if (!items.length){
      setStatus("No valid prices to apply.","error");
      return;
    }

    const prcUrl = `/extranet/property/rooms/${currentRoomTypeId}/prices/bulk`;
    console.log("PRC url (final):", prcUrl);
    console.log("PRC payload (final):", { items });

    disableWhileBusy(true);
    const res = await authFetch(prcUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ items })
    });
    disableWhileBusy(false);

      // Capture raw body for debugging even if it's not JSON
      let prcResObj;
      let respRaw = "";
      try {
        respRaw = await res.text();
        try { prcResObj = JSON.parse(respRaw); } catch { prcResObj = { raw: respRaw }; }
      } catch(_) {
        prcResObj = { parseError: true };
      }
      console.log("PRC status:", res.status, prcResObj);

      // Handle non-OK early
      if (!res.ok) {
        setStatus("Price apply failed (" + res.status + ")", "error");
        toast('Price apply failed', 'error');
        return;
      }

      // If server returns a different ratePlanId, sync UI to it
      if (prcResObj && Number.isFinite(Number(prcResObj.ratePlanId))) {
        const serverPlanId = Number(prcResObj.ratePlanId);
        if (serverPlanId !== ratePlanId) {
          console.warn("Server wrote to different ratePlanId; syncing UI:", serverPlanId);
          window.currentRatePlanId = serverPlanId;
          const ddl = document.getElementById('ratePlanSelect');
          if (ddl) ddl.value = String(serverPlanId);
          try { updateURLFromState?.(); } catch(_) {}
          try { saveCtx?.(); } catch(_) {}
        }
      }

      // Success UI
      setStatus(`Prices applied to ${prcResObj.upserted ?? prcResObj.count ?? items.length} day(s) — saved automatically; no need to click “Save changes”.`, "ok");
      toast('Prices applied (auto-saved)', 'ok');

      // Immediately verify what GET returns for this window/plan
      try {
        const verifyPlan = Number.isFinite(Number(window.currentRatePlanId)) ? Number(window.currentRatePlanId) : ratePlanId;
        const verifyUrl = `/extranet/property/rooms/${currentRoomTypeId}/prices?start=${start}&end=${end}&ratePlanId=${encodeURIComponent(verifyPlan)}`;
        const verifyRes = await authFetch(verifyUrl);
        const verifyRows = verifyRes.ok ? await verifyRes.json() : [];
        console.log("PRC verify GET url:", verifyUrl);
        console.log("PRC verify GET rows:", verifyRows);
      } catch (e) {
        console.warn("PRC verify GET failed:", e);
      }

      await renderCalendar();
      flashDates(dates);
  });

  // Save (grid edits)
  el("save").addEventListener("click", async ()=>{
    const hasRoomEdits = pendingRoomUpdates.size > 0;
    const hasGridEdits = dirty.size > 0;
    const invalidCount = document.querySelectorAll('.chip input.error').length;
    if (invalidCount > 0){ setStatus(`Fix ${invalidCount} invalid field${invalidCount>1?'s':''} before saving.`,"error"); return; }
    if (!hasRoomEdits && !hasGridEdits){ setStatus("Nothing to save.","warn"); return; }

    setStatus("Saving…"); disableWhileBusy(true);
    try{
      // 1) Apply queued room edits
      if (hasRoomEdits){
        for (const [id, payload] of pendingRoomUpdates.entries()){
          const url = `/extranet/property/rooms/${id}`;
          let r = await authFetch(url, { method:"PATCH", body: JSON.stringify(payload) });

          if (!r.ok && r.status === 400 && Object.prototype.hasOwnProperty.call(payload, 'active')){
            const { active, ...rest } = payload;
            if (Object.keys(rest).length){
              const r2 = await authFetch(url, { method:"PATCH", body: JSON.stringify(rest) });
              if (r2.ok){
                setStatus("Saved. Status change may not be supported yet, skipped.", "warn");
                continue;
              } else {
                r = r2;
              }
            } else {
              setStatus("Status change may not be supported yet, skipped.", "warn");
              continue;
            }
          }

          if (!r.ok && (r.status === 405 || r.status === 404)) {
            r = await authFetch(url, { method:"PUT", body: JSON.stringify({ ...payload, id }) });
          }
          if (!r.ok) throw new Error(`Room ${id} update failed (${r.status})`);
        }
      }

      // 2) Apply calendar edits if any
      const invItems=[], prcItems=[];
      for (const [date,obj] of dirty.entries()){
        const inv={};
        if (typeof obj.isClosed==='boolean') inv.isClosed = obj.isClosed;
        if (typeof obj.roomsOpen==='number') inv.roomsOpen = obj.roomsOpen;
        if (typeof obj.minStay==='number') inv.minStay = obj.minStay;
        if (Object.keys(inv).length) invItems.push({ date, ...inv });

        // Normalize price: must be a finite non-negative number; round to 2dp
        if (typeof obj.price==='string' && obj.price!=='') {
          const n = Number(obj.price);
          if (Number.isFinite(n) && n >= 0) {
            prcItems.push({ date, price: Math.round(n * 100) / 100, ratePlanId: currentRatePlanId });
          }
        }
      }

      const reqs=[];
      if (invItems.length) {
        reqs.push(authFetch(`/extranet/property/rooms/${currentRoomTypeId}/inventory/bulk`,{
          method:"POST",
          body:JSON.stringify({items:invItems})
        }));
      }
      if (prcItems.length) {
        // Debug visibility mirrors Apply Price path
        console.log("PRC url (save):", `/extranet/property/rooms/${currentRoomTypeId}/prices/bulk`);
        console.log("PRC payload (save):", { items: prcItems });
        reqs.push(authFetch(`/extranet/property/rooms/${currentRoomTypeId}/prices/bulk`,{
          method:"POST",
          body:JSON.stringify({items:prcItems})
        }));
      }
      if (reqs.length){
        const resps = await Promise.all(reqs);
        if (resps.some(r=>!r.ok)) throw new Error(`Grid save failed (${resps.map(r=>r.status).join('/')})`);
      }

      pendingRoomUpdates.clear();
      dirty.clear(); updateDirtyUI();
      await loadRooms();
      if (currentRoomTypeId) await renderCalendar();
      setStatus("Saved.","ok");
      toast('All changes saved', 'ok');
    } catch (e) {
      console.error(e);
      setStatus(String(e.message || "Save error"), "error");
      toast('Save failed', 'error');
    } finally {
      disableWhileBusy(false);
    }
  });

  // Discard (clear unsaved)
  el("discard").addEventListener("click", async ()=>{
    if (busy) return;
    pendingRoomUpdates.clear();
    dirty.clear();
    updateDirtyUI();
    setStatus("Changes discarded.","warn");
    await loadRooms();
    if (currentRoomTypeId) await renderCalendar();
  });

  // Global hotkeys: Save (Cmd/Ctrl+S), Discard (Esc)
  window.addEventListener('keydown', (e) => {
    const saveBtn = el('save');
    const discardBtn = el('discard');
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') {
      e.preventDefault();
      if (saveBtn && !saveBtn.disabled && !busy) saveBtn.click();
    }
    if (e.key === 'Escape') {
      if (discardBtn && !discardBtn.disabled && !busy) discardBtn.click();
    }
  });

  // ANCHOR: HOTKEYS_ALT_NAV
  (function wireAltHotkeys(){
    const prevBtn = document.getElementById('month-prev');
    const nextBtn = document.getElementById('month-next');
    const todayBtn = document.getElementById('month-today');
    const priceEl = document.getElementById('price');
    const invOpenEl = document.getElementById('inv-open');

    window.addEventListener('keydown', (e)=>{
      // Ignore when user is typing in a text input except our combos
      const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
      const isTyping = (tag === 'input' || tag === 'textarea');

      if (e.altKey && !e.ctrlKey && !e.metaKey) {
        // Alt + ArrowLeft / ArrowRight — navigate weeks
        if (e.key === 'ArrowLeft') {
          e.preventDefault();
          prevBtn?.click();
          return;
        }
        if (e.key === 'ArrowRight') {
          e.preventDefault();
          nextBtn?.click();
          return;
        }
        // Alt + T — Today
        if (e.key.toLowerCase() === 't') {
          e.preventDefault();
          todayBtn?.click();
          return;
        }
        // Alt + P — focus Price
        if (e.key.toLowerCase() === 'p') {
          e.preventDefault();
          priceEl?.focus();
          priceEl?.select?.();
          return;
        }
        // Alt + I — focus Inventory roomsOpen
        if (e.key.toLowerCase() === 'i') {
          e.preventDefault();
          invOpenEl?.focus();
          invOpenEl?.select?.();
          return;
        }
      }

      // Prevent our nav combos from interfering when typing freely in inputs
      if (isTyping) return;
    });
  })();

  // ANCHOR: BACK_GUARD_UNSAVED
  (function guardBackWhenDirty(){
    const backBtn = document.getElementById('back');
    if (!backBtn) return;

    backBtn.addEventListener('click', (e)=>{
      const hasRoomEdits = pendingRoomUpdates.size > 0;
      const hasGridEdits = dirty.size > 0;
      const invalidCount = document.querySelectorAll('.chip input.error').length;

      if (hasRoomEdits || hasGridEdits || invalidCount > 0){
        e.preventDefault();
        let msg;
        if (invalidCount > 0) {
          const plural = invalidCount > 1 ? 's' : '';
          msg = 'You have ' + invalidCount + ' invalid field' + plural + '. Leave without fixing/saving?';
        } else {
          msg = 'You have unsaved changes. Leave without saving?';
        }
        if (confirm(msg)){
          // proceed to menu
          location.href = '/partners_app.html';
        }
        // else stay on page
      }
      // if nothing dirty, normal navigation continues via button's onclick
    }, { capture:true });
  })();

  // ANCHOR: COPY_LINK_BTN
  el('copy-link')?.addEventListener('click', async () => {
    const url = location.href;
    try {
      await navigator.clipboard.writeText(url);
      toast('Link copied to clipboard', 'ok');
    } catch(_) {
      // Fallback for older browsers
      const ta = document.createElement('textarea');
      ta.value = url; document.body.appendChild(ta);
      ta.select(); document.execCommand('copy'); ta.remove();
      toast('Link copied to clipboard', 'ok');
    }
  });

  // NEW: wire Rate plan selector
  function wireRatePlanSelector(ctx) {
    const ddl = document.getElementById('ratePlanSelect');
    if (!ddl) return;
    ddl.value = String(ctx?.ratePlanId ?? currentRatePlanId ?? 1);
    ddl.addEventListener('change', () => {
      currentRatePlanId = Number(ddl.value) || 1;
      saveCtx();
      updateURLFromState();
      if (currentRoomTypeId) scheduleRender(180);
    });
  }

  (async function init(){
  const ctx = loadCtx() || {};
    // ANCHOR: DEEPLINK_QUERY_IN
  try {
    const qs = new URLSearchParams(location.search);
    const qRoom  = qs.get('room');
    const qStart = qs.get('start');
    const qEnd   = qs.get('end');
    const qPlan  = qs.get('plan');

    if (qRoom) {
      // numeric or string ids supported
      const n = Number(qRoom);
      ctx.roomId = Number.isFinite(n) ? n : qRoom;
    }
    if (qStart && qEnd) {
    // strict yyyy-mm-dd (zero-padded) validation
    const isoRx = /^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])$/;
    if (isoRx.test(qStart) && isoRx.test(qEnd)) {
      ctx.start = qStart;
      ctx.end   = qEnd;
    }
  }
    if (qPlan) {
      const pn = Number(qPlan);
      ctx.ratePlanId = Number.isFinite(pn) ? pn : 1;
    }
  } catch(_){}
    // clamp ctx/start/end (from URL or localStorage) to today-or-later
{
  const today = todayISO();

    if (ctx.start && ctx.end){
      // sanitize incoming dates
      let s = String(ctx.start);
      let e = String(ctx.end);

      // start must be today or later
      if (s < today) s = today;
      // end must be >= start
      if (e < s) e = s;

      currentRangeStart = s;
      currentRangeEnd   = e;

      const rs = el("range-start"), re = el("range-end");
      if (rs && re){ rs.value = s; re.value = e; }

      currentAnchor = new Date(s + "T00:00:00Z");
      setMonthLabel();
      // also normalize the URL so refresh keeps good dates
      updateURLFromState?.();
    } else {
      // fall back to a clean, clamped window starting today
      const startISO = today; // force today
      currentAnchor = new Date(startISO + "T00:00:00Z");
      setMonthLabel();
      applyMonthWindowToRange({ rerender:false }); // this will also clamp end >= start
    }
  }

    if (ctx.roomId) currentRoomTypeId = ctx.roomId;
    setRightActive(!!currentRoomTypeId);

    // ANCHOR: RATE_PLAN_INIT
    currentRatePlanId = Number(ctx.ratePlanId ?? 1) || 1;
    const plans = await fetchRatePlansSafe();
    populateRatePlanDropdown(plans);

    // If fetch fell back or had issues, expose the reason
    if (lastRatePlanLoadNote) {
      const sel = document.getElementById('ratePlanSelect');
      if (sel) sel.title = lastRatePlanLoadNote;
      setStatus(lastRatePlanLoadNote, lastRatePlanLoadNote.includes('error') ? 'error' : 'warn');
    }

    wireRatePlanSelector({ ratePlanId: currentRatePlanId });

    await loadRooms();
    if (currentRoomTypeId){
      await renderCalendar();
    } else {
      const first = document.querySelector(".room");
      if (first){ first.click(); void renderCalendar(); }
    }
    try { updateURLFromState(); } catch(_){}
  })();
})(); /* end main IIFE */
</script>

<!-- FP: MN-HARDFIX-LOCK — single source of truth for month-nav; exact 3-week stepping -->
<script>
(() => {
  const iso = (d)=>d.toISOString().slice(0,10);
  const addDaysISO=(isoStr,n)=>{ const d=new Date(isoStr+"T00:00:00Z"); d.setDate(d.getDate()+n); return iso(d); };
  const setLabel=(sISO)=>{ const lbl=document.getElementById('month-label'); if(lbl) lbl.textContent=new Date(sISO+'T00:00:00Z').toLocaleString(undefined,{month:'short',year:'numeric'}); };
  const setWindow=(sISO,doRender=true)=>{
  const eISO=addDaysISO(sISO,21-1), rs=document.getElementById('range-start'), re=document.getElementById('range-end');
    if (rs&&re){ rs.value=sISO; re.value=eISO; }
    window.currentRangeStart=sISO; window.currentRangeEnd=eISO; window.currentAnchor=new Date(sISO+'T00:00:00Z');
    setLabel(sISO);
    if (typeof window.updateURLFromState==='function') window.updateURLFromState();
    if (doRender && typeof window.renderCalendar==='function') window.renderCalendar();
  };
  const prev=document.getElementById('month-prev'), next=document.getElementById('month-next'), todayBtn=document.getElementById('month-today'); if (!prev||!next){ console.warn('[MN-HARDFIX-LOCK] nav buttons missing'); return; }
  prev.onclick=null; next.onclick=null; if (todayBtn) todayBtn.onclick=null;
  const install=(el,dir)=>{ el.addEventListener('click',(ev)=>{ ev.stopImmediatePropagation(); ev.preventDefault();
    const rs=document.getElementById('range-start')?.value || window.currentRangeStart;
    const re=document.getElementById('range-end')?.value   || window.currentRangeEnd || rs;
    const nextStart=(dir==='next') ? addDaysISO(re,+1) : addDaysISO(rs,-21);
    setWindow(nextStart,true);
  },{capture:true}); };
  install(prev,'prev'); install(next,'next');
  if (todayBtn){ todayBtn.addEventListener('click',(ev)=>{ ev.stopImmediatePropagation(); ev.preventDefault(); const t=iso(new Date()); setWindow(t,true); },{capture:true}); }
  const initial=document.getElementById('range-start')?.value || window.currentRangeStart || iso(new Date());
  setWindow(initial,false);
})();
</script>
</body>
</html>

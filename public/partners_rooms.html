<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Partners · Rooms & Availability</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'><rect width='16' height='16' fill='%234f8cff'/></svg>" type="image/svg+xml">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/css/extranet.css">
  <!-- FP: MN8-no-overlap -->
  <!-- FP: MN9-dist-source -->

  <style>
    :root{
      --bg:#0b0d12; --panel:#121621; --panel-2:#161b28; --text:#e7ecf3; --muted:#98a3b3;
      --brand:#4f8cff; --accent:#ffb86b; --ok:#2ecc71; --warn:#f39c12; --err:#e74c3c;
      --border:#222a3a; --chip:#1e2536; --header-h:56px;
    }
    *{ box-sizing:border-box; }
    body{ margin:0; background:var(--bg); color:var(--text);
      font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; overflow:hidden; }
    header{ display:flex; gap:12px; align-items:center; padding:14px 18px; height:var(--header-h);
      border-bottom:1px solid var(--border); background:var(--panel); position:sticky; top:0; z-index:5; }
    header h1{ font-size:16px; margin:0; letter-spacing:.2px; white-space:nowrap; }
    .spacer{ flex:1; }
    .header-actions{ display:flex; gap:8px; align-items:center; }
    .header-actions .note{ white-space:nowrap; }
    /* Rate plan chip group */
    .rateplan-checks .chip{
      display:inline-flex; align-items:center; gap:6px;
      padding:6px 10px; border:1px solid var(--border);
      border-radius:999px; cursor:pointer; user-select:none;
      background:var(--chip);
    }
    .rateplan-checks input[type="checkbox"]{ width:16px; height:16px; accent-color: var(--accent); }

    /* NEW: selected + focus styles for rate-plan chips */
    .rateplan-checks input[type="checkbox"]:checked + span { font-weight:600; }
    .rateplan-checks input[type="checkbox"]:focus-visible { outline:2px solid var(--brand); outline-offset:2px; }

    .wrap{ display:grid; grid-template-columns:300px 1fr; height:calc(100vh - var(--header-h)); overflow:hidden; }
    .left{ border-right:1px solid var(--border); background:var(--panel); display:flex; flex-direction:column; min-width:0; }
    .right{ background:var(--panel-2); display:flex; flex-direction:column; min-width:0; }
    
    .toolbar{ display:flex; gap:8px; padding:10px; border-bottom:1px solid var(--border); background:var(--panel); }
    .toolbar input,.toolbar select{ background:var(--chip); border:1px solid var(--border); color:var(--text); padding:8px 10px; border-radius:8px; }
    /* ANCHOR: LOCAL_CSS — scope button/input rules so .btn/.input from extranet.css win */
    .toolbar button:not(.btn){ background:var(--brand); border:0; color:#fff; padding:8px 12px; border-radius:8px; cursor:pointer; }
    .toolbar button.secondary:not(.btn){ background:transparent; border:1px solid var(--border); color:var(--text); }

    .list{ flex:1; overflow:auto; padding:8px; }
    .room{ padding:10px; border:1px solid var(--border); border-radius:10px; background:var(--panel-2);
      margin-bottom:8px; display:flex; justify-content:space-between; align-items:center; cursor:pointer; }
    .room.active{ outline:2px solid var(--brand); } /* changed from var(--accent) to var(--brand) */
    .room .name{ font-weight:600; }
    .room .meta{ color:var(--muted); font-size:12px; }
    .room .actions{ display:flex; gap:6px; }
    .room .actions button{ padding:6px 8px; font-size:12px; border-radius:8px; }
    #add-room{ padding:8px 10px; font-weight:600; }

    .right .controls{ display:flex; flex-wrap:wrap; gap:8px; padding:10px;
      border-bottom:1px solid var(--border); background:var(--panel); align-items:center; }
    .controls input:not(.input){ background:var(--chip); border:1px solid var(--border); color:var(--text); padding:8px 10px; border-radius:8px; }
    .controls .group{ display:flex; gap:6px; align-items:center; }
    .controls .group label{ color:var(--muted); font-size:12px; }
    .controls .flag{ display:flex; gap:6px; align-items:center; color:var(--muted); font-size:12px; }

    .calendar{ flex:0 0 auto; overflow:auto; padding:12px; }
    
    /* Room photos strip between calendar and rate plans */
    .room-photos-panel{
      padding:8px 12px;
      border-top:1px solid var(--border);
      border-bottom:1px solid var(--border);
      background:var(--panel-2);
      min-height:64px;
      display:flex;
      align-items:flex-start; /* was center */
      justify-content:space-between;
      gap:12px;
    }

    .room-photos-title{
      font-size:12px;
      color:var(--muted);
      margin:0 0 6px 0;
    }

    .room-photos-panel.empty{
      opacity:.7;
      font-size:12px;
      color:var(--muted);
      justify-content:flex-start;
    }
    .room-photos-list{
      display:flex;
      gap:8px;
      overflow-x:auto;
      padding-bottom:4px;
      flex:1 1 auto;
    }
    .room-photo-thumb{
      width:72px;
      height:56px;
      border-radius:6px;
      overflow:hidden;
      border:1px solid var(--border);
      background:#0f131d;
      flex:0 0 auto;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:11px;
      color:var(--muted);
    }
    .room-photo-thumb img{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
    }
    .room-photos-actions{
      display:flex;
      flex-direction:column;
      gap:4px;
      align-items:flex-end;
      min-width:140px;
    }
    .room-photos-actions .btn-link{
      background:none;
      border:none;
      padding:0;
      font-size:12px;
      color:var(--muted);
      text-decoration:underline;
      cursor:pointer;
    }

    .cal-grid{ display:grid; grid-auto-flow:column; grid-auto-columns:140px; gap:10px; }
    .day{ background:var(--panel); border:1px solid var(--border); border-radius:10px; padding:8px; min-height:120px; display:flex; flex-direction:column; gap:6px; }
    .day .date{ font-weight:600; font-size:12px; color:var(--muted); }
    /* ANCHOR: DAY_FOCUS_CSS */
    .day:focus-within{
      box-shadow: 0 0 0 2px var(--brand);
    }

    /* ANCHOR: WEEKEND_BADGE_CSS */
    .day .date .we-badge{
      display:inline-block;
      background: var(--accent);
      color: #000;            /* black text */
      font-weight:700;
      font-size:10px;
      line-height:14px;
      padding:0 6px;
      border-radius:6px;
      margin-right:6px;
      vertical-align:baseline;
    }

    /* ANCHOR: DIRTY_BADGE_CSS */
    .day.is-dirty .date::after{
      content:"";
      display:inline-block;
      width:6px; height:6px;
      margin-left:6px;
      border-radius:50%;
      background: var(--accent); /* subtle orange */
      vertical-align:middle;
    }

    /* Make horizontal scroll feel intentional in the calendar area */
    .calendar{ overscroll-behavior: contain; }

    /* ANCHOR: CAL_LOADING_CSS */
    @keyframes spin { to { transform: rotate(360deg); } }

    .calendar.loading {
      position: relative;
    }

    .calendar.loading::after {
      content:"";
      position:absolute;
      inset:0;
      background:rgba(0,0,0,.18);
      border-radius:10px;
    }

    .calendar.loading::before {
      content:"";
      position:absolute;
      top:50%; left:50%;
      width:28px; height:28px;
      margin:-14px 0 0 -14px;
      border:3px solid rgba(255,255,255,.25);
      border-top-color: var(--brand);
      border-radius:50%;
      animation: spin .8s linear infinite;
      z-index:1;
    }

    /* ANCHOR: DAY_FLASH */
    @keyframes dayFlash {
      0%   { box-shadow: 0 0 0 0 rgba(79,140,255,.0); }
      30%  { box-shadow: 0 0 0 4px rgba(79,140,255,.25); }
      100% { box-shadow: 0 0 0 0 rgba(79,140,255,.0); }
    }
    .day.flash {
      animation: dayFlash 1.2s ease-out 1;
    }

    .chip{ background:var(--chip); border:1px solid var(--border); padding:6px 8px; border-radius:10px; font-size:12px;
      display:grid; grid-template-columns: 1fr minmax(64px, 90px); align-items:center; gap:8px; min-width:0; }
    .chip .tag{ color:var(--muted); font-size:11px; }
    .chip input{ width:100%; text-align:right; background:transparent; border:0; color:var(--text);
      padding:4px 0; outline:none; font-variant-numeric:tabular-nums; overflow:hidden; text-overflow:clip; white-space:nowrap; min-width:0; }
    .chip input[data-kind="open"]{    padding-right: 0.25ch; }
    .chip input[data-kind="price"]{   padding-right: 0; }
    .chip input[data-kind="minstay"]{ padding-right: 0.25ch; }
    /* ANCHOR: INV_CELL_WIDTH_5CH */
    .chip input[data-kind="open"],
    .chip input[data-kind="minstay"]{
      width: 10.5ch;          /* ~5 digits visible with small breathing room */
      padding-left: 0.25ch;  /* keep symmetric tiny padding */
    }

    /* ANCHOR: DAY_CELL_VALUE_OFFSETS — center-ish numeric values inside day tiles */
    #cal-grid .chip .money{ 
      justify-content: center;          /* center the $ + input row only inside calendar tiles */
    }

    #cal-grid .chip input[data-kind="open"]{
      text-align: center;
    }

    #cal-grid .chip .money input[data-kind="price"]{
      text-align: center;
      width: 8ch;                        /* keep a stable field width for centering */
    }

    #cal-grid .chip input[data-kind="minstay"]{
      text-align: center;
      transform: translateX(-2ch); 
    }

    /* bulk controls (top row) */
    #inv-open,
    #inv-minstay{
      width: 5ch;            /* same visual cap for bulk fields */
    }
    .chip input.error{ outline:1px solid var(--err); }

    /* Bulk Price input error state */
    #price.error{ outline:1px solid var(--err); }

    /* Bulk Inventory input error state */
    #inv-open.error,
    #inv-minstay.error{ outline:1px solid var(--err); }

    .chip .money{ display:flex; justify-content:flex-end; align-items:center; gap:6px; }
    .chip .money .prefix{ color:var(--muted); font-weight:600; user-select:none; }
    .chip .money input{ flex:1 1 auto; width:auto; min-width:0; }

    input[type=number]{ appearance:textfield; -moz-appearance:textfield; }
    input[type=number]::-webkit-outer-spin-button,
    input[type=number]::-webkit-inner-spin-button{ -webkit-appearance:none; margin:0; }

    button:not(.btn){ background:var(--brand); color:#fff; border:0; border-radius:8px; padding:8px 12px; cursor:pointer; }
    button.secondary:not(.btn){ background:transparent; border:1px solid var(--border); color:var(--text); }
    .btn-accent{ background:var(--accent); color:#0b0d12; }
    .btn-accent:hover{ filter:brightness(1.05); }

    .note{ color:var(--muted); font-size:12px; padding:0 10px; }
    .error{ color:var(--err); }
    .ok{ color:var(--ok); }
    .warn{ color:var(--warn); }
    code.k{ background:var(--chip); padding:2px 6px; border-radius:6px; }
    .disabled{ opacity:.6; pointer-events:none; }

    /* ANCHOR: TOAST_CSS */
    .toast-wrap{ position:fixed; right:16px; bottom:16px; display:flex; flex-direction:column; gap:8px; z-index:9999; }
    .toast{ background:var(--panel-2); border:1px solid var(--border); color:var(--text); padding:10px 12px; border-radius:10px; box-shadow:0 8px 20px rgba(0,0,0,.35); opacity:0; transform:translateY(8px); transition:opacity .18s ease, transform .18s ease; font-size:13px; }
    .toast.in{ opacity:1; transform:translateY(0); }
    .toast.ok{ border-color:rgba(46,204,113,.45); }
    .toast.warn{ border-color:rgba(243,156,18,.6); }
    .toast.error{ border-color:rgba(231,76,60,.6); }

    /* Let shared .btn control background; ensure white text */
    #save{ color:#fff; }
    #save:disabled{ opacity:.6; cursor:not-allowed; }

    #apply-price:disabled,
    #apply-inv:disabled{ opacity:.6; cursor:not-allowed; }

    .month-nav{ display:flex; align-items:center; gap:8px; padding:10px; border-bottom:1px solid var(--border); background:var(--panel); }
    .month-nav .nav-btn{ border:1px solid var(--border); background:var(--chip); padding:.25rem .5rem; border-radius:.5rem; line-height:1.2; cursor:pointer; color:var(--text); }
    .month-nav .nav-btn:hover{ filter:brightness(1.05); }
    .month-nav .month-label{ font-weight:600; letter-spacing:.2px; min-width:8rem; text-align:center; user-select:none; cursor:default; color:var(--text); }
    .month-select{ display:none; }

    /* Modal (Edit Room) */
    .modal{
      position: fixed;
      inset: 0;
      display: none;
      place-items: center;
      background: rgba(0,0,0,.45);
      z-index: 50;
    }
    .modal.open{
      display: grid;
    }
    .dialog{
      width: min(1200px, calc(100vw - 48px));
      max-height: calc(100vh - 48px);
      display: flex;
      flex-direction: column;
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 12px 26px rgba(0,0,0,.45);
    }
    .dialog header{
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 14px;
      border-bottom: 1px solid var(--border);
      background: var(--panel);
    }
    .dialog header h3{
      margin: 0;
      font-size: 15px;
    }
    .dialog .body{
      padding: 14px;
      display: grid;
      gap: 12px;
      overflow-y: auto;    /* vertical scroll when needed */
      overflow-x: hidden;  /* no horizontal scroll */
    }
    .dialog .row{
      display: grid;
      grid-template-columns: 140px 1fr;
      gap: 10px;
      align-items: center;
    }
    .dialog .row.ri-section{
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px 16px 16px;
      margin-top: 4px;
      background: var(--panel-2);
    }
    .dialog input:not(.input){
      background: var(--chip);
      border: 1px solid var(--chip);
      color: var(--text);
      padding: 9px 10px;
      border-radius: 8px;
      width: 100%;
    }
    .dialog footer{
      display: flex;
      gap: 8px;
      justify-content: flex-end;
      padding: 10px 14px;
      border-top: 1px solid var(--border);
      background: var(--panel);
    }
    .muted{
      color: var(--muted);
      font-size: 12px;
    }
    .warn-msg{
      color: var(--warn);
      font-size: 12px;
    }

    /* ANCHOR: EDIT_ROOM_CLOSE_BTN */
    .edit-room-header{
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .dialog-close{
      cursor: pointer;
      padding: 4px 10px;
      border-radius: 999px;   /* pill / circle feel */
      font-size: 13px;
      line-height: 1;
    }

    .dialog-close:hover{
      filter: brightness(1.05);
    }

    /* RATE_PLAN_FILTER (moved under Price group) */
    .rate-plan-selector{ display:grid; grid-template-columns: 1fr; gap:4px; align-self:flex-start; min-width:220px; }
    .rate-plan-selector label{ color:var(--muted); font-size:12px; line-height:1; margin-left:2px; }
    #ratePlanSelect{ min-width:200px; }
    /* ANCHOR: KILL_OVERLAY_CSS */
    #plans-panel[style*="position:fixed"]{ display:none !important; } /* hide modal-style duplicate */

  /* Header actions: allow wrapping and reduce button height */
  .header-actions{ flex-wrap:wrap; }
  .header-actions .btn{ height:32px; padding:6px 10px; line-height:18px; }

  /* Price row: Price | Apply | Rate plan | Copy — always below Range/Inventory */
  .controls .group.price-group{
    /* force its own line below Range/Inventory */
    flex: 1 0 100%;
    width: 100%;
    
    display:grid;
    grid-template-columns: auto auto auto 1fr;
    grid-template-areas: "price apply plan copy";
    column-gap:12px;
    row-gap:10px;
    align-items:end;
  }
    /* Inventory row: its own line below Range, above Price */
    .controls .group.inventory-group{
      flex: 1 0 100%;
      width: 100%;
    }
    /* ANCHOR: INV_BULK_WIDTH_5CH */
    #inv-open,
    #inv-minstay{
      box-sizing: border-box;      /* explicit; global * is already border-box */
      padding-left: 4px !important;
      padding-right: 4px !important;  /* override theme padding if needed */
      width: calc(10ch + 8px);      /* ≈ 5ch content + 4px L/R padding */
    }

  /* Price block (label + input stacked), 8-char visual width */
  .price-field{ grid-area:price; display:grid; grid-template-rows:auto auto; gap:6px; }
  #price{ width:12ch; }

  /* Rate plan block (label + select stacked) */
  .rate-plan-selector{ grid-area:plan; display:grid; grid-template-rows:auto auto; gap:6px; align-self:end; min-width:220px; }
  .rate-plan-selector label{ color:var(--muted); font-size:12px; line-height:1; margin-left:2px; }
  #ratePlanSelect{ min-width:220px; }

  /* Actions placement */
  #apply-price{ grid-area:apply; justify-self:start; align-self:end; }
  #copy-link{ grid-area:copy;  justify-self:start; align-self:end; }

  /* ANCHOR: ROOM_INFO_CSS */
  #edit-room-summary,
  #edit-room-details,
  #edit-room-inclusions {
    width: 100%;
    resize: vertical;
  }
  #edit-room-details,
  #edit-room-inclusions {
    min-height: 60px;
  }

  /* ANCHOR: ROOM_SIZE_ROW_FIX */
  .dialog .row label.muted{
    width: 100%;
    margin-bottom: 4px;
    display: block;
  }

  /* Make the two room-size boxes align evenly */
  #edit-room-size-sqm,
  #edit-room-size-sqft{
    text-align: center;
  }

  /* Extra vertical spacing between sections */
  .dialog .row{
    margin-bottom: 14px;
  }

  /* ANCHOR: ROOM_DETAILS_AND_SIZE_CLEANUP */

  /* Room size: fields side by side */
  .room-size-row{
    display: flex;
    gap: 16px;
    align-items: flex-end;
    flex-wrap: wrap;
  }

  .room-size-field{
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .room-size-field span{
    font-size: 12px;
    color: var(--muted);
  }

  .room-size-field input{
    width: 12ch;
    text-align: right;
    padding-right: 6px;
  }

  /* Room details / inclusions: 5 fixed pairs (text + checkbox) per row */
  .ri-details-grid,
  .ri-inclusions-grid{
    display:grid;
    /* 5 pairs: [text][box] repeated; text wide, box narrow */
    grid-template-columns: repeat(5, minmax(0, 1.6fr) minmax(0, 0.2fr));
    column-gap:24px;
    row-gap:10px;
    padding-top:6px;
  }

  .ri-details-grid label,
  .ri-inclusions-grid label{
    display:contents;
    font-size:13px;
    color:var(--text);
  }

  .ri-details-grid label span,
  .ri-inclusions-grid label span{
    align-self:center;
    white-space:normal;
  }

  .ri-details-grid input[type="checkbox"],
  .ri-inclusions-grid input[type="checkbox"]{
    justify-self:flex-start;
    align-self:center;
    margin:0;
    transform:scale(1.1);
  }

  </style>

  <!-- ANCHOR: ADDONS_MODAL_TWEAKS -->
  <style>
    /* Wider modal */
    #addonsModalBackdrop .addons-modal-dialog {
      max-width: 900px;
      width: min(900px, 95vw);
    }

    /* Slightly larger, more legible text */
    #addonsModalBackdrop .addons-modal-body {
      font-size: 14px;
    }

    /* Align column headers with row cells */
    #addonsModalBackdrop .addons-modal-grid-header,
    #addonsModalBackdrop .addons-modal-row {
      display: grid;
      grid-template-columns: 3fr 1.2fr 1.2fr 1.2fr 1.3fr; /* Activity | UoM | Price | Qty | Total */
      column-gap: 16px;
      align-items: center;
    }

    /* Hide "add a note" column / textareas */
    #addonsModalBackdrop .addons-modal-col-notes,
    #addonsModalBackdrop .addons-modal-comment-wrap {
      display: none !important;
    }

    /* Footer: put "Add-ons total" directly above the buttons, right aligned */
    #addonsModalBackdrop .addons-modal-footer {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 8px;
    }

    #addonsModalBackdrop .addons-modal-footer-summary {
      text-align: right;
      font-size: 14px;
    }

    #addonsModalBackdrop .addons-modal-total-label {
      font-weight: 500;
      margin-bottom: 2px;
    }

    #addonsModalBackdrop .addons-modal-total-amount {
      font-weight: 600;
    }

    /* Buttons: same height, pill shape */
    #addonsModalBackdrop .addons-modal-footer-actions {
      display: flex;
      gap: 12px;
    }

    #addonsModalBackdrop .addons-modal-footer-actions button {
      min-height: 40px;
      padding: 0 22px;
      border-radius: 9999px;
      font-size: 14px;
    }

    /* Gradient primary button */
    #addonsModalBackdrop #applyAddonsButton {
      background: linear-gradient(135deg, #ff6a3d, #ff914d);
      border: none;
      color: #ffffff;
    }

    #addonsModalBackdrop #applyAddonsButton:hover {
      filter: brightness(1.05);
    }

    /* Cancel button: same height, neutral style */
    #addonsModalBackdrop .addons-modal-footer-actions button[data-close-addons-modal] {
      background: #ffffff;
      border: 1px solid #e5e7eb;
      color: #374151;
    }
  </style>

</head>
<body>
  <header>
    <h1>Rooms & Availability</h1>
    <div class="spacer"></div>
    <div class="header-actions"><!-- ANCHOR: HEADER_ACTIONS -->
      <!-- RATE_PLAN_FILTER END -->
      <span id="status" class="note">Ready.</span>
      <span id="dirty-count" class="note">No changes</span>
      <button id="save" class="btn" disabled>Save changes</button>
      <button id="discard" class="secondary btn btn-secondary-outline" disabled>Discard changes</button>
      <button id="back" class="secondary btn btn-secondary-outline" onclick="location.href='/partners_app.html'">Back to menu</button>
    </div>
  </header>

  <div class="wrap">
    <aside class="left">
      <div class="toolbar"><!-- ANCHOR: TOOLBAR_ADD_ROOM -->
        <button id="add-room" class="secondary btn btn-secondary-outline">+ Add room type</button>
      </div>
      <div class="list" id="rooms-list"></div>
    </aside>

    <section class="right">
      <div id="month-nav" class="month-nav" role="group" aria-label="Month navigator">
        <button id="month-prev" class="nav-btn" type="button" aria-label="Previous month">◀</button>
        <span id="month-label" class="month-label" title="Month">Sep 2025</span>
        <select id="month-select" class="month-select" aria-label="Select month"></select>
        <button id="month-today" class="nav-btn" type="button" aria-label="Jump to today">Today</button>
        <button id="month-next" class="nav-btn" type="button" aria-label="Next month">▶</button>
      </div>

      <div class="controls">
        <div class="group">
          <label>Range</label>
          <input type="date" id="range-start" class="input" />
          <input type="date" id="range-end" class="input" />
          <button type="button" id="range-7"  class="secondary btn btn-secondary-outline">7d</button>
          <button type="button" id="range-14" class="secondary btn btn-secondary-outline">14d</button>
          <button type="button" id="range-21" class="secondary btn btn-secondary-outline">21d</button>
        </div>
        <div class="group inventory-group">
          <label>Inventory</label>
          <input type="number" id="inv-open" class="input" min="0" placeholder="roomsOpen" />
          <input type="number" id="inv-minstay" class="input" min="1" placeholder="minStay" />
          <span class="flag"><input type="checkbox" id="inv-closed" /> Closed</span>
          <button id="apply-inv" class="secondary btn btn-secondary-outline" title="Applies immediately (auto-saves)">Apply Inventory</button>
        </div>
        <div class="group price-group">
          <div class="price-field">
            <label>Price</label>
            <input id="price" class="input" placeholder="149.00" inputmode="decimal" maxlength="8" />
          </div>

          <button id="apply-price" class="secondary btn btn-secondary-outline" title="Applies immediately (auto-saves)">Apply Price</button>
          <button id="copy-link" class="secondary btn btn-secondary-outline" type="button" title="Copy the current link with room, date range, and plan">Copy link</button>
        </div>
          </div> <!-- CLOSES .controls -->
          <!-- RATE_PLAN_FILTER ROW (chips above day tiles) -->
          <div id="rateplan-checks-row" class="rateplan-checks-row"
              style="display:flex; align-items:center; gap:10px; padding:10px 12px; border-bottom:1px solid var(--border); background:var(--panel);">
            <span class="note" style="margin:0;">Rate plans</span>
            <div id="rateplan-checks" class="rateplan-checks" style="display:flex; flex-wrap:wrap; gap:8px; align-items:center;"></div>
            <div style="flex:1"></div>
          </div>

          <div class="calendar">
            <div id="cal-grid" class="cal-grid"></div>
          </div>

          <!-- Room photos strip (per room type) -->
          <div id="room-photos-panel" class="room-photos-panel empty" aria-live="polite">
            <div style="flex:1 1 auto; min-width:0;">
              <div class="room-photos-title">Manage room photos</div>
              <div class="room-photos-list" id="room-photos-list">
                <span class="note">Pick a room type to add photos.</span>
              </div>
            </div>
            <div class="room-photos-actions">
              <button type="button" class="btn primary" id="manage-room-photos-btn">
                Choose/Upload photos
              </button>
              <span class="note" style="font-size:11px;">Up to 3 photos show in the booking flow.</span>
            </div>
          </div>

          <!-- ANCHOR: PLANS_PANEL_HTML -->
          <div id="plans-panel" aria-live="polite" aria-label="Rate plan rules" class="plans-panel" style="margin:12px;margin-top:12px;margin-bottom:12px;background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:12px;">
            <h3 style="margin:0 0 8px 0;font-size:14px;letter-spacing:.2px;">Rate Plan Rules (Derived from Standard)</h3>

            <div id="plans-list" class="plans-list" style="display:grid;gap:8px;">
              <!-- Standard (read-only) -->
              <div class="plan-row" style="display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center;padding:8px 10px;border-radius:8px;background:var(--panel-2);border:1px solid var(--border);">
                <div>
                  <div class="plan-name" style="font-weight:600;">Standard</div>
                  <div class="plan-meta" style="color:var(--muted);font-size:12px;">Base plan — other plans derive from this.</div>
                </div>
                <div class="plan-badge" style="font-size:12px;padding:4px 8px;border-radius:999px;border:1px solid var(--border);background:var(--chip);">read-only</div>
              </div>

              <!-- Non-Refundable (editable) -->
              <div class="plan-row" data-plan-code="NRF" style="display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center;padding:8px 10px;border-radius:8px;background:var(--panel-2);border:1px solid var(--border);">
                <div>
                  <div class="plan-name" style="font-weight:600;">Non-Refundable</div>
                  <div class="plan-meta" style="color:var(--muted);font-size:12px;">Rule applies to Standard price</div>
                  <div class="rule-editor" style="display:flex;gap:8px;align-items:center;margin-top:6px;">
                    <label class="note">Adjust</label>
                    <select class="input" data-field="sign" style="min-width:86px;background:var(--chip);border:1px solid var(--border);color:var(--text);border-radius:8px;padding:6px 8px;">
                      <option value="+">+</option>
                      <option value="-" selected>-</option>
                    </select>
                    <input class="input" data-field="value" type="number" step="0.01" min="0" placeholder="10.00"
                          style="width:10ch;background:var(--chip);border:1px solid var(--border);color:var(--text);border-radius:8px;padding:6px 8px;text-align:right;" />
                    <select class="input" data-field="unit" style="min-width:86px;background:var(--chip);border:1px solid var(--border);color:var(--text);border-radius:8px;padding:6px 8px;">
                      <option value="%">%</option>
                      <option value="$">$</option>
                    </select>
                    <span class="note" data-field="preview" style="color:var(--muted);font-size:12px;">Example: $100 → $90.00</span>
                    <a href="#" class="note" data-act="reset" style="margin-left:2px;">Reset</a>
                  </div>
                </div>
                <div class="plan-badge" style="font-size:12px;padding:4px 8px;border-radius:999px;border:1px solid var(--border);background:var(--chip);">code: NRF</div>
              </div>

              <!-- Breakfast (editable) -->
              <div class="plan-row" data-plan-code="BRKF" style="display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center;padding:8px 10px;border-radius:8px;background:var(--panel-2);border:1px solid var(--border);">
                <div>
                  <div class="plan-name" style="font-weight:600;">Breakfast</div>
                  <div class="plan-meta" style="color:var(--muted);font-size:12px;">Rule applies to Standard price</div>
                  <div class="rule-editor" style="display:flex;gap:8px;align-items:center;margin-top:6px;">
                    <label class="note">Adjust</label>
                    <select class="input" data-field="sign" style="min-width:86px;background:var(--chip);border:1px solid var(--border);color:var(--text);border-radius:8px;padding:6px 8px;">
                      <option value="+">+</option>
                      <option value="-" selected>-</option>
                    </select>
                    <input class="input" data-field="value" type="number" step="0.01" min="0" placeholder="15.00"
                          style="width:10ch;background:var(--chip);border:1px solid var(--border);color:var(--text);border-radius:8px;padding:6px 8px;text-align:right;" />
                    <select class="input" data-field="unit" style="min-width:86px;background:var(--chip);border:1px solid var(--border);color:var(--text);border-radius:8px;padding:6px 8px;">
                      <option value="$" selected>$</option>
                      <option value="%">%</option>
                    </select>
                    <span class="note" data-field="preview" style="color:var(--muted);font-size:12px;">Example: $100 → $85.00</span>
                    <a href="#" class="note" data-act="reset" style="margin-left:2px;">Reset</a>
                  </div>
                </div>
                <div class="plan-badge" style="font-size:12px;padding:4px 8px;border-radius:999px;border:1px solid var(--border);background:var(--chip);">code: BRKF</div>
              </div>
            </div> <!-- closes id="plans-list" -->

            <!-- Save button at bottom-right of the panel -->
            <div class="plans-save-wrap" style="display:flex; justify-content:flex-end; margin-top:10px;">
              <button id="save-plan-rules" class="btn btn-primary" type="button" title="Save rules for derived plans">
                Save Plan Rate IDs
              </button>
            </div>
          </div>

  <!-- Edit Room Modal -->
  <div id="edit-modal" class="modal" aria-modal="true" role="dialog" aria-labelledby="edit-title">
    <div class="dialog">
      <header class="edit-room-header">
        <h3 id="edit-title">Edit room</h3>
      <button type="button"
              id="edit-room-close"
              class="dialog-close secondary btn btn-secondary-outline"
              aria-label="Close">
        X
      </button>
      </header>
      <div class="body">
        <div class="row">
          <label for="edit-name" class="muted">Name</label>
          <input id="edit-name" class="input" autocomplete="off" />
        </div>
        <div class="row">
          <label for="edit-base" class="muted">Base price (USD)</label>
          <input id="edit-base" class="input" inputmode="decimal" autocomplete="off" />
        </div>
        <div class="row">
          <label for="edit-max" class="muted">Max capacity</label>
          <input id="edit-max" class="input" type="number" min="1" step="1" />
        </div>
        <div class="row">
          <label for="edit-active" class="muted">Status</label>
          <select id="edit-active" class="input">
            <option value="true">Active</option>
            <option value="false">Inactive</option>
          </select>
        </div>

        <!-- ANCHOR: ROOM_INFO_FIELDS -->
        <div class="row">
          <label class="muted">Room size</label>
          <div class="room-size-row">
            <div class="room-size-field">
              <span class="muted small">sqm²</span>
              <input
                id="edit-room-size-sqm"
                class="input"
                inputmode="decimal"
                placeholder="0"
              />
            </div>
            <div class="room-size-field">
              <span class="muted small">sq ft</span>
              <input
                id="edit-room-size-sqft"
                class="input"
                inputmode="decimal"
                placeholder="0"
              />
            </div>
          </div>
        </div>
        <div class="row">
          <label for="edit-room-summary" class="muted">Room summary</label>
          <textarea id="edit-room-summary"
                    class="input"
                    rows="2"
                    placeholder="Short description shown to guests"></textarea>
        </div>
          <div class="row ri-section">
            <label class="muted">Room details</label>
            <div class="ri-details-grid">
              <label class="ri-row">
                <span>City view</span>
                <input type="checkbox" class="ri-detail" value="city_view">
              </label>
              <label class="ri-row">
                <span>Sea / ocean view</span>
                <input type="checkbox" class="ri-detail" value="sea_view">
              </label>
              <label class="ri-row">
                <span>Garden view</span>
                <input type="checkbox" class="ri-detail" value="garden_view">
              </label>
              <label class="ri-row">
                <span>Pool view</span>
                <input type="checkbox" class="ri-detail" value="pool_view">
              </label>
              <label class="ri-row">
                <span>High floor</span>
                <input type="checkbox" class="ri-detail" value="high_floor">
              </label>

              <label class="ri-row">
                <span>King bed</span>
                <input type="checkbox" class="ri-detail" value="bed_king">
              </label>
              <label class="ri-row">
                <span>Queen bed</span>
                <input type="checkbox" class="ri-detail" value="bed_queen">
              </label>
              <label class="ri-row">
                <span>Double bed</span>
                <input type="checkbox" class="ri-detail" value="bed_double">
              </label>
              <label class="ri-row">
                <span>Single or twin bed</span>
                <input type="checkbox" class="ri-detail" value="bed_single_twin">
              </label>
              <label class="ri-row">
                <span>Bunk bed</span>
                <input type="checkbox" class="ri-detail" value="bed_bunk">
              </label>
              <label class="ri-row">
                <span>Sofa bed</span>
                <input type="checkbox" class="ri-detail" value="bed_sofa">
              </label>

              <label class="ri-row">
                <span>Balcony or terrace</span>
                <input type="checkbox" class="ri-detail" value="balcony_terrace">
              </label>
              <label class="ri-row">
                <span>Separate living area</span>
                <input type="checkbox" class="ri-detail" value="separate_living">
              </label>
              <label class="ri-row">
                <span>Kitchenette</span>
                <input type="checkbox" class="ri-detail" value="kitchenette">
              </label>
              <label class="ri-row">
                <span>Full kitchen</span>
                <input type="checkbox" class="ri-detail" value="full_kitchen">
              </label>
              <label class="ri-row">
                <span>Private pool</span>
                <input type="checkbox" class="ri-detail" value="private_pool">
              </label>

              <label class="ri-row">
                <span>Air conditioning</span>
                <input type="checkbox" class="ri-detail" value="air_conditioning">
              </label>
              <label class="ri-row">
                <span>TV with streaming</span>
                <input type="checkbox" class="ri-detail" value="tv_streaming">
              </label>
              <label class="ri-row">
                <span>Refrigerator</span>
                <input type="checkbox" class="ri-detail" value="refrigerator">
              </label>
              <label class="ri-row">
                <span>Work desk</span>
                <input type="checkbox" class="ri-detail" value="work_desk">
              </label>
              <label class="ri-row">
                <span>In-room safe</span>
                <input type="checkbox" class="ri-detail" value="inroom_safe">
              </label>

              <label class="ri-row">
                <span>Bathtub</span>
                <input type="checkbox" class="ri-detail" value="bathtub">
              </label>
              <label class="ri-row">
                <span>Bidet</span>
                <input type="checkbox" class="ri-detail" value="bidet">
              </label>
              <label class="ri-row">
                <span>Crib or baby cot available</span>
                <input type="checkbox" class="ri-detail" value="crib_available">
              </label>
              <label class="ri-row">
                <span>Handicap accessible room</span>
                <input type="checkbox" class="ri-detail" value="handicap_accessible">
              </label>
            </div>
          </div>

          <div class="row ri-section">
            <label class="muted">Property Facilities & Inclusions</label>
            <div class="ri-inclusions-grid">
              <label class="ri-row">
                <span>Breakfast included (no added cost)</span>
                <input type="checkbox" class="ri-inclusion" value="breakfast_included">
              </label>
              <label class="ri-row">
                <span>Kids stay free under 12</span>
                <input type="checkbox" class="ri-inclusion" value="kids_free_under12">
              </label>
              <label class="ri-row">
                <span>Free Wi-Fi</span>
                <input type="checkbox" class="ri-inclusion" value="free_wifi">
              </label>
              <label class="ri-row">
                <span>Free parking</span>
                <input type="checkbox" class="ri-inclusion" value="free_parking">
              </label>
              <label class="ri-row">
                <span>Airport shuttle</span>
                <input type="checkbox" class="ri-inclusion" value="airport_shuttle">
              </label>
              <label class="ri-row">
                <span>Daily housekeeping</span>
                <input type="checkbox" class="ri-inclusion" value="daily_housekeeping">
              </label>

              <label class="ri-row">
                <span>Swimming pool</span>
                <input type="checkbox" class="ri-inclusion" value="facility_pool">
              </label>
              <label class="ri-row">
                <span>Gym or fitness center</span>
                <input type="checkbox" class="ri-inclusion" value="facility_gym">
              </label>
              <label class="ri-row">
                <span>Spa or sauna</span>
                <input type="checkbox" class="ri-inclusion" value="facility_spa_sauna">
              </label>
              <label class="ri-row">
                <span>Beachfront or direct beach access</span>
                <input type="checkbox" class="ri-inclusion" value="beachfront_access">
              </label>
              <label class="ri-row">
                <span>Water sports equipment (kayak / paddleboard / snorkel)</span>
                <input type="checkbox" class="ri-inclusion" value="watersports_equipment">
              </label>

              <label class="ri-row">
                <span>24-hour front desk</span>
                <input type="checkbox" class="ri-inclusion" value="frontdesk_24h">
              </label>
              <label class="ri-row">
                <span>Family / child-friendly property</span>
                <input type="checkbox" class="ri-inclusion" value="family_friendly">
              </label>
              <label class="ri-row">
                <span>Non-smoking property</span>
                <input type="checkbox" class="ri-inclusion" value="nonsmoking_property">
              </label>
              <label class="ri-row">
                <span>Smoking area</span>
                <input type="checkbox" class="ri-inclusion" value="smoking_area">
              </label>
              <label class="ri-row">
                <span>Pets allowed</span>
                <input type="checkbox" class="ri-inclusion" value="pets_allowed">
              </label>
              <label class="ri-row">
                <span>Facilities for disabled guests</span>
                <input type="checkbox" class="ri-inclusion" value="disabled_facilities">
              </label>

              <label class="ri-row">
                <span>Business center or meeting rooms</span>
                <input type="checkbox" class="ri-inclusion" value="business_center">
              </label>
              <label class="ri-row">
                <span>Shared kitchen or guest pantry</span>
                <input type="checkbox" class="ri-inclusion" value="shared_kitchen">
              </label>
              <label class="ri-row">
                <span>Laundry service or self-service laundry</span>
                <input type="checkbox" class="ri-inclusion" value="laundry">
              </label>
              <label class="ri-row">
                <span>On-site restaurant</span>
                <input type="checkbox" class="ri-inclusion" value="onsite_restaurant">
              </label>

              <label class="ri-row">
                <span>Eco-cleaning option (reduced housekeeping)</span>
                <input type="checkbox" class="ri-inclusion" value="eco_cleaning">
              </label>
              <label class="ri-row">
                <span>Quiet hours enforced</span>
                <input type="checkbox" class="ri-inclusion" value="quiet_hours">
              </label>
              <label class="ri-row">
                <span>Guaranteed crib or baby cot</span>
                <input type="checkbox" class="ri-inclusion" value="crib_guaranteed">
              </label>
              <label class="ri-row">
                <span>Flexible self check-in (lockbox / smart lock)</span>
                <input type="checkbox" class="ri-inclusion" value="flexible_self_checkin">
              </label>
            </div>
          </div>

        <!-- END ANCHOR: ROOM_INFO_FIELDS -->

        <div class="warn-msg" id="edit-warn" style="display:none;"></div>
      </div>
      <footer>
        <button id="edit-cancel" class="secondary btn btn-secondary-outline" type="button">Cancel</button>
        <button id="edit-save" class="btn" type="button">Save</button>
      </footer>
    </div>
  </div>

<script>
(() => {
  /* ===== Month window core ===== */
  const WEEK_START = 1;
  let visibleWeeks = 3;
  let currentMonth = (() => { const d=new Date(); return new Date(d.getFullYear(), d.getMonth(), 1); })();
  let currentAnchor = null;
  let __renderEpoch = 0;   // prevents stale renderCalendar from clobbering newer UI

  const el = (id) => document.getElementById(id);
  const status = el("status");
  const roomsList = el("rooms-list");
  const calGrid = el("cal-grid");
  const monthPrevBtn = el("month-prev");
  const monthNextBtn = el("month-next");

    // Room photos (between calendar and rate-plan rules)
  const roomPhotosPanel = el("room-photos-panel");
  const roomPhotosList  = el("room-photos-list");
  const managePhotosBtn = el("manage-room-photos-btn");

  // Simple in-memory cache: roomId -> [{id,url,label}, ...]
  const roomPhotosCache = new Map();

  function renderRoomPhotos(roomId, photos){
    if (!roomPhotosPanel || !roomPhotosList) return;

    const list = Array.isArray(photos) ? photos : [];
    if (!list.length){
      roomPhotosPanel.classList.add("empty");
      roomPhotosList.innerHTML = `<span class="note">No photos for this room yet.</span>`;
      return;
    }

    roomPhotosPanel.classList.remove("empty");

    const top3 = list.slice(0, 3);
    const html = top3.map(p => {
      const id    = p && p.id != null ? String(p.id) : "";
      const url   = p && (p.thumbnailUrl || p.url || p.src || "");
      const label = (p && (p.label || p.caption || "Room photo")).replace(/"/g, "&quot;");
      if (!url){
        return `<div class="room-photo-thumb" data-photo-id="${id}"><span>${label}</span></div>`;
      }
      return `
        <div class="room-photo-thumb" data-photo-id="${id}">
          <img src="${url}" alt="${label}">
        </div>`;
    }).join("");

    roomPhotosList.innerHTML = html;
  }

  async function loadRoomPhotos(roomId){
    if (!roomPhotosPanel || !roomPhotosList) return;

    const rid = Number(roomId);
    if (!Number.isFinite(rid)){
      renderRoomPhotos(null, []);
      return;
    }

    // Use cache first to avoid re-fetching
    if (roomPhotosCache.has(rid)){
      renderRoomPhotos(rid, roomPhotosCache.get(rid));
      return;
    }

    roomPhotosPanel.classList.add("empty");
    roomPhotosList.innerHTML = `<span class="note">Loading photos…</span>`;

    try {
      // Backend: use /extranet/property/photos (exists) and filter by roomTypeId.
      // Response shape: { value:[...], Count } (or sometimes bare array).
      const res = await authFetch(`/extranet/property/photos`, { method:"GET" });

      if (!res.ok){
        roomPhotosCache.set(rid, []);
        renderRoomPhotos(rid, []);
        return;
      }

      const j = await res.json().catch(() => ({}));

      // normalize list
      let all = [];
      if (Array.isArray(j)) all = j;
      else if (Array.isArray(j.value)) all = j.value;
      else if (Array.isArray(j.photos)) all = j.photos;

      // keep only this room’s photos
      const arr = all.filter(p => Number(p?.roomTypeId) === rid);

      const normalized = arr
        .filter(p => p && (p.thumbnailUrl || p.url || p.src))
        .map(p => ({
          id: p.id,
          url: p.thumbnailUrl || p.url || p.src,
          label: p.label || p.caption || ""
        }));

      roomPhotosCache.set(rid, normalized);
      renderRoomPhotos(rid, normalized);
    } catch (e){
      console.warn("[room photos] load failed", e);
      roomPhotosCache.set(rid, []);
      renderRoomPhotos(rid, []);
    }
  }

  if (managePhotosBtn){
    managePhotosBtn.addEventListener("click", () => {
      const rid = Number(window.currentRoomTypeId);
      const qs  = new URLSearchParams(window.location.search || "");
      if (Number.isFinite(rid)) qs.set("room", String(rid));

      const url = "/partners_photos.html" + (qs.toString() ? ("?" + qs.toString()) : "");
      console.log("[Room photos] Navigating to:", url);
      managePhotosBtn.disabled = true;
      managePhotosBtn.textContent = "Opening Photos...";
      setTimeout(() => { window.location.href = url; }, 300);
    });
  }

  /* ANCHOR: KILL_OVERLAY_DUP */
  function removeOverlayPlansPanel(){
    const panels = document.querySelectorAll('#plans-panel');
    if (panels.length > 1){
      panels.forEach(p=>{
        const pos = getComputedStyle(p).position;
        if (pos === 'fixed') p.remove();   // nuke the modal copy
      });
    }
    // ensure inline panel is visible if someone left hidden=""
    const inlinePanel = document.querySelector('#plans-panel');
    if (inlinePanel && inlinePanel.hasAttribute('hidden')) inlinePanel.removeAttribute('hidden');
  }
  document.addEventListener('DOMContentLoaded', removeOverlayPlansPanel);

  // On first paint, restore room/date window from saved context, then align chips
  document.addEventListener('DOMContentLoaded', () => {
    try {
      const ctx = (typeof loadCtx === 'function') ? loadCtx() : null;
      if (ctx && typeof ctx === 'object') {
        if (Number.isFinite(Number(ctx.roomId))) {
          window.currentRoomTypeId = Number(ctx.roomId);
          try { loadRoomPhotos(window.currentRoomTypeId); } catch(_){}
        }
        if (ctx.start) {
          const rs = document.getElementById('range-start');
          if (rs) rs.value = String(ctx.start);
          window.currentRangeStart = String(ctx.start);
        }
        if (ctx.end) {
          const re = document.getElementById('range-end');
          if (re) re.value = String(ctx.end);
          window.currentRangeEnd = String(ctx.end);
        }
      }
      // Snap chips/global primary to the hydrated room BEFORE any initial render
      try { window.syncChipsToCurrentRoom?.(); } catch(_){}
    } catch(_){}
  });

  // Mark chips ready for renderCalendar guard
  document.addEventListener('plans:rendered', () => { window.__plansReady = true; });

  // Ensure rate-plan chips match the current room as soon as chips finish rendering
  document.addEventListener('plans:rendered', () => {
    try { window.syncChipsToCurrentRoom?.(); } catch(_){}
  }, { once:true });

  // Keep chips/globals room-scoped BEFORE other listeners run (no render race)
  // Guarded to avoid infinite loop because syncChipsToCurrentRoom() re-dispatches 'rateplans:changed'
  (function(){
    let __syncing = false;
    document.addEventListener('rateplans:changed', () => {
      if (__syncing) return;
      __syncing = true;
      try { window.syncChipsToCurrentRoom?.(); } catch(_){}
      finally { __syncing = false; }
    }, { capture: true });
  })();

  /* ANCHOR: HARDEN_GUARD_RELOAD */
  (function installReloadGuards(){
    const evt = 'rateplans:changed';
    const SUPPRESS_MS = 500;
    let last = 0;

    // Capture-phase listener runs before your existing handler
    document.addEventListener(evt, function(e){
      const now = Date.now();
      if (now - last < SUPPRESS_MS) {
        e.stopImmediatePropagation(); // suppress burst duplicates
        return;
      }
      last = now;
    }, true);
  })();

  /* ANCHOR: PLAN_CACHE_TTL */
  (function planCacheTTL(){
    const LS_KEY = 'rateplan.cache.v2'; // { ids:'1,6', primary:1, ts:1699999999999, ttl:600000 }
    const DEFAULT_TTL_MS = 10 * 60 * 1000; // 10 minutes (tune as needed)

    const safeLS = {
      get(k){ try { return localStorage.getItem(k); } catch(_){ return null; } },
      set(k,v){ try { localStorage.setItem(k, v); } catch(_){ } },
      del(k){ try { localStorage.removeItem(k); } catch(_){ } },
    };

    function now(){ return Date.now(); }

    function readCache(){
      const raw = safeLS.get(LS_KEY);
      if (!raw) return null;
      try { return JSON.parse(raw); } catch(_){ return null; }
    }

    function isFresh(entry){
      if (!entry || !Number.isFinite(entry.ts)) return false;
      const ttl = Number.isFinite(entry.ttl) ? entry.ttl : DEFAULT_TTL_MS;
      return (now() - entry.ts) < ttl;
    }

    function writeCache(idsArrOrString, primary, ttlMs){
      const ids = Array.isArray(idsArrOrString) ? idsArrOrString.join(',') : String(idsArrOrString||'');
      const payload = { ids, primary: Number(primary)||null, ts: now(), ttl: Number(ttlMs)||DEFAULT_TTL_MS };
      safeLS.set(LS_KEY, JSON.stringify(payload));
    }

    function currentSelectedIdsFromDOM(){
      // Try to infer from chips/checkboxes if present; fall back to window state.
      const chipNodes = document.querySelectorAll('[data-plan-id].selected, input[name="rateplan"]:checked, input[data-plan-id]:checked');
      const fromDOM = Array.from(chipNodes).map(n => Number(n.getAttribute('data-plan-id') || n.value)).filter(Number.isFinite);
      if (fromDOM.length) return fromDOM;
      if (Array.isArray(window.currentRatePlanIds) && window.currentRatePlanIds.length) return window.currentRatePlanIds;
      if (Number.isFinite(window.currentRatePlanId)) return [window.currentRatePlanId];
      return [];
    }

    function primaryFrom(ids){
      if (!ids || !ids.length) return null;
      // Convention: first selected is primary
      return Number(ids[0]) || null;
    }

    // 🔁 Keep cache updated whenever rateplans change (bubbling phase, after your handlers)
    document.addEventListener('rateplans:changed', function(e){
      // Prefer explicit payload if provided by your app
      const detailIds = e && e.detail && e.detail.ids;
      const ids = Array.isArray(detailIds) ? detailIds
                : (typeof detailIds === 'string' ? detailIds.split(',').map(s=>Number(s.trim())).filter(Number.isFinite)
                : currentSelectedIdsFromDOM());
      if (!ids || !ids.length) return;

      const primary = (e && e.detail && Number.isFinite(e.detail.primary))
        ? Number(e.detail.primary)
        : primaryFrom(ids);

      writeCache(ids, primary);
    }, false);

    // 🩹 Self-heal on load/boot: if nothing is selected yet and cache is fresh, restore once
    (function tryRestoreOnce(){
      const hasSelection = currentSelectedIdsFromDOM().length > 0 || Number.isFinite(window.currentRatePlanId);
      if (hasSelection) return;

      const entry = readCache();
      if (!isFresh(entry) || !entry || !entry.ids) return;

      const ids = entry.ids.split(',').map(s=>Number(s.trim())).filter(Number.isFinite);
      if (!ids.length) return;

      // Set global hints (non-invasive to DOM) and emit one clean event
      window.currentRatePlanId = Number.isFinite(entry.primary) ? entry.primary : primaryFrom(ids);
      window.currentRatePlanIds = ids.slice();

      // This will notify the rest of the app; Step 1’s guard prevents bursts.
      document.dispatchEvent(new CustomEvent('rateplans:changed', {
        detail: { ids: ids.slice(), primary: window.currentRatePlanId, source: 'plan-cache-ttl-restore' }
      }));
    })();

    /* ANCHOR: PLAN_CACHE_SCOPE */
    (function scopePlanCachePerContext(){
      if (!window.__planCacheTTL) return;

      // Derive a stable scope from globals/URL
      function getScope(){
        // Prefer explicit globals if your app sets them
        const prop = Number(window.currentPropertyId) || Number(new URLSearchParams(location.search).get('propertyId')) || 0;
        const room = Number(window.currentRoomTypeId) || 0;
        return { prop, room };
      }

      function makeKey(base){
        const { prop, room } = getScope();
        // If room=0 (unknown), still scope by property
        return `${base}::p${prop}::r${room}`;
      }

      // Keep reference to original helpers
      const _read  = window.__planCacheTTL.read;
      const _write = window.__planCacheTTL.write;
      const _fresh = window.__planCacheTTL.isFresh;

      // Back-compat: migrate old unscoped cache (rateplan.cache.v2) into scoped key once, then delete.
      const RAW_BASE = 'rateplan.cache.v2';
      function migrateIfNeeded(){
        try {
          const raw = localStorage.getItem(RAW_BASE);
          if (!raw) return;
          const scoped = makeKey(RAW_BASE);
          // Only migrate if scoped doesn’t exist yet
          if (!localStorage.getItem(scoped)) {
            localStorage.setItem(scoped, raw);
          }
          // Remove old unscoped to avoid future bleed
          localStorage.removeItem(RAW_BASE);
        } catch(_){}
      }
      migrateIfNeeded();

      // Wrap read/write to use scoped LS keys.
      window.__planCacheTTL.read = function(){
        try {
          const scoped = makeKey(RAW_BASE);
          const raw = localStorage.getItem(scoped);
          return raw ? JSON.parse(raw) : null;
        } catch(_){ return null; }
      };

      window.__planCacheTTL.write = function(ids, primary, ttlMs){
        try {
          const scoped = makeKey(RAW_BASE);
          const payload = { ids: Array.isArray(ids)? ids.join(',') : String(ids||''), primary, ts: Date.now(), ttl: Number(ttlMs)|| (10*60*1000) };
          localStorage.setItem(scoped, JSON.stringify(payload));
        } catch(_){}
      };

      // Optional safety: ignore restores if none of the saved ids exist in current DOM
      window.__planCacheTTL._idsExistInDOM = function(ids){
        const set = new Set((Array.isArray(ids)? ids:[]).map(n=>String(n)));
        const nodes = document.querySelectorAll('[data-plan-id], input[data-plan-id], input[name="rateplan"]');
        for (const n of nodes) {
          const pid = n.getAttribute('data-plan-id') || n.value;
          if (pid != null && set.has(String(Number(pid)))) return true;
        }
        return false;
      };
    })();

    /* ANCHOR: PLAN_SCOPE_WATCHER */
    (function planScopeWatcher(){
      // On extranet Rooms & Availability, disable scope watcher to prevent rate plans auto clearing.
      const path = (location && location.pathname) ? location.pathname : '';
      if (path.includes('partners_rooms')) {
        return;
      }

      // Must come after PLAN_CACHE_SCOPE so getScope logic matches
      function getScope(){
        const prop = Number(window.currentPropertyId) || Number(new URLSearchParams(location.search).get('propertyId')) || 0;
        const room = Number(window.currentRoomTypeId) || 0;
        return { prop, room };
      }

      const SSK = 'plan.scope.last';
      function readLast(){
        try { return JSON.parse(sessionStorage.getItem(SSK) || 'null'); } catch(_){ return null; }
      }
      function writeLast(s){
        try { sessionStorage.setItem(SSK, JSON.stringify(s)); } catch(_){}
      }

      function scopesDiffer(a,b){
        if (!a || !b) return true;
        return Number(a.prop)!==Number(b.prop) || Number(a.room)!==Number(b.room);
      }

      function clearGlobalsAndDom(){
        try {
          // Clear globals so nothing stale leaks across contexts
          delete window.currentRatePlanId;
          window.currentRatePlanIds = [];

          // Best-effort uncheck existing UI (if present)
          const nodes = document.querySelectorAll('input[name="rateplan"]:checked, input[data-plan-id]:checked, [data-plan-id].selected');
          nodes.forEach(n => {
            if (n.matches('input[type="checkbox"], input[type="radio"]')) n.checked = false;
            n.classList && n.classList.remove('selected');
          });
        } catch(_){}
      }

      function onScopeChange(){
        clearGlobalsAndDom();
        // Do NOT emit an empty event; the cache/URL/history restorers will re-emit correctly
        // once the appropriate chips are present (PLAN_CACHE_DEFER_RESTORE handles timing).
      }

      // Initial check on load
      const now = getScope();
      const last = readLast();
      if (scopesDiffer(now, last)) {
        onScopeChange();
        writeLast(now);
      }

      // Update on navigation events that commonly imply scope changes
      window.addEventListener('popstate', () => {
        const cur = getScope();
        const prev = readLast();
        if (scopesDiffer(cur, prev)) {
          onScopeChange();
          writeLast(cur);
        }
      }, { capture: true });

      window.addEventListener('pageshow', () => {
        const cur = getScope();
        const prev = readLast();
        if (scopesDiffer(cur, prev)) {
          onScopeChange();
          writeLast(cur);
        }
      }, { capture: true });
    })();

    // Public helpers if you want to adjust TTL elsewhere
    window.__planCacheTTL = {
      read: readCache,
      write: writeCache,
      isFresh
    };
  })();

  /* ANCHOR: PLAN_NET_CANCEL_ON_SCOPE */
  (function cancelNetworkOnScopeChange(){
    if (!window.__singleFlight?.cancelByPrefix) return;

    const SSK = 'plan.scope.last';

    function getScope(){
      const prop = Number(window.currentPropertyId) || Number(new URLSearchParams(location.search).get('propertyId')) || 0;
      const room = Number(window.currentRoomTypeId) || 0;
      return { prop, room };
    }
    function readLast(){
      try { return JSON.parse(sessionStorage.getItem(SSK) || 'null'); } catch(_){ return null; }
    }
    function writeLast(s){
      try { sessionStorage.setItem(SSK, JSON.stringify(s)); } catch(_){}
    }
    function scopesDiffer(a,b){
      if (!a || !b) return true;
      return Number(a.prop)!==Number(b.prop) || Number(a.room)!==Number(b.room);
    }

    function cancelAll(){
      try {
        // Abort any pending reads tied to old scope
        window.__singleFlight.cancelByPrefix('GET /api/prices');
        window.__singleFlight.cancelByPrefix('GET /api/rateplans');
        // (Extend here if you have other GETs to cancel)
      } catch(_){}
    }

    function handleScopeChange(){
      cancelAll();
      // Optional: clear the "pending" flag so UI doesn’t look stuck
      const host = document.getElementById('plans-panel') || document.documentElement;
      host && host.removeAttribute('data-price-pending');
    }

    // Initial compare on load
    (function init(){
      const now = getScope();
      const last = readLast();
      if (scopesDiffer(now, last)) handleScopeChange();
      writeLast(now);
    })();

    // React to navigation events that imply scope changes
    window.addEventListener('popstate', () => {
      const now = getScope();
      const last = readLast();
      if (scopesDiffer(now, last)) { handleScopeChange(); writeLast(now); }
    }, { capture: true });

    window.addEventListener('pageshow', () => {
      const now = getScope();
      const last = readLast();
      if (scopesDiffer(now, last)) { handleScopeChange(); writeLast(now); }
    }, { capture: true });

    // Also react when URL’s query string changes without navigation (SPA links)
    let prevHref = location.href;
    setInterval(() => {
      if (location.href !== prevHref) {
        prevHref = location.href;
        const now = getScope();
        const last = readLast();
        if (scopesDiffer(now, last)) { handleScopeChange(); writeLast(now); }
      }
    }, 400);
  })();

  /* ANCHOR: PLAN_CACHE_DEFER_RESTORE */
  (function deferPlanRestoreUntilChips(){
    // Requires: window.__planCacheTTL (from PLAN_CACHE_TTL), and optionally window.emitRateplansChanged
    if (!window.__planCacheTTL) return;

    // Helper: read current selection presence from DOM
    function hasDomSelection(){
      const checked = document.querySelector('input[name="rateplan"]:checked, input[data-plan-id]:checked');
      const tagged  = document.querySelector('[data-plan-id].selected');
      return !!(checked || tagged);
    }

    // Try a quick sync path first (in case chips already exist)
    function tryApplyFromCache(sourceTag){
      try {
        const entry = window.__planCacheTTL.read?.();
        if (!window.__planCacheTTL.isFresh?.(entry) || !entry || !entry.ids) return false;

      const ids = String(entry.ids).split(',').map(s => Number(s.trim())).filter(Number.isFinite);
        if (!ids.length) return false;

        const primary = Number.isFinite(Number(entry.primary)) ? Number(entry.primary) : ids[0];

        // Build available set from the current DOM and intersect with cached ids
        const domNodes = document.querySelectorAll('[data-plan-id], input[data-plan-id], input[name="rateplan"]');
        const available = new Set(
          Array.from(domNodes)
            .map(n => Number(n.getAttribute('data-plan-id') || n.value))
            .filter(Number.isFinite)
        );
        const idsToApply = ids.filter(id => available.has(id));
        if (!idsToApply.length) return false;

        const newPrimary = available.has(primary) ? primary : idsToApply[0];

        // Only emit if DOM has no selection yet (avoid overwriting user action)
        if (!hasDomSelection()) {
          if (typeof window.emitRateplansChanged === 'function') {
            window.emitRateplansChanged(idsToApply, newPrimary, sourceTag);
          } else {
            document.dispatchEvent(new CustomEvent('rateplans:changed', {
              detail: { ids: idsToApply, primary: newPrimary, source: sourceTag }
            }));
          }
          return true;
        }
      } catch(_){}
      return false;
    }

    // 1) Immediate attempt in case chips are already present
    if (tryApplyFromCache('plan-cache-dom-immediate')) return;

    // 2) Observe for plan chips attaching, with a short timeout safety
    const deadlineMs = 5000;   // stop observing after 5s
    const startedAt  = Date.now();

    const observer = new MutationObserver(() => {
      // If chips appeared, try apply once
      const hasChips = document.querySelector('[data-plan-id], input[name="rateplan"], input[data-plan-id]');
      if (hasChips) {
        if (tryApplyFromCache('plan-cache-dom-attach')) {
          observer.disconnect();
          return;
        }
      }
      // Hard stop to avoid lingering observers
      if (Date.now() - startedAt > deadlineMs) observer.disconnect();
    });

    /* ANCHOR: PLAN_CACHE_REAPPLY_ON_PANEL_MUTATION */
    (function reapplyOnPlansPanelMutation(){
      if (!window.__planCacheTTL) return;

      // Debounced re-apply from cache if DOM lost selection after a re-render
      let timer = null;
      function debouncedTry(){
        if (timer) return;
        timer = setTimeout(() => {
          timer = null;
          try {
            const entry = window.__planCacheTTL.read?.();
            if (!window.__planCacheTTL.isFresh?.(entry) || !entry || !entry.ids) return;

            const ids = String(entry.ids).split(',').map(s => Number(s.trim())).filter(Number.isFinite);
            if (!ids.length) return;

            // If DOM already has a selection, do nothing
            const hasDomSelection = !!document.querySelector('[data-plan-id].selected, input[name="rateplan"]:checked, input[data-plan-id]:checked');
            if (hasDomSelection) return;

            // Only re-apply if those IDs exist in the current DOM (room/property check)
            if (typeof window.__planCacheTTL._idsExistInDOM === 'function' && !window.__planCacheTTL._idsExistInDOM(ids)) {
              return;
            }

            const primary = Number.isFinite(Number(entry.primary)) ? Number(entry.primary) : ids[0];

            // Emit normalized restore
            if (typeof window.emitRateplansChanged === 'function') {
              window.emitRateplansChanged(ids, primary, 'plan-cache-panel-mutation');
            } else {
              document.dispatchEvent(new CustomEvent('rateplans:changed', {
                detail: { ids, primary, source: 'plan-cache-panel-mutation' }
              }));
            }
          } catch(_){}
        }, 150);
      }

      // Observe just the plans panel if present; else fall back to document
      const target = document.getElementById('plans-panel') || document.body;
      try {
        const mo = new MutationObserver((list) => {
          // If nodes added/removed under plans panel, attempt re-apply
          for (const rec of list) {
            if (rec.type === 'childList' && (rec.addedNodes.length || rec.removedNodes.length)) {
              debouncedTry();
              break;
            }
          }
        });

        mo.observe(target, { childList: true, subtree: true });
      } catch(_){}
    })();

    /* ANCHOR: PLAN_CACHE_PERSIST_ON_HIDE */
    (function persistPlanCacheOnHide(){
      if (!window.__planCacheTTL) return;

      // Read current selection from DOM or window state
      function currentSelection(){
        // DOM first
        const chipNodes = document.querySelectorAll('[data-plan-id].selected, input[name="rateplan"]:checked, input[data-plan-id]:checked');
        const ids = Array.from(chipNodes)
          .map(n => Number(n.getAttribute('data-plan-id') || n.value))
          .filter(Number.isFinite);

        if (ids.length) return { ids, primary: ids[0] };

        // Fallback to window hints
        const arr = Array.isArray(window.currentRatePlanIds) ? window.currentRatePlanIds.filter(Number.isFinite) : [];
        if (arr.length) return { ids: arr.slice(), primary: Number(arr[0]) };

        if (Number.isFinite(window.currentRatePlanId)) return { ids: [Number(window.currentRatePlanId)], primary: Number(window.currentRatePlanId) };

        return { ids: [], primary: null };
      }

      // Throttled saver (avoid spam)
      let saveTimer = null;
      function saveNow(){
        try {
          const { ids, primary } = currentSelection();
          if (!ids.length) return;
          window.__planCacheTTL.write?.(ids, primary);
        } catch(_) {}
      }
      function saveSoon(){
        if (saveTimer) return;
        saveTimer = setTimeout(() => { saveTimer = null; saveNow(); }, 200);
      }

      // Save when user is about to leave or tab becomes hidden
      window.addEventListener('pagehide', saveNow, { capture: true });
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'hidden') saveSoon();
      }, { capture: true });

      // Optional: save when we detect a plan change (after your handlers ran)
      document.addEventListener('rateplans:changed', saveSoon, false);
    })();

    try {
      observer.observe(document.documentElement || document.body, {
        childList: true,
        subtree: true
      });
      // Also try again after the next frame and after DOMContentLoaded as extra guards
      requestAnimationFrame(() => tryApplyFromCache('plan-cache-raf'));
      document.addEventListener('DOMContentLoaded', () => tryApplyFromCache('plan-cache-domcontent'), { once: true });
    } catch(_){}
  })();

  /* ANCHOR: NET_SINGLE_FLIGHT */
  (function installSingleFlight(){
    const flights = new Map(); // key -> { promise, controllers: Set<AbortController>, startedAt }
    const DEFAULT_TIMEOUT_MS = 12000;

    function withTimeout(ms, controller){
      return setTimeout(() => {
        try { controller.abort(); } catch(_) {}
      }, ms);
    }

    function normalizeKey(url, opts){
      try {
        const u = new URL(url, location.origin);
        // Normalize order of params for stable keying
        const params = [...u.searchParams.entries()].sort((a,b)=> a[0].localeCompare(b[0]));
        const q = new URLSearchParams(params).toString();
        const method = (opts && (opts.method||'GET')).toUpperCase();
        return `${method} ${u.pathname}?${q}`;
      } catch {
        return (opts && (opts.method||'GET')).toUpperCase() + ' ' + String(url);
      }
    }

    async function json(url, opts={}, keyOverride){
      const controller = new AbortController();
      const timeoutMs = Number.isFinite(opts.timeoutMs) ? opts.timeoutMs : DEFAULT_TIMEOUT_MS;
      const key = keyOverride || normalizeKey(url, opts);

      // Coalesce if an identical request is already in flight
      if (flights.has(key)) {
        const existing = flights.get(key);
        return existing.promise;
      }

      // Add a small cache-buster to avoid intermediary caches (kept in key as well)
      try {
        const u = new URL(url, location.origin);
        u.searchParams.set('cb', String(Date.now()));
        url = u.toString();
      } catch { /* non-URL, ignore */ }

      const timer = withTimeout(timeoutMs, controller);
      const finalOpts = { ...opts, signal: controller.signal };

      const p = (async () => {
        try {
          const res = await fetch(url, finalOpts);
          if (!res.ok) {
            const txt = await res.text().catch(()=> '');
            throw new Error(`HTTP ${res.status} ${res.statusText} :: ${txt}`);
          }
          const ct = res.headers.get('content-type') || '';
          return ct.includes('application/json') ? res.json() : res.text();
        } finally {
          clearTimeout(timer);
          flights.delete(key);
        }
      })();

      /* ANCHOR: NET_SINGLE_FLIGHT_CACHE */
      (function decorateSingleFlightWithCache(){
        if (!window.__singleFlight || typeof window.__singleFlight.json !== 'function') return;

        const LS_NS = 'net.cache.v1:'; // key = LS_NS + normalizeKey(url, opts)
        const DEV = !/^(prod|production)$/i.test(String(window.__env||'')) && location.hostname !== 'lolaelo.com';

        function lsGet(k){
          try { const raw = localStorage.getItem(k); return raw ? JSON.parse(raw) : null; } catch(_){ return null; }
        }
        function lsSet(k,v){
          try { localStorage.setItem(k, JSON.stringify(v)); } catch(_){}
        }

        // Must mirror the key used by cancel prefixes: "METHOD /path?sorted=query"
        function normalizeKey(url, opts){
          try {
            const u = new URL(url, location.origin);
            // Sort params for stable keys; DO NOT include the runtime cache-buster (we add it later)
            const entries = [...u.searchParams.entries()].filter(([k]) => k !== 'cb').sort((a,b)=> a[0].localeCompare(b[0]));
            const q = new URLSearchParams(entries).toString();
            const method = (opts && (opts.method||'GET')).toUpperCase();
            return `${method} ${u.pathname}${q ? ('?'+q) : ''}`;
          } catch {
            return (opts && (opts.method||'GET')).toUpperCase() + ' ' + String(url);
          }
        }

        // TTL policy: shorter for prices, longer for static-ish lists like rateplans
        function ttlForKey(key){
          if (key.startsWith('GET /api/prices')) return 2 * 60 * 1000;     // 2 minutes
          if (key.startsWith('GET /api/rateplans')) return 60 * 60 * 1000; // 60 minutes
          return 5 * 60 * 1000; // default 5 minutes
        }

        function isFresh(entry, key){
          if (!entry || typeof entry.ts !== 'number') return false;
          const ttl = ttlForKey(key);
          return (Date.now() - entry.ts) < ttl;
        }

        const origJson = window.__singleFlight.json;

        async function jsonWithCache(url, opts={}, keyOverride){
          const key = keyOverride || normalizeKey(url, opts);
          const lsKey = LS_NS + key;

          try {
            // Try network first (keeps existing single-flight semantics)
            const data = await origJson(url, opts, keyOverride);
            // Only cache JSON-serializable payloads
            try { lsSet(lsKey, { ts: Date.now(), data }); } catch(_){}
            return data;
          } catch (err) {
            // On failure, attempt stale-while-revalidate style read
            const entry = lsGet(lsKey);
            if (isFresh(entry, key)) {
              if (DEV) console.warn('[NET_CACHE] Using cached response for', key, 'due to error:', String(err));
              return entry.data;
            }
            throw err;
          }
        }

        // Swap in the decorated version transparently
        window.__singleFlight.json = jsonWithCache;
      })();

      /* ANCHOR: NET_SINGLE_FLIGHT_RETRY */
      (function decorateSingleFlightWithRetry(){
        if (!window.__singleFlight || typeof window.__singleFlight.json !== 'function') return;

        const origJson = window.__singleFlight.json;

        // Only retry these read endpoints
        function isRetryableKey(key){
          return key.startsWith('GET /api/prices') || key.startsWith('GET /api/rateplans');
        }

        // Re-create the same key normalization used earlier (without cb)
        function normalizeKey(url, opts){
          try {
            const u = new URL(url, location.origin);
            const entries = [...u.searchParams.entries()].filter(([k]) => k !== 'cb').sort((a,b)=> a[0].localeCompare(b[0]));
            const q = new URLSearchParams(entries).toString();
            const method = (opts && (opts.method||'GET')).toUpperCase();
            return `${method} ${u.pathname}${q ? ('?'+q) : ''}`;
          } catch {
            return (opts && (opts.method||'GET')).toUpperCase() + ' ' + String(url);
          }
        }

        function sleep(ms){
          return new Promise(r => setTimeout(r, ms + Math.floor(Math.random()*60)));
        }

        function isRetryableError(err){
          const msg = String(err && (err.message || err));
          // Network/abort/timeouts:
          if (/abort/i.test(msg) || /network/i.test(msg) || /timeout/i.test(msg)) return true;
          // We may also receive 'HTTP 5xx ...'
          if (/HTTP\s+5\d{2}/.test(msg)) return true;
          return false;
        }

        async function jsonWithRetry(url, opts={}, keyOverride){
          const key = keyOverride || normalizeKey(url, opts);

          // Non-retryable endpoints fall back to original
          if (!isRetryableKey(key)) {
            return origJson(url, opts, keyOverride);
          }

          const attempts = [300, 700, 1500]; // backoff plan
          let lastErr;

          // First try (attempt 0)
          try { return await origJson(url, opts, keyOverride); }
          catch(e){ lastErr = e; if (!isRetryableError(e)) throw e; }

          // Retries with backoff
          for (let i=0; i<attempts.length; i++){
            await sleep(attempts[i]);
            try { return await origJson(url, opts, keyOverride); }
            catch(e){ lastErr = e; if (!isRetryableError(e)) break; }
          }

          // Give up — allow upstream cache decorator to try LS fallback or bubble up
          throw lastErr;
        }

        window.__singleFlight.json = jsonWithRetry;
      })();

      /* ANCHOR: NET_SINGLE_FLIGHT_EVENTS */
      (function decorateSingleFlightWithEvents(){
        if (!window.__singleFlight || typeof window.__singleFlight.json !== 'function') return;

        const origJson = window.__singleFlight.json;

        // Must mirror our normalization (without 'cb') for consistent keys
        function normalizeKey(url, opts){
          try {
            const u = new URL(url, location.origin);
            const entries = [...u.searchParams.entries()].filter(([k]) => k !== 'cb').sort((a,b)=> a[0].localeCompare(b[0]));
            const q = new URLSearchParams(entries).toString();
            const method = (opts && (opts.method||'GET')).toUpperCase();
            return `${method} ${u.pathname}${q ? ('?'+q) : ''}`;
          } catch {
            return (opts && (opts.method||'GET')).toUpperCase() + ' ' + String(url);
          }
        }

        function emit(name, detail){
          try { document.dispatchEvent(new CustomEvent(name, { detail })); } catch(_){}
        }

        async function jsonWithEvents(url, opts={}, keyOverride){
          const key = keyOverride || normalizeKey(url, opts);
          const startedAt = Date.now();

          emit('net:request', { key, startedAt });

          try {
            const data = await origJson(url, opts, keyOverride);
            emit('net:success', { key, ms: Date.now() - startedAt });
            return data;
          } catch (err) {
            emit('net:failure', { key, ms: Date.now() - startedAt, error: String(err) });
            throw err;
          }
        }

        window.__singleFlight.json = jsonWithEvents;
      })();

      /* ANCHOR: PLAN_PRICE_HINT_AND_PENDING */
      (function installPriceHintAndPending(){
        const EVT = 'rateplans:changed';
        const host = document.getElementById('plans-panel') || document.documentElement;

        // When selection changes, emit a hint with current selection signature.
        document.addEventListener(EVT, (e) => {
          try {
            const ids = Array.isArray(e?.detail?.ids) ? e.detail.ids.map(Number).filter(Number.isFinite) : [];
            if (!ids.length) return;
            const sig = ids.slice().sort((a,b)=>a-b).join(',');

            // Mark UI as "price pending" — optional CSS hook
            host && host.setAttribute('data-price-pending', '1');

            // Non-breaking hint event; your code can listen for this to eagerly fetch prices if desired
            document.dispatchEvent(new CustomEvent('prices:hint', { detail: { planSig: sig, source: String(e?.detail?.source || '') }}));
          } catch(_){}
        }, false);

        // Clear pending flag on successful prices response
        document.addEventListener('net:success', (e) => {
          try {
            const key = String(e?.detail?.key || '');
            if (!key.startsWith('GET /api/prices')) return;
            host && host.removeAttribute('data-price-pending');
          } catch(_){}
        }, false);

        // Also clear pending flag on price failure (epoch guard will auto-refetch when needed)
        document.addEventListener('net:failure', (e) => {
          try {
            const key = String(e?.detail?.key || '');
            if (!key.startsWith('GET /api/prices')) return;
            host && host.removeAttribute('data-price-pending');
          } catch(_){}
        }, false);
      })();

      /* ANCHOR: PLAN_PRICE_HINT_DEBOUNCE */
      (function debouncePriceHints(){
        // Coalesce rapid selection changes into a single refetch signal.
        // Non-breaking: your app can optionally listen to 'prices:refetch'
        // to kick a fetch for the current view.
        let t = null;
        let lastSig = '';

        function emitRefetch(sig){
          try {
            document.dispatchEvent(new CustomEvent('prices:refetch', { detail: { planSig: sig }}));
          } catch(_){}
        }

        document.addEventListener('prices:hint', (e) => {
          try {
            const sig = String(e?.detail?.planSig || '');
            if (!sig) return;
            lastSig = sig;
            clearTimeout(t);
            t = setTimeout(() => emitRefetch(lastSig), 120);
          } catch(_){}
        }, false);
      })();

      /* ANCHOR: PLAN_PRICE_PENDING_WATCHDOG */
      (function installPricePendingWatchdog(){
        if (!window.__singleFlight || typeof window.__singleFlight.json !== 'function') return;

        const host = document.getElementById('plans-panel') || document.documentElement;
        let timer = null;

        function currentPlanSig(){
          const ids = Array.isArray(window.currentRatePlanIds) ? window.currentRatePlanIds
                    : (Number.isFinite(window.currentRatePlanId) ? [window.currentRatePlanId] : []);
          return ids.map(n=>Number(n)).filter(Number.isFinite).sort((a,b)=>a-b).join(',');
        }

        function keyToUrl(key){
          try {
            const space = key.indexOf(' ');
            if (space === -1) return null;
            const pathQuery = key.slice(space + 1);
            return new URL(pathQuery, location.origin).toString();
          } catch { return null; }
        }

        let lastPricesKey = '';
        document.addEventListener('net:request', (e) => {
          const k = String(e?.detail?.key || '');
          if (k.startsWith('GET /api/prices')) lastPricesKey = k;
        }, false);

        function armWatchdog(){
          clearTimeout(timer);
          // Only arm if we’re actually pending
          if (!host || host.getAttribute('data-price-pending') !== '1') return;
          // If still pending after 2500ms, refetch for the *current* selection
          timer = setTimeout(async () => {
            try {
              // Cancel if pending cleared in the meantime
              if (!host || host.getAttribute('data-price-pending') !== '1') return;
              const url = keyToUrl(lastPricesKey);
              if (!url) return;
              await window.__singleFlight.json(url, { method: 'GET' });
            } catch(_) {}
          }, 2500);
        }

        // Arm on hint (selection changed) and on debounce refetch signal
        document.addEventListener('prices:hint', armWatchdog, false);
        document.addEventListener('prices:refetch', armWatchdog, false);

        // Disarm on success/failure of prices
        function disarm(){ clearTimeout(timer); timer = null; }
        document.addEventListener('net:success', (e) => {
          if (String(e?.detail?.key || '').startsWith('GET /api/prices')) disarm();
        }, false);
        document.addEventListener('net:failure', (e) => {
          if (String(e?.detail?.key || '').startsWith('GET /api/prices')) disarm();
        }, false);
      })();

      /* ANCHOR: PRICES_SIG_CACHE */
      (function installSelectionScopedPriceCache(){
        if (!window.__singleFlight || typeof window.__singleFlight.json !== 'function') return;

        const TTL_MS = 2 * 60 * 1000; // 2 minutes (aligns with NET_SINGLE_FLIGHT_CACHE for /api/prices)
        const cache = new Map(); // sig -> { ts, data }
        const orig = window.__singleFlight.json;

        function now(){ return Date.now(); }
        function isFresh(entry){ return !!entry && (now() - entry.ts) < TTL_MS; }

        function currentPlanSig(){
          const ids = Array.isArray(window.currentRatePlanIds)
            ? window.currentRatePlanIds
            : (Number.isFinite(window.currentRatePlanId) ? [window.currentRatePlanId] : []);
          return ids.map(Number).filter(Number.isFinite).sort((a,b)=>a-b).join(',');
        }

        function sigFromUrl(url){
          try {
            const u = new URL(url, location.origin);
            const s = u.searchParams.get('sel');
            return s ? s : '';
          } catch { return ''; }
        }

        // Decorate prices calls to store (and broadcast) results by selection signature
        window.__singleFlight.json = async function jsonWithPricesSigCache(url, opts={}, keyOverride){
          // Only affect /api/prices calls
          let keyStr = '';
          try {
            const method = (opts && (opts.method||'GET')).toUpperCase();
            const u = new URL(url, location.origin);
            keyStr = `${method} ${u.pathname}`;
          } catch { keyStr = (opts && (opts.method||'GET') || 'GET') + ' ' + String(url); }

          const isPrices = keyStr.startsWith('GET /api/prices');
          if (!isPrices) return orig(url, opts, keyOverride);

          // Use selection signature in URL if present (from PLAN_PRICE_EPOCH_GUARD), else compute
          const planSig = sigFromUrl(url) || currentPlanSig();

          const data = await orig(url, opts, keyOverride);

          try {
            // Save fresh copy
            cache.set(planSig, { ts: now(), data });
            // Immediately announce ready data for this selection
            document.dispatchEvent(new CustomEvent('prices:ready', {
              detail: { planSig, data, source: 'net' }
            }));
          } catch(_){}

          return data;
        };

        // If a selection change happens and we already have fresh prices for that sig,
        // emit them instantly (before the network completes) for perceived snappiness.
        document.addEventListener('prices:hint', (e) => {
          try {
            const sig = String(e?.detail?.planSig || '');
            if (!sig) return;
            const entry = cache.get(sig);
            if (isFresh(entry)) {
              document.dispatchEvent(new CustomEvent('prices:ready', {
                detail: { planSig: sig, data: entry.data, source: 'cache' }
              }));
            }
          } catch(_){}
        }, false);

        // Expose a tiny helper for manual pulls if you want
        window.__pricesBySig = {
          get(sig){ const x = cache.get(String(sig||'')); return isFresh(x) ? x.data : null; },
          getCurrent(){ return this.get(currentPlanSig()); },
          _debugDump(){ return Array.from(cache.keys()); }
        };
      })();

      /* ANCHOR: PRICES_READY_GATE */
      (function installPricesReadyGate(){
        const host = document.getElementById('plans-panel') || document.documentElement;

        function currentPlanSig(){
          const ids = Array.isArray(window.currentRatePlanIds)
            ? window.currentRatePlanIds
            : (Number.isFinite(window.currentRatePlanId) ? [window.currentRatePlanId] : []);
          return ids.map(Number).filter(Number.isFinite).sort((a,b)=>a-b).join(',');
        }

        // Only re-emit prices when they match the current selection signature.
        // Non-breaking: your app can optionally listen to 'prices:display' to render.
        document.addEventListener('prices:ready', (e) => {
          try {
            const sig = String(e?.detail?.planSig || '');
            const data = e?.detail?.data;
            const src  = String(e?.detail?.source || '');

            if (!sig) return;

            if (sig === currentPlanSig()) {
              // Clear any "stale" marker and announce display-ready prices
              host && host.removeAttribute('data-price-stale');
              document.dispatchEvent(new CustomEvent('prices:display', {
                detail: { planSig: sig, data, source: src }
              }));
            } else {
              // Mark that we received prices for an outdated selection; harmless, just diagnostic
              host && host.setAttribute('data-price-stale', '1');
            }
          } catch(_){}
        }, false);
      })();

      /* ANCHOR: PRICES_PENDING_CLEAR_ON_DISPLAY */
      (function clearPendingOnPricesDisplay(){
        const host = document.getElementById('plans-panel') || document.documentElement;

        // When prices are ready-to-display (cache or network), clear pending and tag the sig.
        document.addEventListener('prices:display', (e) => {
          try {
            const sig = String(e?.detail?.planSig || '');
            if (host) {
              host.removeAttribute('data-price-pending');   // stop any spinner immediately
              if (sig) host.setAttribute('data-price-sig', sig); // useful for debugging/styling
            }
          } catch(_){}
        }, false);
      })();

      /* ANCHOR: PLAN_PRICE_EPOCH_GUARD */
      (function decoratePricesWithEpochGuard(){
        if (!window.__singleFlight || typeof window.__singleFlight.json !== 'function') return;

        const origJson = window.__singleFlight.json;
        const LS_NS = 'net.cache.v1:'; // matches NET_SINGLE_FLIGHT_CACHE
        const DEV = !/^(prod|production)$/i.test(String(window.__env||'')) && location.hostname !== 'lolaelo.com';

        function normalizeKey(url, opts){
          try {
            const u = new URL(url, location.origin);
            const entries = [...u.searchParams.entries()].filter(([k]) => k !== 'cb').sort((a,b)=> a[0].localeCompare(b[0]));
            const q = new URLSearchParams(entries).toString();
            const method = (opts && (opts.method||'GET')).toUpperCase();
            return `${method} ${u.pathname}${q ? ('?'+q) : ''}`;
          } catch {
            return (opts && (opts.method||'GET')).toUpperCase() + ' ' + String(url);
          }
        }

        function currentPlanSig(){
          const ids = Array.isArray(window.currentRatePlanIds) ? window.currentRatePlanIds : (
            Number.isFinite(window.currentRatePlanId) ? [window.currentRatePlanId] : []
          );
          return ids.map(n=>Number(n)).filter(Number.isFinite).sort((a,b)=>a-b).join(',');
        }

        function deleteCacheForKey(key){
          try { localStorage.removeItem(LS_NS + key); } catch(_){}
        }

        async function jsonWithEpoch(url, opts={}, keyOverride){
          const key = keyOverride || normalizeKey(url, opts);

          // Only guard read calls to prices
          if (!key.startsWith('GET /api/prices')) {
            return origJson(url, opts, keyOverride);
          }

          // Capture the selection signature at request start
          const sigAtStart = currentPlanSig();

          // Also append it to the URL as sel= to isolate cache entries per selection
          try {
            const u = new URL(url, location.origin);
            u.searchParams.set('sel', sigAtStart || 'none');
            url = u.toString();
          } catch(_) {}

          // Use original (already decorated with retry/cache/events)
          const data = await origJson(url, opts, keyOverride);

          // If selection changed while we were in-flight, reject as stale and nuke that cache entry
          const sigNow = currentPlanSig();
          if (sigNow !== sigAtStart) {
            const nk = normalizeKey(url, opts); // includes sel=; matches cache key
            deleteCacheForKey(nk);
            if (DEV) console.warn('[PRICES_EPOCH_GUARD] Dropping stale price response (sig changed)', { sigAtStart, sigNow });
            throw new Error('STALE_PRICE_RESPONSE: selection changed during prices request');
          }

          return data;
        }

        window.__singleFlight.json = jsonWithEpoch;
      })();

      flights.set(key, { promise: p, controllers: new Set([controller]), startedAt: Date.now() });
      return p;
    }

    function cancelByPrefix(prefix){
      for (const [key, entry] of flights.entries()) {
        if (key.startsWith(prefix)) {
          for (const c of entry.controllers) { try { c.abort(); } catch(_){} }
          flights.delete(key);
        }
      }
    }

    window.__singleFlight = { json, cancelByPrefix };
  })();

  /* ANCHOR: PLAN_PRICE_AUTO_REFETCH_ON_STALE */
  (function autoRefetchPricesOnStale(){
    if (!window.__singleFlight || typeof window.__singleFlight.json !== 'function') return;

    // Track the most recent prices request key so we can reconstruct a fresh URL
    let lastPricesKey = '';

    function keyToUrl(key){
      // key format: "GET /api/prices?foo=1&bar=2"
      try {
        const space = key.indexOf(' ');
        if (space === -1) return null;
        const pathQuery = key.slice(space + 1);
        return new URL(pathQuery, location.origin).toString();
      } catch { return null; }
    }

    // Remember latest prices request (any variant)
    document.addEventListener('net:request', (e) => {
      try {
        const k = String(e?.detail?.key || '');
        if (k.startsWith('GET /api/prices')) lastPricesKey = k;
      } catch(_){}
    }, false);

    // If a prices call fails because selection changed mid-flight, immediately refetch for the *current* selection.
    document.addEventListener('net:failure', async (e) => {
      try {
        const key = String(e?.detail?.key || '');
        const err = String(e?.detail?.error || '');
        if (!key.startsWith('GET /api/prices')) return;
        if (!/STALE_PRICE_RESPONSE/.test(err)) return;

        // Rebuild a fresh URL from the last known prices key (without cb/sel; guards will add them)
        const url = keyToUrl(lastPricesKey || key);
        if (!url) return;

        // Fire a replacement request; existing guards (single-flight + epoch) will keep it clean
        await window.__singleFlight.json(url, { method: 'GET' });
        // No need to do anything else — your existing prices rendering logic should react to the success.
      } catch(_){}
    }, false);
  })();

  /* ANCHOR: PLAN_RESTORE_ON_RATEPLANS_FETCH */
  (function restoreAfterRateplansFetch(){
    const EVT = 'rateplans:changed';

    function hasDomSelection(){
      return !!document.querySelector('[data-plan-id].selected, input[name="rateplan"]:checked, input[data-plan-id]:checked');
    }
    function normIds(arr){
      return (Array.isArray(arr)? arr:[])
        .map(n=>Number(n))
        .filter(Number.isFinite)
        .sort((a,b)=>a-b);
    }
    function idsExist(ids){
      try {
        if (typeof window.__planCacheTTL?._idsExistInDOM === 'function') {
          return window.__planCacheTTL._idsExistInDOM(ids);
        }
      } catch(_){}
      const set = new Set(ids.map(String));
      const nodes = document.querySelectorAll('[data-plan-id], input[data-plan-id], input[name="rateplan"]');
      for (const n of nodes) {
        const pid = n.getAttribute('data-plan-id') || n.value;
        if (pid != null && set.has(String(Number(pid)))) return true;
      }
      return false;
    }
    function emit(ids, primary, source){
      try {
        if (typeof window.emitRateplansChanged === 'function') {
          window.emitRateplansChanged(ids, primary, source);
        } else {
          document.dispatchEvent(new CustomEvent(EVT, { detail: { ids, primary, source } }));
        }
      } catch(_){}
    }

    // When rateplans load successfully, attempt a one-time restore if needed
    document.addEventListener('net:success', () => {
      try {
        // Only act if chips exist but nothing is selected yet
        const hasChips = !!document.querySelector('[data-plan-id], input[name="rateplan"], input[data-plan-id]');
        if (!hasChips || hasDomSelection()) return;

        const entry = window.__planCacheTTL?.read?.();
        if (!entry || !window.__planCacheTTL?.isFresh?.(entry) || !entry.ids) return;

        const ids = normIds(String(entry.ids).split(',').map(s=>Number(s.trim())));
        if (!ids.length || !idsExist(ids)) return;

        const primary = Number.isFinite(Number(entry.primary)) ? Number(entry.primary) : ids[0];
        emit(ids, primary, 'plan-rateplans-fetch');
      } catch(_){}
    }, false);
  })();

  /* ANCHOR: PLAN_CACHE_PRUNE_ON_RATEPLANS */
  (function prunePlanCacheOnRateplansFetch(){
    if (!window.__planCacheTTL?.read || !window.__planCacheTTL?.write) return;

    function availableIdsFromDOM(){
      const nodes = document.querySelectorAll('[data-plan-id], input[data-plan-id], input[name="rateplan"]');
      return Array.from(nodes)
        .map(n => Number(n.getAttribute('data-plan-id') || n.value))
        .filter(Number.isFinite);
    }

    document.addEventListener('net:success', (e) => {
      try {
        const entry = window.__planCacheTTL.read();
        if (!entry || !window.__planCacheTTL.isFresh?.(entry) || !entry.ids) return;

        // Only act right after rateplans finish loading (chips are present)
        // We key by prefix so any GET /api/rateplans?... matches.
        const key = e?.detail?.key || '';
        if (typeof key !== 'string' || !key.startsWith('GET /api/rateplans')) return;

        const avail = new Set(availableIdsFromDOM());
        const cachedIds = String(entry.ids).split(',').map(s => Number(s.trim())).filter(Number.isFinite);
        const pruned = cachedIds.filter(id => avail.has(id));

        // If nothing changed, bail
        if (pruned.length === cachedIds.length) return;

        // Recompute primary to a valid one
        const primary = avail.has(Number(entry.primary)) ? Number(entry.primary) : (pruned[0] ?? null);

        // Write back the pruned cache (preserving ttl if present)
        window.__planCacheTTL.write(pruned, primary, Number(entry.ttl)||undefined);
      } catch(_){}
    }, false);
  })();

  /* ANCHOR: EVENT_SCHEMA_GUARD */
  (function installEventSchemaGuard(){
    const EVT = 'rateplans:changed';
    const DEV = !/^(prod|production)$/i.test(String(window.__env||'')) && location.hostname !== 'lolaelo.com';

    function numify(v){ const n = Number(v); return Number.isFinite(n) ? n : null; }

    function normalize(detail){
      // Accept: undefined | string "1,6" | number[] | object { ids, primary, source }
      let ids = [];
      let primary = null;
      let source = '';

      if (detail == null) {
        // noop
      } else if (Array.isArray(detail)) {
        ids = detail;
      } else if (typeof detail === 'string') {
        ids = detail.split(',').map(s=>Number(s.trim()));
      } else if (typeof detail === 'object') {
        if (Array.isArray(detail.ids)) ids = detail.ids;
        else if (typeof detail.ids === 'string') ids = detail.ids.split(',').map(s=>Number(s.trim()));
        else if (detail.ids == null && typeof detail.primary !== 'undefined') {
          const p = numify(detail.primary);
          if (p != null) ids = [p];
        }
        primary = numify(detail.primary);
        source = String(detail.source || '');
      }

      ids = ids.map(Number).filter(Number.isFinite);
      if (primary == null && ids.length) primary = ids[0];
      if (primary != null && !ids.includes(primary)) ids.unshift(primary);

      return { ids, primary, source };
    }

    // Capture-phase: sanitize/standardize every incoming event before other handlers
    document.addEventListener(EVT, function(e){
      try {
        const norm = normalize(e.detail);
        if (!norm.ids.length) {
          if (DEV) console.warn('[EVENT_SCHEMA_GUARD] Dropping event with empty ids:', e.detail);
          e.stopImmediatePropagation();
          return;
        }
        e.detail = norm; // overwrite with normalized schema
      } catch(err){
        if (DEV) console.error('[EVENT_SCHEMA_GUARD] Error normalizing event:', err);
        e.stopImmediatePropagation();
      }
    }, true);
  })();
  
  /* ANCHOR: PLAN_SELECTION_EPOCH */
  (function installPlanSelectionEpoch(){
    // Global epoch controller
    const EP = { cur: 0, isCurrent(e){ return Number(e) === this.cur; } };
    window.__planEpoch = EP;

    // Capture-phase: stamp every normalized event with a fresh epoch
    document.addEventListener('rateplans:changed', (e) => {
      try {
        // Bump epoch and stamp detail
        EP.cur += 1;
        const epoch = EP.cur;
        if (e.detail && typeof e.detail === 'object') e.detail.epoch = epoch;

        // Surface epoch for debug and to help CSS/tests if needed
        const host = document.getElementById('plans-panel') || document.documentElement;
        host && host.setAttribute('data-plan-epoch', String(epoch));
      } catch(_){}
    }, true); // capture -> runs before other handlers

    // After handlers run: guard against stale DOM application
    document.addEventListener('rateplans:changed', (e) => {
      try {
        const epoch = Number(e?.detail?.epoch);
        if (!Number.isFinite(epoch)) return;

        // Verify DOM reflects the latest epoch within a frame; if not, nudge it once.
        requestAnimationFrame(() => {
          // If another newer change happened in the meantime, bail.
          if (!EP.isCurrent(epoch)) return;

          // Build DOM signature
          const nodes = document.querySelectorAll('[data-plan-id].selected, input[name="rateplan"]:checked, input[data-plan-id]:checked');
          const have = Array.from(nodes).map(n => Number(n.getAttribute('data-plan-id') || n.value))
                            .filter(Number.isFinite).sort((a,b)=>a-b).join(',');

          const wantArr = Array.isArray(e?.detail?.ids) ? e.detail.ids.map(Number).filter(Number.isFinite).sort((a,b)=>a-b) : [];
          const want = wantArr.join(',');

          if (want && have !== want) {
            const rid = Number(window.currentRoomTypeId);
            // Use whichever applier is available (our wrapper or fallback)
            if (Number.isFinite(rid) && typeof window.setRoomPlanSelection === 'function') {
              try { window.setRoomPlanSelection(rid, wantArr); } catch(_){}
            }
          }
        });
      } catch(_){}
    }, false);

    // Tag outgoing prices requests with the epoch (helps diagnostics & cache separation if needed)
    document.addEventListener('net:request', (e) => {
      try {
        const key = String(e?.detail?.key || '');
        if (!key.startsWith('GET /api/prices')) return;
        // Reflect latest epoch for visibility (request URL already carries sel= from the price guard)
        const host = document.getElementById('plans-panel') || document.documentElement;
        host && host.setAttribute('data-price-epoch', String(EP.cur));
      } catch(_){}
    }, false);
  })();

  /* ANCHOR: PLAN_USER_INTENT_LOCK */
  (function installPlanUserIntentLock(){
    const EVT = 'rateplans:changed';
    const USER_SRC = 'plan-panel-aggregate';     // emitted by our aggregator on real user input
    const RESTORE_PREFIXES = ['plan-cache-', 'history-', 'plan-url-sync', 'idle-', 'plan-reassert-'];
    const LOCK_MS = 1200;

    let until = 0;

    function isRestoreSource(src){
      const s = String(src||'');
      return RESTORE_PREFIXES.some(p => s.startsWith(p));
    }

    // When the user changes selection, start a brief lock window
    document.addEventListener(EVT, (e) => {
      try {
        if ((e?.detail?.source||'') === USER_SRC) {
          until = Date.now() + LOCK_MS;
        }
      } catch(_){}
    }, false);

    // Capture-phase gate: drop restore events during the lock window
    document.addEventListener(EVT, (e) => {
      try {
        const src = e?.detail?.source || '';
        if (Date.now() < until && isRestoreSource(src)) {
          // Ignore late restores that would overwrite the user's fresh choice
          e.stopImmediatePropagation();
        }
      } catch(_){}
    }, true); // capture
  })();

  /* ANCHOR: EMIT_RATEPLANS_CHANGED_HELPER */
  (function installEmitHelper(){
    function emitRateplansChanged(ids, primary=null, source=''){
      try {
        const arr = Array.isArray(ids)
          ? ids
          : (typeof ids === 'string' ? ids.split(',') : []);
        const normIds = arr.map(n=>Number(n)).filter(Number.isFinite);
        const p = Number.isFinite(Number(primary)) ? Number(primary) : (normIds[0] ?? null);
        const detail = { ids: normIds, primary: p, source: String(source||'manual') };
        document.dispatchEvent(new CustomEvent('rateplans:changed', { detail }));
      } catch(_){}
    }
    window.emitRateplansChanged = emitRateplansChanged;
  })();
  
  /* ANCHOR: PLAN_REASSERT_AFTER_RESTORE */
  (function installPlanReassert(){
    const EVT = 'rateplans:changed';
    const RESTORE_PREFIXES = ['plan-cache-', 'history-', 'plan-url-sync', 'idle-'];

    let reassert = { sig: '', timers: [] };

    function sigFromIds(ids){
      return (Array.isArray(ids) ? ids.slice().sort((a,b)=>a-b) : []).join(',');
    }

    function currentDomSig(){
      const nodes = document.querySelectorAll('[data-plan-id].selected, input[name="rateplan"]:checked, input[data-plan-id]:checked');
      const ids = Array.from(nodes)
        .map(n => Number(n.getAttribute('data-plan-id') || n.value))
        .filter(Number.isFinite)
        .sort((a,b)=>a-b);
      return ids.join(',');
    }

    function cancelTimers(){
      reassert.timers.forEach(t => clearTimeout(t));
      reassert = { sig: '', timers: [] };
    }

    function scheduleReassert(ids, primary){
      cancelTimers();
      const sig = sigFromIds(ids);
      reassert.sig = sig;

      function maybeReassert(tag){
        try {
          // If user already changed selection, or DOM already matches, skip
          if (currentDomSig() === sig) return;
          if (typeof window.emitRateplansChanged === 'function') {
            window.emitRateplansChanged(ids, primary, tag);
          } else {
            document.dispatchEvent(new CustomEvent(EVT, { detail: { ids, primary, source: tag } }));
          }
        } catch(_){}
      }

      // Avoid our 500ms burst guard; pick 600ms and 1200ms
      reassert.timers.push(setTimeout(() => maybeReassert('plan-reassert-600'), 600));
      reassert.timers.push(setTimeout(() => maybeReassert('plan-reassert-1200'), 1200));
    }

    // Start reassert only for non-user restore sources
    document.addEventListener(EVT, (e) => {
      try {
        const ids = Array.isArray(e?.detail?.ids) ? e.detail.ids : [];
        const primary = Number.isFinite(Number(e?.detail?.primary)) ? Number(e.detail.primary) : (ids[0] ?? null);
        const src = String(e?.detail?.source || '');
        const isRestore = RESTORE_PREFIXES.some(p => src.startsWith(p));
        if (isRestore && ids.length) {
          scheduleReassert(ids, primary);
        }
        // If the user changes plans, cancel any pending reasserts
        if (src === 'plan-panel-aggregate') cancelTimers();
      } catch(_){}
    }, false);
  })();

  /* ANCHOR: PLAN_REASSERT_AFTER_USER */
  (function installPlanUserReassert(){
    const EVT = 'rateplans:changed';
    const USER_SRC = 'plan-panel-aggregate'; // emitted by our aggregator on real user input

    let timer = null;
    let sigTarget = '';

    function sigOfIds(ids){
      return (Array.isArray(ids) ? ids.slice().sort((a,b)=>a-b) : []).join(',');
    }
    function currentDomSig(){
      const nodes = document.querySelectorAll('[data-plan-id].selected, input[name="rateplan"]:checked, input[data-plan-id]:checked');
      const ids = Array.from(nodes)
        .map(n => Number(n.getAttribute('data-plan-id') || n.value))
        .filter(Number.isFinite)
        .sort((a,b)=>a-b);
      return ids.join(',');
    }
    function scheduleVerify(ids, primary){
      clearTimeout(timer);
      sigTarget = sigOfIds(ids);
      timer = setTimeout(() => {
        timer = null;
        // If DOM lost the user's selection (e.g., late re-render), reassert once
        if (!sigTarget || currentDomSig() === sigTarget) return;
        try {
          if (typeof window.emitRateplansChanged === 'function') {
            window.emitRateplansChanged(ids, primary, 'plan-user-reassert-500');
          } else {
            document.dispatchEvent(new CustomEvent(EVT, { detail: { ids, primary, source: 'plan-user-reassert-500' } }));
          }
        } catch(_){}
      }, 500);
    }

    // Start a one-off verify after genuine user input
    document.addEventListener(EVT, (e) => {
      try {
        const src = String(e?.detail?.source || '');
        if (src !== USER_SRC) return;
        const ids = Array.isArray(e?.detail?.ids) ? e.detail.ids.map(Number).filter(Number.isFinite) : [];
        if (!ids.length) return;
        const primary = Number.isFinite(Number(e?.detail?.primary)) ? Number(e.detail.primary) : ids[0];
        scheduleVerify(ids, primary);
      } catch(_){}
    }, false);

    // Any subsequent change cancels the pending verify
    document.addEventListener(EVT, () => { clearTimeout(timer); timer = null; sigTarget = ''; }, true);
  })();

  /* ANCHOR: PLAN_HISTORY_SYNC */
  (function planHistorySync(){
    const EVT = 'rateplans:changed';

    function normIds(ids){
      return (Array.isArray(ids) ? ids : [])
        .map(n => Number(n))
        .filter(Number.isFinite)
        .sort((a,b)=>a-b);
    }

    function readState(){
      try { return history.state && typeof history.state === 'object' ? history.state : {}; }
      catch(_){ return {}; }
    }

    function writeState(ids, primary){
      try {
        const s = readState();
        const next = { ...s, planIds: normIds(ids), planPrimary: Number.isFinite(Number(primary)) ? Number(primary) : (normIds(ids)[0] ?? null) };
        history.replaceState(next, document.title, location.href);
      } catch(_){}
    }

    function currentDomSelection(){
      const nodes = document.querySelectorAll('[data-plan-id].selected, input[name="rateplan"]:checked, input[data-plan-id]:checked');
      const ids = Array.from(nodes)
        .map(n => Number(n.getAttribute('data-plan-id') || n.value))
        .filter(Number.isFinite);
      const primary = ids.length ? ids[0] : (Number.isFinite(window.currentRatePlanId) ? Number(window.currentRatePlanId) : null);
      return { ids: normIds(ids.length ? ids : (Array.isArray(window.currentRatePlanIds) ? window.currentRatePlanIds : [])), primary };
    }

    // Persist to history on changes (debounced to avoid spam)
    let t = null;
    document.addEventListener(EVT, (e) => {
      try {
        const ids = Array.isArray(e?.detail?.ids) ? e.detail.ids : [];
        const primary = Number(e?.detail?.primary);
        if (t) clearTimeout(t);
        t = setTimeout(() => { writeState(ids, primary); }, 120);
      } catch(_){}
    }, false);

    // Try restoring from history.state if it disagrees with DOM
    function tryRestoreFromHistory(source){
      try {
        const s = readState();
        const stIds = normIds(s.planIds || []);
        if (!stIds.length) return false;

        const dom = currentDomSelection();
        const domKey = dom.ids.join(',');
        const stKey  = stIds.join(',');

        if (domKey !== stKey) {
          const p = Number.isFinite(Number(s.planPrimary)) ? Number(s.planPrimary) : stIds[0];
          if (typeof window.emitRateplansChanged === 'function') {
            window.emitRateplansChanged(stIds, p, source);
          } else {
            document.dispatchEvent(new CustomEvent(EVT, { detail: { ids: stIds, primary: p, source } }));
          }
          return true;
        }
      } catch(_){}
      return false;
    }

    // Restore on back/forward
    window.addEventListener('popstate', () => { tryRestoreFromHistory('history-popstate'); }, { capture: true });

    // Restore on BFCache/tab restore
    window.addEventListener('pageshow', (ev) => {
      if (ev && ev.persisted) {
        tryRestoreFromHistory('history-pageshow');
      }
    }, { capture: true });
  })();

  /* ANCHOR: PLAN_URL_SYNC */
  (function planUrlSync(){
    const EVT = 'rateplans:changed';

    function normIds(ids){
      return (Array.isArray(ids) ? ids : [])
        .map(n => Number(n))
        .filter(Number.isFinite)
        .sort((a,b)=>a-b);
    }

    function readPlansFromURL(){
      try {
        const sp = new URLSearchParams(location.search);
        const raw = sp.get('plans') || sp.get('plan') || '';
        const arr = raw.split(',').map(s => Number(s.trim())).filter(Number.isFinite);
        return normIds(arr);
      } catch(_){ return []; }
    }

    function writePlansToURL(ids){
      try {
        const sp = new URLSearchParams(location.search);
        const val = normIds(ids).join(',');
        if (!val) { sp.delete('plans'); sp.delete('plan'); }
        else { sp.set('plans', val); sp.delete('plan'); }
        history.replaceState(history.state || {}, document.title, location.pathname + '?' + sp.toString());
      } catch(_){}
    }

    // On load: if URL carries plans and DOM has none yet, and IDs exist, emit once
    (function tryUrlBootstrap(){
      try {
        const fromURL = readPlansFromURL();
        if (!fromURL.length) return;

        // Skip if DOM already has a selection
        const hasDom = !!document.querySelector('[data-plan-id].selected, input[name="rateplan"]:checked, input[data-plan-id]:checked');
        if (hasDom) return;

        // Only restore if these IDs exist in the current DOM (scope safety)
        if (typeof window.__planCacheTTL?._idsExistInDOM === 'function' && !window.__planCacheTTL._idsExistInDOM(fromURL)) {
          return;
        }

        const primary = fromURL[0];
        if (typeof window.emitRateplansChanged === 'function') {
          window.emitRateplansChanged(fromURL, primary, 'plan-url-sync');
        } else {
          document.dispatchEvent(new CustomEvent(EVT, { detail: { ids: fromURL, primary, source: 'plan-url-sync' } }));
        }
      } catch(_){}
    })();

    // Keep URL in sync on changes (debounced)
    let t = null;
    document.addEventListener(EVT, (e) => {
      try {
        const ids = Array.isArray(e?.detail?.ids) ? e.detail.ids : [];
        if (t) clearTimeout(t);
        t = setTimeout(() => writePlansToURL(ids), 120);
      } catch(_){}
    }, false);
  })();

  /* ANCHOR: PLAN_DIAG_PROBE */
  (function installPlanDiagProbe(){
    function domSelection(){
      const nodes = document.querySelectorAll('[data-plan-id].selected, input[name="rateplan"]:checked, input[data-plan-id]:checked');
      const ids = Array.from(nodes).map(n => Number(n.getAttribute('data-plan-id') || n.value)).filter(Number.isFinite).sort((a,b)=>a-b);
      return { ids, primary: ids[0] ?? null };
    }

    function cacheSelection(){
      try {
        const entry = window.__planCacheTTL?.read?.();
        if (!entry) return { ids: [], primary: null, raw: null, fresh: false, scopedKey: 'n/a' };
        const ids = String(entry.ids||'').split(',').map(s=>Number(s.trim())).filter(Number.isFinite).sort((a,b)=>a-b);
        const key = (() => {
          // expose which scoped LS key we’re on
          const prop = Number(window.currentPropertyId) || Number(new URLSearchParams(location.search).get('propertyId')) || 0;
          const room = Number(window.currentRoomTypeId) || 0;
          return `rateplan.cache.v2::p${prop}::r${room}`;
        })();
        return {
          ids,
          primary: Number.isFinite(Number(entry.primary)) ? Number(entry.primary) : (ids[0] ?? null),
          raw: entry,
          fresh: !!window.__planCacheTTL?.isFresh?.(entry),
          scopedKey: key
        };
      } catch { return { ids: [], primary: null, raw: null, fresh: false, scopedKey: 'err' }; }
    }

    function historySelection(){
      try {
        const s = (history.state && typeof history.state === 'object') ? history.state : {};
        const ids = Array.isArray(s.planIds) ? s.planIds.map(Number).filter(Number.isFinite).sort((a,b)=>a-b) : [];
        const primary = Number.isFinite(Number(s.planPrimary)) ? Number(s.planPrimary) : (ids[0] ?? null);
        return { ids, primary, raw: s };
      } catch { return { ids: [], primary: null, raw: null }; }
    }

    function urlSelection(){
      try {
        const sp = new URLSearchParams(location.search);
        const raw = sp.get('plans') || sp.get('plan') || '';
        const ids = raw.split(',').map(s=>Number(s.trim())).filter(Number.isFinite).sort((a,b)=>a-b);
        return { ids, primary: ids[0] ?? null, query: raw };
      } catch { return { ids: [], primary: null, query: '' }; }
    }

    function globalsSelection(){
      const ids = Array.isArray(window.currentRatePlanIds) ? window.currentRatePlanIds.map(Number).filter(Number.isFinite).sort((a,b)=>a-b) : [];
      const primary = Number.isFinite(Number(window.currentRatePlanId)) ? Number(window.currentRatePlanId) : (ids[0] ?? null);
      return { ids, primary };
    }

    function rateplanProbe(){
      const out = {
        DOM: domSelection(),
        CACHE: cacheSelection(),
        HISTORY: historySelection(),
        URL: urlSelection(),
        GLOBALS: globalsSelection()
      };
      try { console.table?.(out); } catch { console.log(out); }
      return out;
    }

    window.rateplanProbe = rateplanProbe;
  })();

  /* ANCHOR: PLAN_DEBUG_NUKE */
  (function installRateplanNuke(){
    function rateplanNuke(){
      try {
        // 1) Clear DOM selection
        const nodes = document.querySelectorAll(
          '[data-plan-id].selected, input[name="rateplan"]:checked, input[data-plan-id]:checked'
        );
        nodes.forEach(n => {
          if (n.matches('input[type="checkbox"], input[type="radio"]')) n.checked = false;
          n.classList && n.classList.remove('selected');
        });

        // 2) Clear globals
        delete window.currentRatePlanId;
        window.currentRatePlanIds = [];

        // 3) Clear URL params
        try {
          const sp = new URLSearchParams(location.search);
          sp.delete('plans'); sp.delete('plan');
          history.replaceState(history.state || {}, document.title, location.pathname + (sp.toString() ? '?' + sp.toString() : ''));
        } catch(_){}

        // 4) Clear history bits
        try {
          const s = (history.state && typeof history.state === 'object') ? history.state : {};
          delete s.planIds; delete s.planPrimary;
          history.replaceState(s, document.title, location.href);
        } catch(_){}

        // 5) Clear scoped LS cache for current scope
        try {
          const prop = Number(window.currentPropertyId) || Number(new URLSearchParams(location.search).get('propertyId')) || 0;
          const room = Number(window.currentRoomTypeId) || 0;
          const scoped = `rateplan.cache.v2::p${prop}::r${room}`;
          localStorage.removeItem(scoped);
        } catch(_){}

        // 6) Emit a single normalized empty-change (optional no-op): we skip to avoid handlers expecting ids
        console.warn('[rateplanNuke] Cleared DOM, globals, URL, history, and scoped cache.');
      } catch(err){
        console.error('[rateplanNuke] error:', err);
      }
    }
    window.rateplanNuke = rateplanNuke;
  })();

  /* ANCHOR: PLAN_IDLE_RECONCILE */
  (function installPlanIdleReconcile(){
    const EVT = 'rateplans:changed';

    function hasDomSelection(){
      return !!document.querySelector('[data-plan-id].selected, input[name="rateplan"]:checked, input[data-plan-id]:checked');
    }
    function normIds(ids){
      return (Array.isArray(ids) ? ids : []).map(n=>Number(n)).filter(Number.isFinite).sort((a,b)=>a-b);
    }
    function readFromURL(){
      try {
        const sp = new URLSearchParams(location.search);
        const raw = sp.get('plans') || sp.get('plan') || '';
        return normIds(raw.split(',').map(s=>Number(s.trim())));
      } catch(_){ return []; }
    }
    function readFromHistory(){
      try {
        const s = (history.state && typeof history.state === 'object') ? history.state : {};
        return normIds(Array.isArray(s.planIds)? s.planIds : []);
      } catch(_){ return []; }
    }
    function readFromCache(){
      try {
        const entry = window.__planCacheTTL?.read?.();
        if (!window.__planCacheTTL?.isFresh?.(entry) || !entry) return [];
        return normIds(String(entry.ids||'').split(',').map(s=>Number(s.trim())));
      } catch(_){ return []; }
    }
    function readFromGlobals(){
      try {
        const arr = Array.isArray(window.currentRatePlanIds) ? window.currentRatePlanIds : (Number.isFinite(window.currentRatePlanId) ? [window.currentRatePlanId] : []);
        return normIds(arr);
      } catch(_){ return []; }
    }
    function idsExist(ids){
      if (typeof window.__planCacheTTL?._idsExistInDOM === 'function') {
        return window.__planCacheTTL._idsExistInDOM(ids);
      }
      // fallback: any plan node matching?
      const set = new Set(ids.map(String));
      const nodes = document.querySelectorAll('[data-plan-id], input[data-plan-id], input[name="rateplan"]');
      for (const n of nodes) {
        const pid = n.getAttribute('data-plan-id') || n.value;
        if (pid != null && set.has(String(Number(pid)))) return true;
      }
      return false;
    }

    function pickSource(){
      const url = readFromURL();          if (url.length && idsExist(url)) return { ids: url, source: 'idle-url' };
      const hist = readFromHistory();     if (hist.length && idsExist(hist)) return { ids: hist, source: 'idle-history' };
      const cach = readFromCache();       if (cach.length && idsExist(cach)) return { ids: cach, source: 'idle-cache' };
      const glob = readFromGlobals();     if (glob.length && idsExist(glob)) return { ids: glob, source: 'idle-globals' };
      return null;
    }

    let ran = false;
    function reconcileOnce(){
      if (ran) return; ran = true;
      if (hasDomSelection()) return;
      const pick = pickSource();
      if (!pick) return;

      const primary = pick.ids[0];
      try {
        if (typeof window.emitRateplansChanged === 'function') {
          window.emitRateplansChanged(pick.ids, primary, pick.source);
        } else {
          document.dispatchEvent(new CustomEvent(EVT, { detail: { ids: pick.ids, primary, source: pick.source } }));
        }
      } catch(_){}
    }

    // Run after a short idle; also on DOMContentLoaded as a safety
    try {
      if ('requestIdleCallback' in window) {
        requestIdleCallback(() => setTimeout(reconcileOnce, 120), { timeout: 1500 });
      } else {
        setTimeout(reconcileOnce, 300);
      }
    } catch(_) { setTimeout(reconcileOnce, 300); }

    document.addEventListener('DOMContentLoaded', () => setTimeout(reconcileOnce, 150), { once: true });
  })();
  
  /* ANCHOR: PLAN_RESTORE_ON_VISIBLE */
  (function restorePlansOnVisible(){
    const EVT = 'rateplans:changed';

    function hasDomSelection(){
      return !!document.querySelector('[data-plan-id].selected, input[name="rateplan"]:checked, input[data-plan-id]:checked');
    }
    function normIds(ids){
      return (Array.isArray(ids) ? ids : [])
        .map(n=>Number(n))
        .filter(Number.isFinite)
        .sort((a,b)=>a-b);
    }
    function idsExist(ids){
      try {
        if (typeof window.__planCacheTTL?._idsExistInDOM === 'function') {
          return window.__planCacheTTL._idsExistInDOM(ids);
        }
      } catch(_){}
      // fallback: scan DOM
      const set = new Set(ids.map(String));
      const nodes = document.querySelectorAll('[data-plan-id], input[data-plan-id], input[name="rateplan"]');
      for (const n of nodes) {
        const pid = n.getAttribute('data-plan-id') || n.value;
        if (pid != null && set.has(String(Number(pid)))) return true;
      }
      return false;
    }
    function readFromURL(){
      try {
        const sp = new URLSearchParams(location.search);
        const raw = sp.get('plans') || sp.get('plan') || '';
        return normIds(raw.split(',').map(s=>Number(s.trim())));
      } catch(_){ return []; }
    }
    function readFromHistory(){
      try {
        const s = (history.state && typeof history.state === 'object') ? history.state : {};
        return normIds(Array.isArray(s.planIds) ? s.planIds : []);
      } catch(_){ return []; }
    }
    function readFromCache(){
      try {
        const entry = window.__planCacheTTL?.read?.();
        if (!entry || !window.__planCacheTTL?.isFresh?.(entry)) return [];
        return normIds(String(entry.ids||'').split(',').map(s=>Number(s.trim())));
      } catch(_){ return []; }
    }
    function emit(ids, primary, source){
      try {
        if (typeof window.emitRateplansChanged === 'function') {
          window.emitRateplansChanged(ids, primary, source);
        } else {
          document.dispatchEvent(new CustomEvent(EVT, { detail: { ids, primary, source } }));
        }
      } catch(_){}
    }

    // Fire when tab becomes visible again
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState !== 'visible') return;
      // Only restore if nothing is selected yet
      if (hasDomSelection()) return;

      // Prefer URL → History → Cache, and only if those IDs exist in the current DOM
      const fromURL = readFromURL();
      if (fromURL.length && idsExist(fromURL)) {
        emit(fromURL, fromURL[0], 'plan-visible-url');
        return;
      }

      const fromHist = readFromHistory();
      if (fromHist.length && idsExist(fromHist)) {
        emit(fromHist, fromHist[0], 'plan-visible-history');
        return;
      }

      const fromCache = readFromCache();
      if (fromCache.length && idsExist(fromCache)) {
        emit(fromCache, fromCache[0], 'plan-visible-cache');
        return;
      }
    }, { capture: true });
  })();

  /* ANCHOR: NET_CANCEL_ON_EVENT */
  (function wireCancelOnRateplanChange(){
    // Cancel any in-flight calls that are tied to price/plan loads when plan changes
    document.addEventListener('rateplans:changed', () => {
      if (window.__singleFlight && window.__singleFlight.cancelByPrefix) {
        // Prefixes should match the normalized keys you use below (method + path)
        window.__singleFlight.cancelByPrefix('GET /api/prices');
        window.__singleFlight.cancelByPrefix('GET /api/rateplans');
      }
    }, false);
  })();

  /* ANCHOR: DOM_STATE_GUARDS */
  (function installDomStateGuards(){
    // Track last applied plan-ids per room to skip no-op updates
    const lastAppliedByRoom = new Map(); // roomTypeId:number -> "idsKey" (e.g., "1,6")

    function normalizeIds(ids){
      return (Array.isArray(ids) ? ids : [])
        .map(n => Number(n))
        .filter(Number.isFinite)
        .sort((a,b)=>a-b)
        .join(',');
    }

    // Batches DOM updates to next frame to avoid layout thrash
    let rafToken = null;
    let pendingApply = null;

    function scheduleApply(fn){
      pendingApply = fn;
      if (rafToken != null) return;
      rafToken = requestAnimationFrame(() => {
        const f = pendingApply;
        pendingApply = null;
        rafToken = null;
        try { f && f(); } catch(_){}
      });
    }

    // Public helper your handler can call
    function applyRateplanSelection(roomTypeId, ids){
      const idsKey = normalizeIds(ids);
      const prevKey = lastAppliedByRoom.get(roomTypeId);
      if (idsKey === prevKey) return; // no change, skip

      scheduleApply(() => {
        try {
          if (typeof setRoomPlanSelection === 'function'){
            setRoomPlanSelection(roomTypeId, ids);
          }
          lastAppliedByRoom.set(roomTypeId, idsKey);
          try { updateURLFromState?.(); } catch(_){}
        } catch(_){}
      });
    }

    // Expose for reuse
    window.__domGuards = {
      applyRateplanSelection,
      _lastAppliedByRoom: lastAppliedByRoom
    };
  })();

  /* ANCHOR: PLAN_APPLY_DOM_FALLBACK */
  (function installPlanApplyDomFallback(){
    // Low-level DOM applier (used only if setRoomPlanSelection is absent)
    function applyPlansDirectToDom(roomTypeId, ids){
      try {
        const set = new Set((Array.isArray(ids)? ids: []).map(n=>Number(n)).filter(Number.isFinite));
        const scope = document.getElementById('plans-panel') || document;

        // Uncheck / unselect everything first (scoped)
        scope.querySelectorAll('input[name="rateplan"], input[data-plan-id]').forEach(inp => {
          if (inp.type === 'checkbox' || inp.type === 'radio') inp.checked = false;
        });
        scope.querySelectorAll('[data-plan-id].selected').forEach(n => n.classList.remove('selected'));

        // Apply selection
        scope.querySelectorAll('[data-plan-id], input[data-plan-id], input[name="rateplan"]').forEach(n => {
          const pid = Number(n.getAttribute('data-plan-id') || n.value);
          if (!Number.isFinite(pid)) return;
          if (set.has(pid)) {
            if (n.matches('input[type="checkbox"], input[type="radio"]')) n.checked = true;
            const host = n.closest('[data-plan-id]') || n;
            host.classList && host.classList.add('selected');
          }
        });
      } catch(_){}
    }

    // If the page hasn't provided setRoomPlanSelection, install a safe fallback.
    if (typeof window.setRoomPlanSelection !== 'function') {
      window.setRoomPlanSelection = function(roomTypeId, ids){
        // Defer to next frame to avoid fighting other handlers
        try { requestAnimationFrame(() => applyPlansDirectToDom(roomTypeId, ids)); }
        catch(_) { setTimeout(() => applyPlansDirectToDom(roomTypeId, ids), 0); }
      };
    } else {
      // Wrap existing to add a verification pass if DOM didn't reflect selection
      const original = window.setRoomPlanSelection;
      window.setRoomPlanSelection = function(roomTypeId, ids){
        try { original(roomTypeId, ids); } catch(_){}
        // If DOM still doesn't show selection, apply minimal corrective pass
        try {
          const want = (Array.isArray(ids)? ids: []).map(Number).filter(Number.isFinite).sort((a,b)=>a-b).join(',');
          const nodes = document.querySelectorAll('[data-plan-id].selected, input[name="rateplan"]:checked, input[data-plan-id]:checked');
          const have = Array.from(nodes).map(n => Number(n.getAttribute('data-plan-id') || n.value))
                            .filter(Number.isFinite).sort((a,b)=>a-b).join(',');
          if (want && have !== want) {
            requestAnimationFrame(() => applyPlansDirectToDom(roomTypeId, ids));
          }
        } catch(_){}
      };
    }
  })();

  /* ANCHOR: PLAN_PANEL_CHANGE_AGGREGATOR */
  (function installPlanPanelChangeAggregator(){
    const PANEL = document.getElementById('plans-panel') || document.body;

    // Track last emitted ids signature to avoid duplicate emits
    let lastSig = '';
    let timer = null;

    function collectIdsFromPanel(){
      const nodes = (document.getElementById('plans-panel') || document).querySelectorAll(
        '[data-plan-id].selected, input[name="rateplan"]:checked, input[data-plan-id]:checked'
      );
      const ids = Array.from(nodes)
        .map(n => Number(n.getAttribute('data-plan-id') || n.value))
        .filter(Number.isFinite)
        .sort((a,b)=>a-b);
      return ids;
    }

    function emitIfChanged(sourceTag){
      const ids = collectIdsFromPanel();
      const sig = ids.join(',');
      if (sig === lastSig || !ids.length) return; // no change or nothing selected
      lastSig = sig;

      const primary = ids[0];
      if (typeof window.emitRateplansChanged === 'function') {
        window.emitRateplansChanged(ids, primary, sourceTag);
      } else {
        document.dispatchEvent(new CustomEvent('rateplans:changed', {
          detail: { ids, primary, source: sourceTag }
        }));
      }
    }

    function scheduleEmit(){
      if (timer) return;
      timer = setTimeout(() => { timer = null; emitIfChanged('plan-panel-aggregate'); }, 80);
    }

    // Listen to both change and click (supports chips and checkboxes)
    try {
      PANEL.addEventListener('change', (ev) => {
        const t = ev.target;
        if (!t) return;
        if (t.matches('[data-plan-id], [name="rateplan"]')) scheduleEmit();
      }, true);

      PANEL.addEventListener('click', (ev) => {
        const t = ev.target;
        if (!t) return;
        if (t.closest && t.closest('[data-plan-id]')) scheduleEmit();
      }, true);
    } catch(_){}

    // Reset dedupe signature when a normalized event comes from elsewhere
    document.addEventListener('rateplans:changed', (e) => {
      try {
        const ids = Array.isArray(e?.detail?.ids) ? e.detail.ids : [];
        lastSig = ids.slice().sort((a,b)=>a-b).join(',');
      } catch(_){}
    }, false);
  })();

  /* ANCHOR: PLAN_BOOTSTRAP_FROM_DOM */
  (function bootstrapPlansFromDomOnce(){
    const EVT = 'rateplans:changed';
    let ran = false;

    function collectDomIds(){
      const nodes = document.querySelectorAll('[data-plan-id].selected, input[name="rateplan"]:checked, input[data-plan-id]:checked');
      return Array.from(nodes)
        .map(n => Number(n.getAttribute('data-plan-id') || n.value))
        .filter(Number.isFinite)
        .sort((a,b)=>a-b);
    }

    function currentSig(){ return (Array.isArray(window.currentRatePlanIds) ? window.currentRatePlanIds.slice().sort((a,b)=>a-b) : []).join(','); }
    function domSig(){ return collectDomIds().join(','); }

    function emit(ids, primary, source){
      if (typeof window.emitRateplansChanged === 'function') {
        window.emitRateplansChanged(ids, primary, source);
      } else {
        document.dispatchEvent(new CustomEvent(EVT, { detail: { ids, primary, source } }));
      }
    }

    function run(){
      if (ran) return; ran = true;
      const ids = collectDomIds();
      if (!ids.length) return;

      // If globals already match DOM, do nothing
      if (currentSig() === ids.join(',')) return;

      const primary = ids[0];
      emit(ids, primary, 'plan-bootstrap-dom');
    }

    // Try on next frame and on DOMContentLoaded (whichever fires effectively first)
    try {
      requestAnimationFrame(() => setTimeout(run, 50));
    } catch(_) { setTimeout(run, 80); }

    document.addEventListener('DOMContentLoaded', () => setTimeout(run, 80), { once: true });
  })();

  // Persist the current room's chip selection whenever it changes (bubble phase)
  document.addEventListener('rateplans:changed', (e) => {
    try {
      const ids = Array.isArray(e?.detail?.ids) ? e.detail.ids : [];
      const rid = Number(window.currentRoomTypeId);
      if (Number.isFinite(rid) && window.__domGuards?.applyRateplanSelection) {
        window.__domGuards.applyRateplanSelection(rid, ids);
      }
    } catch(_){}
  });

    let currentRoomTypeId = null;
    let currentRangeStart = null, currentRangeEnd = null;

    // Reason/note for rate plan load outcome (used for UI messaging)
    let lastRatePlanLoadNote = '';

    let busy = false;
    window.addEventListener('beforeunload', function(e){
      if (pendingRoomUpdates.size > 0 || dirty.size > 0){
        e.preventDefault();
        e.returnValue = '';
      }
    });

  const pendingRoomUpdates = new Map(); // roomId -> payload
  const readOnlyRoomField = new Map();  // roomId -> true

  // ANCHOR: ROOM_INFO_STATE
  const ROOM_INFO_LS_KEY = "extranet_roomInfo_v1";
  const SQM_TO_SQFT = 10.7639;

  function loadRoomInfoMap(){
    try{
      const raw = localStorage.getItem(ROOM_INFO_LS_KEY);
      if (!raw) return {};
      const obj = JSON.parse(raw);
      return (obj && typeof obj === "object") ? obj : {};
    }catch(_){
      return {};
    }
  }

  function saveRoomInfoMap(map){
    try{
      localStorage.setItem(ROOM_INFO_LS_KEY, JSON.stringify(map));
    }catch(_){}
  }

  // roomId -> { summary, details, inclusions, sizeSqm, sizeSqft }
  let roomInfoById = loadRoomInfoMap();

  function syncRoomSizeFields(source){
    const sqmEl  = el('edit-room-size-sqm');
    const sqftEl = el('edit-room-size-sqft');
    if (!sqmEl || !sqftEl) return;

    const rawSqm  = (sqmEl.value || '').replace(/,/g,'').trim();
    const rawSqft = (sqftEl.value || '').replace(/,/g,'').trim();

    if (source === 'sqm'){
      const v = parseFloat(rawSqm);
      if (!Number.isFinite(v)) return;
      const ft = v * SQM_TO_SQFT;
      sqftEl.value = String(Math.round(ft));
    } else if (source === 'sqft'){
      const v = parseFloat(rawSqft);
      if (!Number.isFinite(v)) return;
      const m = v / SQM_TO_SQFT;
      sqmEl.value = String(Math.round(m));
    }
  }

  const clamp = (v,min,max)=>Math.min(Math.max(v,min),max);
  const toNumber = (v) => {
    if (v === null || v === undefined || v === "") return NaN;
    const n = Number(String(v).replace(/[^0-9.-]/g, ""));
    return Number.isFinite(n) ? n : NaN;
  };
  const fmtUSD = (v) => { const n = toNumber(v); if (!Number.isFinite(n)) return ""; return "$" + n.toFixed(2); };
  const iso = (d)=>d.toISOString().slice(0,10);
  const todayISO = ()=>iso(new Date());
  const API_BASE = (location.origin.includes('lolaelo-api.onrender.com') ? '' : 'https://lolaelo-api.onrender.com');

  /* ANCHOR: CTX_HELPERS */
  const LS_CTX = 'rooms_ctx_v1';
  function saveCtx(){
    try{
      localStorage.setItem(LS_CTX, JSON.stringify({
        roomId: currentRoomTypeId,
        start: currentRangeStart,
        end:   currentRangeEnd,
        ratePlanId: currentRatePlanId
      }));
    }catch(_){}
  }
  function loadCtx(){
    try{
      const raw = localStorage.getItem(LS_CTX);
      if (!raw) return null;
      const j = JSON.parse(raw);
      return (j && typeof j === 'object') ? j : null;
    }catch(_){ return null; }
  }
  function startOfWeek(dt, weekStart=WEEK_START){
    const d=new Date(dt.getFullYear(),dt.getMonth(),dt.getDate());
    const diff=(d.getDay()-weekStart+7)%7; d.setDate(d.getDate()-diff); d.setHours(0,0,0,0); return d;
  }
  function addWeeks(dt,n){ const d=new Date(dt.getFullYear(),dt.getMonth(),dt.getDate()); d.setDate(d.getDate()+n*7); return d; }
  function monthLabel(dt){ return dt.toLocaleString(undefined,{month:"short",year:"numeric"}); }
  function computeWindowFromAnchor(){
    const base=currentAnchor??new Date();
    const start=startOfWeek(base);
    const end=new Date(addWeeks(start,visibleWeeks).getTime()-86400000);
    return { startISO: iso(start), endISO: iso(end) };
  }
  function setMonthLabel(){
    const lbl=el("month-label");
    const rs=(typeof currentRangeStart==="string"&&currentRangeStart)?currentRangeStart:iso(currentAnchor??new Date());
    const start=new Date(rs+"T00:00:00Z");
    if (lbl) lbl.textContent=monthLabel(start);
  }
  function applyMonthWindowToRange({rerender=false}={}){
    const {startISO,endISO}=computeWindowFromAnchor();
    const t=todayISO();
    let s=startISO<t?t:startISO;
    const minDays=(visibleWeeks*7)-1;
    let e=endISO;
    if (e<=s){ const sDate=new Date(s+"T00:00:00Z"); const eDate=new Date(sDate.getTime()+minDays*86400000); e=iso(eDate); }
    const rs=el("range-start"), re=el("range-end");
    if (rs&&re){ rs.value=s; re.value=e; }
    currentAnchor=new Date(s+"T00:00:00Z");
    currentRangeStart=s; currentRangeEnd=e;
    saveCtx();
      if (typeof updateURLFromState==='function') updateURLFromState();
      if (rerender) void renderCalendar();
  }

  /* ANCHOR: DEEPLINK_HELPERS */
  function updateURLFromState(mode='replace'){
  try{
    const url = new URL(location.href);

    // Preserve date & room if present in the UI/state
    const rs = el('range-start'), re = el('range-end');
    const startISO = rs?.value || currentRangeStart || url.searchParams.get('start');
    const endISO   = re?.value || currentRangeEnd   || url.searchParams.get('end');
    const roomId   = (typeof currentRoomTypeId !== 'undefined' && currentRoomTypeId != null)
      ? currentRoomTypeId
      : url.searchParams.get('room');

    if (startISO) url.searchParams.set('start', String(startISO));
    if (endISO)   url.searchParams.set('end',   String(endISO));
    if (roomId != null && roomId !== '') url.searchParams.set('room', String(roomId));

    // === Canonical plan state: prefer ROOM-SCOPED selection, then fallback ===
    let ids = [];
    const rid = Number(roomId ?? window.currentRoomTypeId);

    if (Number.isFinite(rid) && typeof getRoomPlanSelection === 'function') {
      try { ids = getRoomPlanSelection(rid) || []; } catch(_) { ids = []; }
    }

    // Fallback to global chips / legacy storage
    if (!Array.isArray(ids) || !ids.length) {
      ids = Array.isArray(window.__selectedPlanIds) ? window.__selectedPlanIds.slice() : [];
      if (!ids.length) {
        try { ids = JSON.parse(localStorage.getItem('rateplan.selectedIds') || '[]'); } catch(_) { ids = []; }
      }
    }

    // Normalize + choose primary
    ids = (Array.isArray(ids) ? ids.map(n => Number(n)).filter(n => Number.isFinite(n) && n > 0) : []);
    const primary =
      Number.isFinite(Number(window.currentRatePlanId))
        ? Number(window.currentRatePlanId)
        : (() => {
          const stdChip = document.querySelector('#rateplan-checks .chip[data-plan-code="STD"]');
          const stdId = Number(stdChip && stdChip.getAttribute('data-plan-id'));
          return (ids[0] || Number(localStorage.getItem('rateplan.lastPlanId')) || (Number.isFinite(stdId) ? stdId : 1));
        })();
    const planId = Number.isFinite(primary) ? primary : 1;
    if (!ids.length) ids = [planId];

    // Write back canonical values
    url.searchParams.set('plan', String(planId));
    url.searchParams.set('plans', ids.join(','));

    const next = url.pathname + '?' + url.searchParams.toString() + url.hash;
    if (mode === 'push') history.pushState(null, '', next);
    else history.replaceState(null, '', next);
    try { sessionStorage.setItem('rooms:lastURL', next); } catch(_){}
  }catch(_){}
}

  window.updateURLFromState = updateURLFromState;
  
  // NEW: persist the latest canonical URL for this tab on hide/unload
  (function persistCanonicalURLOnHide(){
    function save(){
      try {
        // Only persist if we’re on this rooms page
        if (location.pathname.includes('partners_rooms.html')) {
          sessionStorage.setItem('rooms:lastURL', location.href);
        }
      } catch(_){}
    }
    // Save when the page is hidden or being unloaded (covers hub hops / hard refreshes)
    window.addEventListener('visibilitychange', save, { capture:true });
    window.addEventListener('pagehide',         save, { capture:true });
    window.addEventListener('beforeunload',     save, { capture:true });
  })();

  (function ensureToken(){
    const hashToken = new URLSearchParams(location.hash.slice(1)).get('token');
    if (hashToken) localStorage.setItem('partnerToken', hashToken);
  })();
  const token =
    localStorage.getItem("partnerToken") ||
    localStorage.getItem("lolaelo_session") || "";
  const baseHeaders = { "Content-Type": "application/json" };
  const authHeaders = token
    ? { ...baseHeaders, "Authorization": "Bearer " + token, "x-partner-token": token }
    : baseHeaders;

  /* ANCHOR: AUTH_FETCH */
  function authFetch(url, opts = {}) {
    const finalUrl = (typeof url === 'string' && url.startsWith('/')) ? (API_BASE + url) : url;
    const merged = { ...opts, headers: { ...(opts.headers||{}), ...authHeaders } };
    return fetch(finalUrl, merged).then(async (r) => {
      if (r.status === 401) {
        const hasToken = !!localStorage.getItem('partnerToken');
        setStatus(hasToken ? "Auth failed. Check token or permissions." : "Not signed in.", "warn");
        const s = document.getElementById('status');
        if (s) {
          s.innerHTML = (hasToken
            ? 'Auth failed. <a href="/partners_login.html" style="color:#4f8cff">Open login</a>'
            : 'Not signed in. <a href="/partners_login.html" style="color:#4f8cff">Open login</a>');
        }
      }
      return r;
    });
  }

  /* ANCHOR: FETCH_RETRY_HELPER */
  async function fetchWithRetry(url, opts = {}, attempts = 2, delayMs = 800){
    let lastResp;
    for (let i = 0; i < attempts; i++){
      try{
        const resp = await authFetch(url, opts);
        if (resp.status >= 500 && resp.status < 600){
          lastResp = resp;
          console.warn('Retryable status', resp.status, url);
        } else {
          return resp;
        }
      } catch (err){
        console.warn('Network error, retrying', url, err);
      }
      if (i < attempts - 1) await new Promise(r => setTimeout(r, delayMs));
    }
    return lastResp;
  }

  /* ANCHOR: RATE_PLAN_FETCH */

  // Derive propertyId reliably (URL -> window -> localStorage -> fallback)
  function getRatePlanPropertyId(){
    const qs = new URLSearchParams(location.search);
    const fromUrl = Number(qs.get('propertyId'));
    if (Number.isFinite(fromUrl) && fromUrl > 0) return fromUrl;

    const fromWindow = Number(window.currentPropertyId);
    if (Number.isFinite(fromWindow) && fromWindow > 0) return fromWindow;

    // common existing storage keys we already use elsewhere in your app
    const fromLs =
      Number(localStorage.getItem('checkout.lastPropertyId')) ||
      Number(localStorage.getItem('rooms:lastPropertyId')) ||
      Number(localStorage.getItem('partner.propertyId'));

    if (Number.isFinite(fromLs) && fromLs > 0) return fromLs;

    // final fallback (your test property)
    return 2;
  }

  async function fetchRatePlansSafe(roomTypeId){
    try{
      const rid = Number(roomTypeId);
      const pid = getRatePlanPropertyId();

      if (!Number.isFinite(rid) || rid <= 0){
        throw new Error(`fetchRatePlansSafe: invalid roomTypeId=${roomTypeId}`);
      }

      const url =
        `/extranet/property/rateplans?propertyId=${encodeURIComponent(String(pid))}` +
        `&roomTypeId=${encodeURIComponent(String(rid))}`;

      const r = await authFetch(url, { method:'GET' });
      if (!r.ok) throw new Error('rateplans_fetch_failed_' + r.status);
      const list = await r.json();
      return Array.isArray(list) ? list : [];
    } catch(e){
      console.warn('[RATE_PLAN_FETCH] fallback to Standard only:', e);
      return [{ id: 1, name: 'Standard', code: 'STD', isDefault: true, kind: 'NONE', value: 0, active: true }];
    }
  }

  // Canonical primary plan id for the given room (defaults to current)
  function getCanonicalPrimaryPlanId(roomId){
    const rid = Number(roomId || window.currentRoomTypeId);

    // Valid ids from visible, enabled chips
    const boxes = Array.from(document.querySelectorAll('#rateplan-checks input[type="checkbox"][data-plan-id]'));
    const valid = new Set(boxes.filter(b => !b.disabled).map(b => Number(b.dataset.planId)).filter(Number.isFinite));

    let selected = window.getRoomPlanSelection(rid);
    let plan = selected.find(id => valid.has(id));

    if (!Number.isFinite(plan)){
      plan = valid.has(1) ? 1 : ([...valid][0] || 1);
      const rest = selected.filter(id => id !== plan && valid.has(id));
      window.saveRoomPlanSelection(rid, [plan, ...rest]);
      if (localStorage.getItem('rooms_debug') === '1'){
        console.debug('[plan-fallback] canonicalized per-room fetch plan', { rid, plan });
      }
    }

    window.currentRatePlanId = plan;
    try { localStorage.setItem('rateplan.lastPlanId', String(plan)); } catch(_){}
    try { updateURLFromState?.(); } catch(_){}

    return plan;
  }

  // Build URLs using canonical primary id
  function buildCalendarFetchURLs(roomId, startISO, endISO){
    const ratePlanId = getCanonicalPrimaryPlanId();
    return {
      roomId,
      invUrl: `/extranet/property/rooms/${roomId}/inventory?start=${startISO}&end=${endISO}`,
      prcUrl: `/extranet/property/rooms/${roomId}/prices?start=${startISO}&end=${endISO}&ratePlanId=${ratePlanId}`,
      start: startISO,
      end: endISO
    };
  }

  /* ANCHOR: RATE_PLAN_DROPDOWN_TO_CHECKS (drop-in) */
  function populateRatePlanDropdown(plans){
    const selectedIds = (Array.isArray(window.__selectedPlanIds) ? window.__selectedPlanIds.slice() : []);

    // 1) Render the checkbox chips (new UI)
    try {
      if (typeof populateRatePlanChecks === 'function') {
        populateRatePlanChecks(plans);
      }
    } catch (_) {}

    // 2) Hide (but keep) the legacy <select> for safe rollback
    const sel = document.getElementById('ratePlanSelect');
    if (sel) sel.style.display = 'none';

    // 3) Primary plan = canonical from chips (filters out invalid/hidden ids)
    const primary = (typeof getCanonicalPrimaryPlanId === 'function')
      ? getCanonicalPrimaryPlanId()
      : (Number(localStorage.getItem('rateplan.lastPlanId')) || getCanonicalPrimaryPlanId() || 1);
    window.currentRatePlanId = primary;
    try { localStorage.setItem('rateplan.lastPlanId', String(primary)); } catch(_){}

    // 4) Persist + URL sync + initial refresh
    try { if (typeof saveCtx === 'function') saveCtx(); } catch (_){}
    try { if (typeof updateURLFromState === 'function') updateURLFromState(); } catch (_){}
    if (typeof renderCalendar === 'function') renderCalendar({ reason: 'init:rateplans' });

    // 5) Listen once for future checkbox changes → update state + refresh
    const handler = (e) => {
      const list = (e && e.detail && Array.isArray(e.detail.ids)) ? e.detail.ids : [];
      window.currentRatePlanId = list.length ? Number(list[0]) : (getCanonicalPrimaryPlanId() || 1);
      try { localStorage.setItem('rateplan.lastPlanId', String(window.currentRatePlanId)); } catch(_){}
      try { if (typeof saveCtx === 'function') saveCtx(); } catch (_){}
      try { if (typeof updateURLFromState === 'function') updateURLFromState(); } catch (_){}
      if (typeof renderCalendar === 'function') renderCalendar({ reason: 'rateplans:changed' });
    };

    // idempotent wiring
    if (window.__rateplansChangedHandlerRef) {
      document.removeEventListener('rateplans:changed', window.__rateplansChangedHandlerRef);
    }
    document.addEventListener('rateplans:changed', handler);
    window.__rateplansChangedHandlerRef = handler;
  }

    (function(){
    const LS_KEY_IDS     = 'rateplan.selectedIds';
    const LS_KEY_LABELS  = 'rateplan.customLabels';   // generic label store (no special CUS1/CUS2 behavior)
    const LS_KEY_CODEMAP = 'rateplan.codeToId';       // generic code→id mapping

    // --- Custom label helpers (persisted, generic) ---
    function getCustomLabel(code){
      try {
        const map = JSON.parse(localStorage.getItem(LS_KEY_LABELS) || '{}');
        const v = map && map[code];
        return (v && String(v).trim()) || null;
      } catch(_) { return null; }
    }
    function setCustomLabel(code, name){
      try {
        const map = JSON.parse(localStorage.getItem(LS_KEY_LABELS) || '{}');
        map[code] = String(name || '').trim();
        localStorage.setItem(LS_KEY_LABELS, JSON.stringify(map));
      } catch(_) {}
    }

    // --- Friendly name (no CUS1/CUS2 special cases) ---
    function friendlyPlanName(p){
      const code = String(p.code || '').toUpperCase();
      const raw  = String(p.name || p.code || `Plan ${p.id}`);

      if (p.isDefault || code === 'STD' || code === 'STD1' || /standard/i.test(raw)) return 'Standard';
      if (code === 'BRKF' || /breakfast/i.test(raw)) return 'Breakfast';
      if (code === 'NRF'  || /non[-\s]?ref/i.test(raw) || /non[-\s]?refundable/i.test(raw)) return 'Non-Refundable';

      // Fallback: original name without trailing "(1)" etc.
      return raw.replace(/\s*\(\d+\)\s*$/, '');
    }

    // ----- label + code→id helpers (generic)
    const getLabels = () => {
      try {
        const o = JSON.parse(localStorage.getItem(LS_KEY_LABELS) || '{}');
        return (o && typeof o === 'object') ? o : {};
      } catch(_) { return {}; }
    };
    const setLabel = (code, name) => {
      const o = getLabels();
      // No implicit "Custom 1/2" defaults; just store the trimmed name
      o[code] = String(name || '').trim();
      localStorage.setItem(LS_KEY_LABELS, JSON.stringify(o));
    };
    const getCodeMap = () => {
      try {
        const o = JSON.parse(localStorage.getItem(LS_KEY_CODEMAP) || '{}');
        return (o && typeof o === 'object') ? o : {};
      } catch(_) { return {}; }
    };

    // ----- selection persistence
    function loadSelectedIds(){
      if (Array.isArray(window.__initialSelectedRatePlanIds) && window.__initialSelectedRatePlanIds.length){
        return window.__initialSelectedRatePlanIds.slice();
      }
      try{
        const raw = localStorage.getItem(LS_KEY_IDS);
        if (raw){
          const arr = JSON.parse(raw);
          if (Array.isArray(arr) && arr.length) return arr.map(Number).filter(Number.isFinite);
        }
      }catch(_){}
      const cur = Number(window.currentRatePlanId);
      const stdChip = document.querySelector('#rateplan-checks .chip[data-plan-code="STD"]');
      const stdId = Number(stdChip && stdChip.getAttribute('data-plan-id'));
      return Number.isFinite(cur) ? [cur] : [Number.isFinite(stdId) ? stdId : 1];
    }
    function saveSelectedIds(ids){
      try{ localStorage.setItem(LS_KEY_IDS, JSON.stringify(ids)); }catch(_){}
    }

    // Expose for URL sync / calendar fetch
    window.getSelectedRatePlanIds = function getSelectedRatePlanIds(){
      try{
        const raw = localStorage.getItem(LS_KEY_IDS);
        if (raw){
          const arr = JSON.parse(raw);
          if (Array.isArray(arr) && arr.length) return arr.map(Number).filter(Number.isFinite);
        }
      }catch(_){}
      const cur = Number(window.currentRatePlanId);
      const stdChip = document.querySelector('#rateplan-checks .chip[data-plan-code="STD"]');
      const stdId = Number(stdChip && stdChip.getAttribute('data-plan-id'));
      return Number.isFinite(cur) ? [cur] : [Number.isFinite(stdId) ? stdId : 1];
    };

    // ----- build list: API plans + always show Custom 1/2
    const stripParenNum = (s) => String(s||'').replace(/\s*\(\d+\)\s*$/,'');

    function hydrateCustom(code, defName){
      const labels  = getLabels();
      const codeMap = getCodeMap();
      const knownId = Number(codeMap[code]);
      return {
        id: Number.isFinite(knownId) ? knownId : code, // string id placeholder if unknown
        code,
        name: (labels[code]?.trim()) || defName,
        placeholder: !Number.isFinite(knownId)
      };
    }

    /* ANCHOR: buildRenderablePlans (drop-in replacement) */
    function buildRenderablePlans(plans){
      const byCode = new Map();

      // Normalize backend list, strip trailing "(1)" from names
      (Array.isArray(plans) ? plans : []).forEach(p => {
        if (!p || p.id == null) return;
        const code = String(p.code || '').toUpperCase();
        const rawName = String(p.name || p.code || `Plan ${p.id}`);
        const name = rawName.replace(/\s*\(\d+\)\s*$/, '');
        byCode.set(code || `ID:${p.id}`, {
          id: Number(p.id),
          code,
          name,
          placeholder: false
        });
      });

      // Ensure Standard exists, and force label to "Standard"
      if (!byCode.has('STD')) {
        byCode.set('STD', { id: 1, code: 'STD', name: 'Standard', placeholder: false });
      } else {
        const std = byCode.get('STD');
        if (std) std.name = 'Standard';
      }

      // Sort: Standard, Breakfast, Non-Refundable, then the rest
      const arr = [...byCode.values()];
      const rank = (p) => {
        const c = p.code || '';
        if (c === 'STD')  return 0;
        if (c === 'BRKF') return 1;
        if (c === 'NRF')  return 2;
        return 3;
      };

      arr.sort((a, b) => {
        const ra = rank(a), rb = rank(b);
        if (ra !== rb) return ra - rb;

        const ai = Number(a.id), bi = Number(b.id);
        if (Number.isFinite(ai) && Number.isFinite(bi)) return ai - bi;

        return String(a.code || '').localeCompare(String(b.code || ''));
      });

      return arr;
    }


    // After plans are fetched/saved, record code→id so Custom chips become active
    document.addEventListener('rateplans:fetched', (e)=>{
      const arr = Array.isArray(e.detail?.plans) ? e.detail.plans : [];
      const codeMap = {};
      arr.forEach(p => { if (p && p.code && p.id != null) codeMap[String(p.code).toUpperCase()] = Number(p.id); });
      if (Object.keys(codeMap).length){
        localStorage.setItem(LS_KEY_CODEMAP, JSON.stringify(codeMap));
        try { window.populateRatePlanChecks(arr); } catch(_){}
      }
    });

    // Live-update chip labels when editing names in bottom panel
    document.addEventListener('input', (e)=>{
      const el = e.target;
      if (!(el instanceof HTMLElement)) return;
      if (!el.matches('#plans-panel [data-field="name"]')) return;
      const row = el.closest('.plan-row[data-plan-code]');
      const code = row?.getAttribute('data-plan-code'); // e.g. "STD", "BRKF", "NRF"
      if (!code) return;
      setLabel(code, el.textContent || '');
      const last = window.__lastFetchedPlans || null;
      try { window.populateRatePlanChecks(last); } catch(_){}
    });

    // Wrap fetchRatePlansSafe to keep last plans + broadcast event
    const _fetch = window.fetchRatePlansSafe;
    if (typeof _fetch === 'function'){
      window.fetchRatePlansSafe = async function(){
        const res = await _fetch.apply(this, arguments);
        try {
          window.__lastFetchedPlans = Array.isArray(res) ? res.slice() : [];
          document.dispatchEvent(new CustomEvent('rateplans:fetched', { detail:{ plans: window.__lastFetchedPlans } }));
        } catch(_){}
        return res;
      };
    }
  })();

  /* ANCHOR: RATEPLAN_CHIPS_RENDER */
  if (!window.populateRatePlanChecks) {
    window.populateRatePlanChecks = function populateRatePlanChecks(plans){
      const hostRow = document.getElementById('rateplan-checks-row');
      const host    = document.getElementById('rateplan-checks');
      if (!hostRow || !host) return;

      // --- optional label + code→id helpers (generic, no Custom 1/2 handling)
      let customLabels = {};
      let codeToId     = {};
      try { customLabels = JSON.parse(localStorage.getItem('rateplan.customLabels') || '{}') || {}; } catch(_) {}
      try { codeToId     = JSON.parse(localStorage.getItem('rateplan.codeToId')     || '{}') || {}; } catch(_) {}

      // Normalize API plans
      const byCode = new Map();
      (Array.isArray(plans) ? plans : []).forEach(p => {
        if (p && p.id != null){
          const code = String(p.code || '').toUpperCase();
          const name = String(p.name || p.code || `Plan ${p.id}`).replace(/\s*\(\d+\)\s*$/,'');
          byCode.set(code || `ID:${p.id}`, { id:Number(p.id), code, name, placeholder:false });
        }
      });

      // Ensure Standard exists and is named consistently
      // IMPORTANT: do not hardcode id=1 (DB ids differ per room)
      if (!byCode.has('STD')) {
        const fallbackStdId = Number(window.currentRatePlanId || 1);
        byCode.set('STD', { id: fallbackStdId, code:'STD', name:'Standard', placeholder:true, active:true });
      } else {
        const std = byCode.get('STD'); if (std) std.name = 'Standard';
      }

      // Order chips: Standard, Breakfast, Non-Refundable, Custom1, Custom2, then others
      const rank = (p) => {
        const c = p.code || '';
        if (c === 'STD')  return 0;
        if (c === 'BRKF') return 1;
        if (c === 'NRF')  return 2;
        return 3;
      };
      const list = [...byCode.values()].sort((a,b)=>{
        const ra=rank(a), rb=rank(b);
        if (ra!==rb) return ra-rb;
        const ai=Number(a.id), bi=Number(b.id);
        if (Number.isFinite(ai)&&Number.isFinite(bi)) return ai-bi;
        return String(a.code).localeCompare(String(b.code));
      });

      // Render chips
      host.innerHTML = '';
      list.forEach(p => {
        const numericId = Number.isFinite(Number(p.id)) && !p.placeholder;

      const label = document.createElement('label');
      label.className = 'chip';
      label.style.marginRight = '4px';

      // IMPORTANT: many downstream helpers rely on chip[data-plan-id]
      label.setAttribute('data-plan-id', String(p.id));
      label.setAttribute('data-plan-code', String(p.code || '').toUpperCase());

      if (!numericId){
        label.style.opacity = '0.65';
        label.title = 'Save plan rules to activate this plan';
      }

      const box = document.createElement('input');
      box.type = 'checkbox';
      box.setAttribute('data-plan-id', String(p.id));
      box.checked = (String(p.code || '').toUpperCase() === 'STD') ? true : (p.active === true);

      // Keep chip "active" class aligned with checkbox (your other logic uses .active)
      label.classList.toggle('active', !!box.checked);

      const txt = document.createElement('span');
      txt.textContent = p.name;

      label.appendChild(box);
      label.appendChild(txt);
      host.appendChild(label);

      if (numericId){
        box.addEventListener('change', async () => {
          label.classList.toggle('active', !!box.checked);

          const code = String(p.code || '').toUpperCase();

          // STD is always on
          if (code === 'STD') { box.checked = true; return; }

          // Optimistic UI, but revert on failure
          const nextActive = box.checked ? true : false;

          // Keep at least one checked (STD guarantees that)
          if (!nextActive) {
            // allow turning off BRKF/NRF etc, STD still on
          }

          // Persist to backend (DB source of truth)
          try {
          const rid = Number(window.currentRoomTypeId || 0);
          const fetcher = (typeof window.authFetch === 'function') ? window.authFetch : fetch;

          const pid = getRatePlanPropertyId();

          const url =
            `/extranet/property/rateplans?propertyId=${encodeURIComponent(String(pid))}` +
            `&roomTypeId=${encodeURIComponent(String(rid))}`;

            const r = await fetcher(url, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              cache: 'no-store',
              credentials: 'include',
              body: JSON.stringify({
                plans: [{ code, active: nextActive }]
              })
            });

            if (!r.ok) throw new Error(`HTTP ${r.status}`);

            // Refresh from server so UI matches DB exactly
            if (typeof window.loadRatePlansForRoom === 'function' && Number.isFinite(rid) && rid > 0) {
              const latest = await window.loadRatePlansForRoom(rid);
              try { window.populateRatePlanChecks(latest); } catch(_) {}
            }

            // notify rest of page (calendar refresh etc)

            // Active toggles should NOT rewrite selection. Just refresh chips from server truth.
            try {
              const rid2 = Number(window.currentRoomTypeId || 0);
              if (typeof window.loadRatePlansForRoom === 'function' && Number.isFinite(rid2) && rid2 > 0) {
                const latest = await window.loadRatePlansForRoom(rid2);
                try { window.populateRatePlanChecks(latest); } catch(_) {}
              }
            } catch(_) {}
          } catch (e) {
            console.warn('[rateplans] persist active failed, reverting', e);
            // revert checkbox
            box.checked = !nextActive;
            alert('Failed to save rate plan change. Please retry.');
          }
        });
        }
      });

      // Ensure row is visible
      hostRow.style.display = 'flex';

      // Persist primary on first paint so refresh keeps the same plan
      try {
        const first = Array.isArray(selected) ? selected[0] : (window.getSelectedRatePlanIds?.()[0]);
        if (Number.isFinite(first)) {
          localStorage.setItem('rateplan.lastPlanId', String(first));
          window.currentRatePlanId = first;
          try { updateURLFromState?.(); } catch(_) {}
        }
      } catch(_) {}

      // Optional: announce that chips rendered (used by some observers)
      try { document.dispatchEvent(new CustomEvent('plans:rendered', { detail:{ plans: list } })); } catch(_){}
    };
  } /* end RATEPLAN_CHIPS_RENDER */

  // Leave this function immediately after the block
  function setStatus(msg, cls=""){ status.className="note "+cls; status.textContent=msg; }

  /* ANCHOR: PER_ROOM_RATEPLANS_STORE */
  (function(){
    const LS_BYROOM = 'rateplan.selectedByRoom';
    const LS_LAST_BYROOM = 'rateplan.lastPlanIdByRoom';

    function readMap(key){
      try { const o = JSON.parse(localStorage.getItem(key)||'{}'); return (o && typeof o==='object') ? o : {}; }
      catch(_) { return {}; }
    }
    function writeMap(key, obj){ try { localStorage.setItem(key, JSON.stringify(obj||{})); } catch(_){} }

    // Read room-scoped selection (fallback to global, then STD=1)
    window.getRoomPlanSelection = function(roomId){
      const rid = Number(roomId || window.currentRoomTypeId);
      const byRoom = readMap(LS_BYROOM);
      let ids = Array.isArray(byRoom[rid]) ? byRoom[rid] : null;

      if (!ids || !ids.length){
        let globalArr = []; try { globalArr = JSON.parse(localStorage.getItem('rateplan.selectedIds') || '[]'); } catch(_){}
        let last = Number(localStorage.getItem('rateplan.lastPlanId') || '');
        const stdChip = document.querySelector('#rateplan-checks .chip[data-plan-code="STD"]');
        const stdId = Number(stdChip && stdChip.getAttribute('data-plan-id'));
        const STD_FALLBACK = (Number.isFinite(stdId) && stdId > 0) ? stdId : 1;

        ids = (Array.isArray(globalArr) && globalArr.length ? globalArr : (Number.isFinite(last) ? [last] : [STD_FALLBACK]));
      }
      ids = ids.map(Number).filter(n => Number.isFinite(n) && n > 0);
      if (!ids.length) ids = [STD_FALLBACK];
      return ids;
    };

    // Persist room-scoped selection (also sync legacy globals for compatibility)
    window.saveRoomPlanSelection = function(roomId, ids){
      const rid = Number(roomId || window.currentRoomTypeId);
      const clean = (Array.isArray(ids) ? ids : []).map(Number).filter(n => Number.isFinite(n) && n>0);
      const stdChip = document.querySelector('#rateplan-checks .chip[data-plan-code="STD"]');
      const stdId = Number(stdChip && stdChip.getAttribute('data-plan-id'));
      const STD_FALLBACK = (Number.isFinite(stdId) && stdId > 0) ? stdId : 1;

      const next = clean.length ? clean : [STD_FALLBACK];

      const byRoom = readMap(LS_BYROOM); byRoom[rid] = next; writeMap(LS_BYROOM, byRoom);
      const lastMap = readMap(LS_LAST_BYROOM); lastMap[rid] = next[0]; writeMap(LS_LAST_BYROOM, lastMap);

      try{
        localStorage.setItem('rateplan.selectedIds', JSON.stringify(next));
        localStorage.setItem('rateplan.lastPlanId', String(next[0]));
      }catch(_){}

      window.__selectedPlanIds = next.slice();
      window.currentRatePlanId = next[0];

      try { updateURLFromState?.(); } catch(_){}
    };

    // Ensure chips reflect current room; broadcast if we changed them
    window.syncChipsToCurrentRoom = function(){
      const rid = Number(window.currentRoomTypeId);
      if (!Number.isFinite(rid)) return;

      const want = window.getRoomPlanSelection(rid);
      const boxes = Array.from(document.querySelectorAll('#rateplan-checks input[type="checkbox"][data-plan-id]'))
        .filter(n => !n.disabled);
      const have = boxes.filter(b => b.checked).map(b => Number(b.dataset.planId));

      const same = want.length === have.length && want.every(id => have.includes(id));
      // Option A: DB enablement owns chip checked states.
      // Do not overwrite chip checkbox states from selection.
      if (!same){
        // Still keep selection stored (for calendar pricing plan), but do NOT touch chip checkboxes here.
        window.saveRoomPlanSelection(rid, want);
        try { document.dispatchEvent(new CustomEvent('rateplans:changed', { detail:{ ids: want.slice(), roomId: rid, source:'selection-sync' } })); } catch(_){}
      }
    };

    // Persist per-room whenever the chips selection changes
    document.addEventListener('rateplans:changed', (e)=>{
      const src = e?.detail?.source || '';
      // Ignore events that are not explicit user selection changes.
      if (src === 'active-toggle' || src === 'selection-sync') return;

      const ids = Array.isArray(e.detail?.ids) ? e.detail.ids.map(Number).filter(Number.isFinite) : [];
      const rid = Number(window.currentRoomTypeId);
      if (Number.isFinite(rid) && ids.length){ window.saveRoomPlanSelection(rid, ids); }
    });

    // After the chips render (initial or refresh), align to the active room
    document.addEventListener('plans:rendered', ()=> { try { window.syncChipsToCurrentRoom(); } catch(_){} });
  })();


  /* ANCHOR: RIGHT_ACTIVE_TOGGLE */
  function setRightActive(flag){
    const r = document.querySelector('section.right');
    if (r) r.classList.toggle('active-room', !!flag);
    if (!flag && typeof loadRoomPhotos === "function"){
      try { loadRoomPhotos(null); } catch(_){}
    }
  }

  /* ANCHOR: TOAST_HELPER */
  function toast(msg, kind='ok', ms=2500){
    try{
      let wrap = document.getElementById('toasts');
      if (!wrap){
        wrap = document.createElement('div');
        wrap.id = 'toasts';
        wrap.style.position='fixed';
        wrap.style.right='16px';
        wrap.style.bottom='16px';
        wrap.style.display='flex';
        wrap.style.flexDirection='column';
        wrap.style.gap='8px';
        wrap.style.zIndex='9999';
        document.body.appendChild(wrap);
      }
      const css = getComputedStyle(document.documentElement);
      const panel2 = css.getPropertyValue('--panel-2').trim() || '#161b28';
      const border = css.getPropertyValue('--border').trim() || '#222a3a';
      const text   = css.getPropertyValue('--text').trim()   || '#e7ecf3';

      const n = document.createElement('div');
      n.textContent = String(msg);
      n.setAttribute('role','status');
      n.style.background = panel2;
      n.style.border = '1px solid ' + border;
      n.style.color = text;
      n.style.padding = '10px 12px';
      n.style.borderRadius = '10px';
      n.style.boxShadow = '0 8px 20px rgba(0,0,0,.35)';
      n.style.fontSize = '13px';
      n.style.opacity = '0';
      n.style.transform = 'translateY(8px)';
      n.style.transition = 'opacity .18s ease, transform .18s ease';

      if (kind==='error') n.style.borderColor = 'rgba(231,76,60,.6)';
      else if (kind==='warn') n.style.borderColor = 'rgba(243,156,18,.6)';
      else if (kind==='ok') n.style.borderColor = 'rgba(46,204,113,.45)';

      wrap.appendChild(n);
      requestAnimationFrame(()=>{ n.style.opacity='1'; n.style.transform='translateY(0)'; });
      setTimeout(()=>{
        n.style.opacity='0'; n.style.transform='translateY(8px)';
        setTimeout(()=> n.remove(), 200);
      }, ms);
    }catch(_){}
  }

    /* ANCHOR: DIRTY_BADGE_HELPER */
    function updateDayDirtyBadge(dateISO){
      const card = document.getElementById('day-' + dateISO);
      if (!card) return;
      const o = dirty.get(dateISO);
      // “effective change” if any field is a number, boolean, or non-empty string
      const hasAny = !!o && Object.values(o).some(v =>
        typeof v === 'number' || typeof v === 'boolean' || (typeof v === 'string' && v !== '')
      );
      card.classList.toggle('is-dirty', hasAny);
    }

  function disableWhileBusy(flag){
    busy=!!flag;
    document.querySelectorAll("button, input").forEach(x=>{
      if (x.id!=="back") x.classList.toggle("disabled", busy);
      x.disabled = busy && x.id!=="back";
    });
  }
  function validateRangeOrWarn(){
    const s=el("range-start").value, e=el("range-end").value;
    if (!s||!e){ setStatus("Enter a start and end date.","error"); return false; }
    if (e<s){ setStatus("End date cannot be before start date.","error"); return false; }
    const t=todayISO(); if (s<t){ setStatus("Start date must be today or later.","error"); return false; }
    return true;
  }
  const dirty = new Map();
  function setDirty(date, kind, value){
    if (!dirty.has(date)) dirty.set(date, {});
    const o = dirty.get(date);
    o[kind] = value;

    // prune if no effective changes remain
    const hasAny = Object.values(o).some(v =>
      typeof v === 'number' || typeof v === 'boolean' || (typeof v === 'string' && v !== '')
    );
    if (!hasAny) dirty.delete(date);

    updateDayDirtyBadge(date);
    updateDirtyUI();
  }
  function updateDirtyUI(){
    const nGrid = dirty.size;
    const nRooms = pendingRoomUpdates.size;
    const invalidCount = document.querySelectorAll('.chip input.error').length;
    const totalChanges = nGrid + nRooms;

    // Build counts string
    const parts = [];
    if (nGrid)  parts.push(`${nGrid} day${nGrid>1?'s':''} changed`);
    if (nRooms) parts.push(`${nRooms} room edit${nRooms>1?'s':''}`);
    if (invalidCount) parts.push(`${invalidCount} error${invalidCount>1?'s':''}`);

    // Buttons
    const saveBtn = el("save");
    const discardBtn = el("discard");
    if (saveBtn)   saveBtn.disabled   = (totalChanges===0) || busy || (invalidCount>0);
    if (discardBtn) discardBtn.disabled = (totalChanges===0) || busy;

    // Friendlier message with CTA, while keeping counts
    let msg = "No changes";
    if (invalidCount > 0){
      msg = `Fix ${invalidCount} error${invalidCount>1?'s':''} to enable Save` + (totalChanges ? ` — ${parts.join(" + ")}` : "");
    } else if (totalChanges > 0){
      msg = `Unsaved: ${parts.join(" + ")} — click Save or Discard`;
    }

    el("dirty-count").textContent = msg;
  }

  // ANCHOR: DEBOUNCE_DIRTY_UI
  // Debounce updateDirtyUI to avoid thrashing during rapid input
  {
    const _updateDirtyUI = updateDirtyUI;  // keep original
    let t = null;
    function debounced(){ clearTimeout(t); t = setTimeout(_updateDirtyUI, 50); }
    // Replace the global reference so all existing calls are debounced
    updateDirtyUI = debounced;
  }

  /* ===== Rooms list & edit modal ===== */
  function openEditModal(rt){
    const m = el('edit-modal');
    // No edit-id element in markup anymore; header just says "Edit room"
    el('edit-name').value = rt.name ?? '';

    const basePlain = String(rt.basePrice ?? '').replace(/[^0-9.]/g,'');
    el('edit-base').value = basePlain;

    const maxEl = el('edit-max');
    if (maxEl) maxEl.value = (rt.occupancy ?? rt.maxGuests ?? 2);

    const activeSel = el('edit-active');
    if (activeSel) activeSel.value = String(!!rt.active);

    // Fill room-info fields from backend first, then overlay any local overrides
    let detailKeys = [];
    let inclusionKeys = [];
    try{
      const sumEl  = el('edit-room-summary');
      const detEl  = el('edit-room-details');
      const incEl  = el('edit-room-inclusions');
      const sqmEl  = el('edit-room-size-sqm');
      const sqftEl = el('edit-room-size-sqft');

      const dbInfo = {
        summary:       rt.summary        ?? '',
        details:       rt.details_text   ?? '',
        inclusions:    rt.inclusion_text ?? '',
        sizeSqm:       rt.size_sqm       ?? '',
        sizeSqft:      rt.size_sqft      ?? '',
        detailsKeys:   Array.isArray(rt.details_keys)   ? rt.details_keys   : [],
        inclusionKeys: Array.isArray(rt.inclusion_keys) ? rt.inclusion_keys : [],
      };

      const localInfo = (roomInfoById && roomInfoById[rt.id]) || {};
      const info = { ...dbInfo, ...localInfo };

      if (sumEl)  sumEl.value  = info.summary    ?? '';
      if (detEl)  detEl.value  = info.details    ?? '';
      if (incEl)  incEl.value  = info.inclusions ?? '';
      if (sqmEl)  sqmEl.value  = info.sizeSqm    ?? '';
      if (sqftEl) sqftEl.value = info.sizeSqft   ?? '';

      detailKeys    = Array.isArray(info.detailsKeys)    ? info.detailsKeys    : [];
      inclusionKeys = Array.isArray(info.inclusionKeys)  ? info.inclusionKeys  : [];
    }catch(_){}

    // Apply checkbox state for details / inclusions
    try{
      const detailEls = document.querySelectorAll('.ri-detail');
      detailEls.forEach(cb => {
        cb.checked = detailKeys.includes(cb.value);
      });

      const inclusionEls = document.querySelectorAll('.ri-inclusion');
      inclusionEls.forEach(cb => {
        cb.checked = inclusionKeys.includes(cb.value);
      });
    }catch(_){}

    // Attach one-time blur handlers for size conversion
    const sqmEl  = el('edit-room-size-sqm');
    const sqftEl = el('edit-room-size-sqft');
    if (sqmEl && !sqmEl.dataset.boundSize){
      sqmEl.dataset.boundSize = '1';
      sqmEl.addEventListener('blur', () => syncRoomSizeFields('sqm'));
    }
    if (sqftEl && !sqftEl.dataset.boundSize){
      sqftEl.dataset.boundSize = '1';
      sqftEl.addEventListener('blur', () => syncRoomSizeFields('sqft'));
    }

    el('edit-warn').style.display = 'none';
    m.classList.add('open');

    // Autofocus first field and prevent background scroll
    try { el('edit-name')?.focus(); el('edit-name')?.select?.(); } catch(_){}
    const prevOverflow = document.body.style.overflow;
    document.body.style.overflow = 'hidden';

    // Key handlers: Enter => OK, Esc => Cancel
    const onKey = (ev) => {
      if (ev.key === 'Escape') {
        ev.preventDefault();
        el('edit-cancel').click();
      } else if (ev.key === 'Enter') {
        // Save on Enter unless focused element is a button/select
        const tag = (ev.target?.tagName || '').toLowerCase();
        if (tag === 'input' || tag === 'textarea') {
          ev.preventDefault();
          el('edit-save').click();
        }
      }
    };
    m.addEventListener('keydown', onKey);

    const onSave = async () => {
      const nameVal   = el('edit-name').value.trim();
      const baseVal   = el('edit-base').value.trim();
      const maxValStr = (el('edit-max')?.value ?? '').trim();
      const maxVal    = maxValStr === '' ? NaN : parseInt(maxValStr, 10);
      const activeVal = (el('edit-active')?.value === 'true');

      const payload = {};

      // Capture room-info fields (localStorage only, no API yet)
      const infoSummary     = (el('edit-room-summary')?.value || '').trim();
      const infoDetails     = (el('edit-room-details')?.value || '').trim();
      const infoInclusions  = (el('edit-room-inclusions')?.value || '').trim();
      const infoSizeSqm     = (el('edit-room-size-sqm')?.value || '').trim();
      const infoSizeSqft    = (el('edit-room-size-sqft')?.value || '').trim();

      // Checkbox selections
      let infoDetailKeys = [];
      let infoInclusionKeys = [];
      try{
        const detailEls = document.querySelectorAll('.ri-detail');
        infoDetailKeys = Array.from(detailEls)
          .filter(cb => cb.checked)
          .map(cb => cb.value);

        const inclusionEls = document.querySelectorAll('.ri-inclusion');
        infoInclusionKeys = Array.from(inclusionEls)
          .filter(cb => cb.checked)
          .map(cb => cb.value);
      }catch(_){}

      const prevInfo = roomInfoById[rt.id] || {};
      const nextInfo = {
        summary:        infoSummary,
        details:        infoDetails,
        inclusions:     infoInclusions,
        sizeSqm:        infoSizeSqm,
        sizeSqft:       infoSizeSqft,
        detailsKeys:    infoDetailKeys,
        inclusionKeys:  infoInclusionKeys
      };

      if (prevInfo.summary        !== nextInfo.summary       ||
          prevInfo.details        !== nextInfo.details       ||
          prevInfo.inclusions     !== nextInfo.inclusions    ||
          prevInfo.sizeSqm        !== nextInfo.sizeSqm       ||
          prevInfo.sizeSqft       !== nextInfo.sizeSqft      ||
          JSON.stringify(prevInfo.detailsKeys   || []) !== JSON.stringify(nextInfo.detailsKeys) ||
          JSON.stringify(prevInfo.inclusionKeys || []) !== JSON.stringify(nextInfo.inclusionKeys)) {
        roomInfoById = { ...roomInfoById, [rt.id]: nextInfo };
        saveRoomInfoMap(roomInfoById);
      }

      // Map room-info fields into API payload for RoomType update
      if (infoSummary) {
        payload.summary = infoSummary;
      }

      if (infoDetails) {
        payload.details_text = infoDetails;
      }

      if (infoInclusions) {
        payload.inclusion_text = infoInclusions;
      }

      if (infoDetailKeys && infoDetailKeys.length) {
        payload.details_keys = infoDetailKeys.slice();
      }

      if (infoInclusionKeys && infoInclusionKeys.length) {
        payload.inclusion_keys = infoInclusionKeys.slice();
      }

      if (infoSizeSqm) {
        const v = Number(String(infoSizeSqm).replace(/,/g, ""));
        if (Number.isFinite(v) && v > 0) payload.size_sqm = v;
      }

      if (infoSizeSqft) {
        const v = Number(String(infoSizeSqft).replace(/,/g, ""));
        if (Number.isFinite(v) && v > 0) payload.size_sqft = v;
      }

      if (nameVal && nameVal !== rt.name) payload.name = nameVal;

      if (baseVal !== "") {
        const n = Number(baseVal);
        if (!Number.isFinite(n) || n < 0) { setStatus("Base price must be a non-negative number.","error"); return; }
        if (Number(rt.basePrice) !== n) payload.basePrice = n.toFixed(2);
      }

      if (!Number.isNaN(maxVal)) {
        if (!Number.isFinite(maxVal) || maxVal < 1) { setStatus("Max capacity must be ≥ 1.","error"); return; }
        const prevG = Number(rt.occupancy ?? rt.maxGuests);
        if (!Number.isFinite(prevG) || prevG !== maxVal) {
          payload.occupancy = maxVal;
          payload.maxGuests = maxVal;
        }
      }

      if (typeof rt.active !== 'undefined' && activeVal !== !!rt.active) {
        payload.active = activeVal;
      }

      // Only send fields the backend currently accepts.
      const serverPayloadKeys = ["name", "basePrice", "occupancy", "maxGuests", "active"];
      const serverPayload = {};
      for (const k of serverPayloadKeys) {
        if (Object.prototype.hasOwnProperty.call(payload, k)) {
          serverPayload[k] = payload[k];
        }
      }

      if (!Object.keys(serverPayload).length) {
        // Only metadata (summary/details/inclusions/size) changed.
        // Those are already stored in roomInfoById/localStorage, no backend call needed.
        m.classList.remove('open');
        updateDirtyUI();
        return;
      }

      pendingRoomUpdates.set(rt.id, serverPayload);
      updateDirtyUI();
      setStatus("Room changes queued — click Save changes to apply.", "warn");

      m.classList.remove('open');
      el('edit-save').removeEventListener('click', onSave);
      m.removeEventListener('keydown', onKey);
      document.body.style.overflow = prevOverflow;
    };

    el('edit-save').addEventListener('click', onSave, { once:true });
  }

  el('edit-cancel').addEventListener('click', ()=>{
    const m = el('edit-modal');
    m.classList.remove('open');
    try { m.removeEventListener('keydown', onKey); } catch(_){}
    document.body.style.overflow = '';
  });
  /* ANCHOR: EDIT_ROOM_CLOSE_WIRE */
  const closeBtn = document.getElementById('edit-room-close');
  if (closeBtn) {
    closeBtn.addEventListener('click', () => {
      el('edit-cancel').click();
    });
  }
    el('edit-modal').addEventListener('click', (e)=>{
    if (e.target.id==='edit-modal'){
      const m = el('edit-modal');
      m.classList.remove('open');
      try { m.removeEventListener('keydown', onKey); } catch(_){}
      document.body.style.overflow = '';
    }
  });

  async function loadRooms(){
    roomsList.innerHTML = "";
    const res = await authFetch("/extranet/property/rooms");
    if (!res.ok){ setStatus("Failed to load rooms ("+res.status+")","error"); return; }
    const data = await res.json();
    data.sort((a,b)=>String(a.name).localeCompare(String(b.name), undefined, {sensitivity:'base'}));
    if (!Array.isArray(data)) return;

    data.forEach(rt=>{
      const div = document.createElement("div");
      div.className = "room" + (rt.id === currentRoomTypeId ? " active" : "");
      const base = fmtUSD(rt.basePrice);
      const maxGuests = (rt.occupancy ?? rt.maxGuests ?? 2);
      const roBadge = readOnlyRoomField.get(rt.id) ? ` <span class="warn" title="Server treated base/max as read-only">[read-only]</span>` : "";
      const isActive = !!(rt.active ?? rt.isActive ?? (rt.status === 'ACTIVE'));
      div.innerHTML = `
        <div>
          <div class="name">${rt.name}</div>
          <div class="meta">
            Base ${base || "-"} · Max ${maxGuests}${roBadge}
            ${isActive
              ? '<span class="badge" style="margin-left:6px;">Active</span>'
              : '<span class="badge" style="margin-left:6px; background:#3a2430; color:#ffd7d7; border-color:var(--line);">Inactive</span>'}
          </div>
        </div>
        <div class="actions">
          <button type="button" class="secondary btn btn-secondary-outline" data-act="edit" data-id="${rt.id}">Edit</button>
          <button type="button" class="secondary btn btn-secondary-outline" data-act="del"  data-id="${rt.id}">Delete</button>
        </div>`;

      // Open room on card click, ignore button clicks
      div.addEventListener("click", async (e)=>{
        if (e.target.closest("button")) return;
        currentRoomTypeId = rt.id;

        // Align rate-plan chips to this room before any render/fetch
        try { window.syncChipsToCurrentRoom?.(); } catch(_){}

        // Fire-and-forget room-photo fetch (cached per room)
        try { loadRoomPhotos(currentRoomTypeId); } catch(_){}

        saveCtx();
        updateURLFromState('push');
        if (dirty.clear) dirty.clear();

        // highlight right pane
        setRightActive(true);

        await renderCalendar();
        await loadRooms();
      });

      const editBtn = div.querySelector('button[data-act="edit"]');
      const delBtn  = div.querySelector('button[data-act="del"]');

      if (editBtn) editBtn.addEventListener("click", (e)=>{
        e.preventDefault(); e.stopPropagation();
        openEditModal(rt);
      });

      if (delBtn) delBtn.addEventListener("click", async (e)=>{
        e.preventDefault(); e.stopPropagation();
        if (!confirm("Delete this room type?")) return;
        const r = await authFetch(`/extranet/property/rooms/${rt.id}`, { method:"DELETE" });
        if (r.status === 204){
          if (currentRoomTypeId === rt.id) {
            currentRoomTypeId = null;
            setRightActive(false); // remove highlight
          }
          setStatus("Room deleted","ok");
          await loadRooms();
          calGrid.innerHTML = "";
        } else {
          setStatus("Delete failed ("+r.status+")","error");
        }
      });

      roomsList.appendChild(div);
    });
  }

    // Add Room
    el("add-room").addEventListener("click", async ()=>{
      const name=(prompt("Room type name (e.g., Deluxe Queen):")||"").trim();
      if (!name){ setStatus("Name is required.","warn"); return; }
      let p = prompt("Base price in USD (e.g., 129.00):") || "";
      p = p.replace(/[^0-9.]/g,"");
      const basePrice = Number(p);
      if (!Number.isFinite(basePrice) || basePrice < 0){ setStatus("Enter a valid non-negative price.","error"); return; }

      disableWhileBusy(true);
      const res = await authFetch("/extranet/property/rooms", {
        method:"POST",
        body: JSON.stringify({ name, basePrice: basePrice.toFixed(2), maxGuests: 2, description: "" })
      });
      disableWhileBusy(false);
      if (!res.ok){ setStatus("Create failed ("+res.status+")","error"); return; }
      const created = await res.json();
      currentRoomTypeId = created.id;
      setStatus("Room created","ok");
      await loadRooms();
      await renderCalendar();
    });

    // Range defaults + listeners
    function prepareRangeDefaults(){
      const start=new Date(); const end=new Date(start); end.setMonth(end.getMonth()+6);
      const s=iso(start), e=iso(end);
      if (!el("range-start").value) el("range-start").value=s;
      if (!el("range-end").value)   el("range-end").value=e;
      currentRangeStart=el("range-start").value; currentRangeEnd=el("range-end").value;
    }
    ["range-start","range-end"].forEach(id=>{
      el(id).addEventListener("change", ()=>{
        if (!validateRangeOrWarn()) return;
        currentRangeStart = el("range-start").value;
        currentRangeEnd   = el("range-end").value;
        saveCtx();
        updateURLFromState();
        scheduleRender(220);
      });
    });

    // ANCHOR: RANGE_GUARD_CONSTRAINTS
    (function guardRangePickers(){
      const rs = el("range-start");
      const re = el("range-end");
      if (!rs || !re) return;

      const ONE_DAY = 86400000;
      const iso = (d)=>d.toISOString().slice(0,10);
      const todayISO = ()=> iso(new Date());

      // Set initial constraints
      rs.min = todayISO();
      // keep end's min in sync with start
      const syncEndMin = ()=> { re.min = rs.value || todayISO(); };

      function ensureWindow(){
      // Keep ~1-week window if user collapses range
      if (!rs.value) rs.value = todayISO();
      if (!re.value || re.value < rs.value){
        const s = new Date(rs.value+"T00:00:00Z");
        const e = new Date(s.getTime() + (7-1)*ONE_DAY);
        re.value = iso(e);
      }
    }

    // On load/init
    syncEndMin();
    ensureWindow();

    // When start changes: push end if needed, sync min
    rs.addEventListener("change", ()=>{
      syncEndMin();
      if (!re.value || re.value < rs.value){
        const s = new Date(rs.value+"T00:00:00Z");
        const e = new Date(s.getTime() + (7-1)*ONE_DAY);
        re.value = iso(e);
      }
    });

    // When end changes: if end < start, snap back to ~1 week
    re.addEventListener("change", ()=>{
      if (re.value && rs.value && re.value < rs.value){
        const s = new Date(rs.value+"T00:00:00Z");
        const e = new Date(s.getTime() + (7-1)*ONE_DAY);
        re.value = iso(e);
      }
    });
  })();

    // ANCHOR: RANGE_QUICK_SELECTS
    (function wireQuickRange(){
      const rs = el("range-start");
      const re = el("range-end");
      const b7  = document.getElementById("range-7");
      const b14 = document.getElementById("range-14");
      const b21 = document.getElementById("range-21");
      if (!rs || !re) return;

      const ONE_DAY = 86400000;
      const iso = (d)=>d.toISOString().slice(0,10);

      function setRangeDays(days){
        // start: current rs (or today if empty / past-guard bumps it)
        if (!rs.value){
          const t = new Date();
          rs.value = iso(new Date(t.getFullYear(), t.getMonth(), t.getDate()));
        }
        // end: start + (days-1)
        const s = new Date(rs.value + "T00:00:00Z");
        const e = new Date(s.getTime() + (days-1)*ONE_DAY);
        re.value = iso(e);

        // sync state + URL + render (debounced if available)
        currentRangeStart = rs.value;
        currentRangeEnd   = re.value;
        saveCtx();
        updateURLFromState();
        if (typeof scheduleRender === 'function') scheduleRender(120);
        else if (typeof renderCalendar === 'function') renderCalendar();
      }

      b7?.addEventListener('click',  ()=> setRangeDays(7));
      b14?.addEventListener('click', ()=> setRangeDays(14));
      b21?.addEventListener('click', ()=> setRangeDays(21));
    })();

    // ANCHOR: BULK_PRICE_VALIDATE
    (function wireBulkPriceValidation(){
      const priceEl = el("price");
      if (!priceEl) return;

      const moneyRx = /^(\d+)(\.\d{1,2})?$/;
      function isValidMoney(v){
        if (v === "") return true; // empty is neutral
        if (!moneyRx.test(v)) return false;
        const n = parseFloat(v);
        return Number.isFinite(n) && n >= 0;
      }
      function formatMoney2(v){
        const n = parseFloat(v);
        return Number.isFinite(n) ? n.toFixed(2) : v;
      }

      priceEl.addEventListener("input", () => {
        const v = priceEl.value.trim();
        if (v === "") { priceEl.classList.remove("error"); return; }
        priceEl.classList.toggle("error", !isValidMoney(v));
      });

      // On blur (Tab / click away), normalize to two decimals if valid
      priceEl.addEventListener("blur", () => {
        const v = priceEl.value.trim();
        if (v !== "" && isValidMoney(v)){
          priceEl.value = formatMoney2(v);
          priceEl.classList.remove("error");
        }
      });
    })();

    // ANCHOR: BULK_INVENTORY_VALIDATE
    (function wireBulkInventoryValidation(){
      const invOpenEl = document.getElementById("inv-open");
      const minStayEl = document.getElementById("inv-minstay");

      function validateRoomsOpen(){
        if (!invOpenEl) return;
        const v = invOpenEl.value.trim();
        if (v === "") { invOpenEl.classList.add("error"); return false; } // required
        const n = Number(v);
        const ok = Number.isFinite(n) && n >= 0;
        invOpenEl.classList.toggle("error", !ok);
        return ok;
      }

      function validateMinStay(){
        if (!minStayEl) return true;
        const v = minStayEl.value.trim();
        if (v === "") { minStayEl.classList.remove("error"); return true; } // optional
        const n = Number(v);
        const ok = Number.isFinite(n) && n >= 1;
        minStayEl.classList.toggle("error", !ok);
        return ok;
      }

      // Live validate while typing
      if (invOpenEl) invOpenEl.addEventListener("input", validateRoomsOpen);
      if (minStayEl) minStayEl.addEventListener("input", validateMinStay);

      // Normalize on blur to integers
      if (invOpenEl) invOpenEl.addEventListener("blur", ()=>{
        if (!validateRoomsOpen()) return;
        const n = Math.floor(Number(invOpenEl.value.trim()));
        invOpenEl.value = String(n);
        invOpenEl.classList.remove("error");
      });
      if (minStayEl) minStayEl.addEventListener("blur", ()=>{
        if (!validateMinStay()) return;
        const v = minStayEl.value.trim();
        if (v === "") return; // optional
        const n = Math.floor(Number(v));
        minStayEl.value = String(n);
        minStayEl.classList.remove("error");
      });
    })();

    // ANCHOR: APPLY_BTNS_STATE
    (function wireApplyButtonsState(){
      const priceEl = el("price");
      const invOpenEl = el("inv-open");
      const minStayEl = el("inv-minstay");
      const closedEl = el("inv-closed");
      const applyPriceBtn = el("apply-price");
      const applyInvBtn = el("apply-inv");

      const moneyRx = /^(\d+)(\.\d{1,2})?$/;

      function validPrice(){
        const v = (priceEl?.value ?? "").trim();
        if (v === "") return false;
        if (!moneyRx.test(v)) return false;
        const n = parseFloat(v);
        return Number.isFinite(n) && n >= 0;
      }
      function validInventory(){
        const ro = (invOpenEl?.value ?? "").trim();
        const ms = (minStayEl?.value ?? "").trim();
        // roomsOpen: required, integer >=0
        if (ro === "") return false;
        const roN = Number(ro);
        if (!Number.isFinite(roN) || roN < 0) return false;
        // minStay: optional, but if present must be integer >=1
        if (ms !== ""){
          const msN = Number(ms);
          if (!Number.isFinite(msN) || msN < 1) return false;
        }
        // closed checkbox is always okay
        return true;
      }
      function rangeIsValid(){
        const s = el("range-start")?.value, e = el("range-end")?.value;
        return !!(s && e && e >= s);
      }

      function refresh(){
        if (applyPriceBtn) applyPriceBtn.disabled = !(currentRoomTypeId && rangeIsValid() && validPrice());
        if (applyInvBtn)   applyInvBtn.disabled   = !(currentRoomTypeId && rangeIsValid() && validInventory());
      }

      // Hook inputs that affect validity
      ["range-start","range-end","price","inv-open","inv-minstay","inv-closed"].forEach(id=>{
        const n = el(id);
        if (n) ["input","change","blur"].forEach(ev=> n.addEventListener(ev, refresh));
      });

      // Also refresh after calendar finishes rendering
      document.addEventListener('calendar:rendered', refresh);

      // initial
      refresh();
    })();

    // ANCHOR: APPLY_ON_ENTER
    (function wireApplyOnEnter(){
      const priceEl = document.getElementById("price");
      const invOpenEl = document.getElementById("inv-open");
      const invMinStayEl = document.getElementById("inv-minstay");
      const applyPriceBtn = document.getElementById("apply-price");
      const applyInvBtn = document.getElementById("apply-inv");

      function maybeClick(btn){
        if (btn && !btn.disabled) btn.click();
      }

      // Enter in Price -> Apply Price
      if (priceEl){
        priceEl.addEventListener("keydown", (e)=>{
          if (e.key === "Enter"){
            e.preventDefault();
            maybeClick(applyPriceBtn);
          }
        });
      }

      // Enter in Inventory -> Apply Inventory
      [invOpenEl, invMinStayEl].forEach(el=>{
        if (!el) return;
        el.addEventListener("keydown", (e)=>{
          if (e.key === "Enter"){
            e.preventDefault();
            maybeClick(applyInvBtn);
          }
        });
      });
    })();

    // ANCHOR: SCROLL_TO_DATE
  function scrollToDate(isoDate){
    try{
      const card = document.getElementById(`day-${isoDate}`);
      const wrap = document.querySelector('.calendar');
      if (card && wrap){
        card.scrollIntoView({ block: 'nearest', inline: 'start' });
      }
    }catch(_){}
  }

  // ANCHOR: CAL_LOADING_HELPERS
  function setCalLoading(on){
    try{
      const wrap = document.querySelector('.calendar');
      if (!wrap) return;
      wrap.classList.toggle('loading', !!on);
    }catch(_){}
  }

  // ANCHOR: FLASH_DATES_HELPER
  function flashDates(dates){
    try{
      dates.forEach(d=>{
        const el = document.getElementById(`day-${d}`);
        if (!el) return;
        el.classList.remove('flash'); // restart animation if already present
        // force reflow to allow re-adding the class
        void el.offsetWidth;
        el.classList.add('flash');
        setTimeout(()=> el.classList.remove('flash'), 1400);
      });
    }catch(_){}
  }

  // ANCHOR: CAL_WHEEL_HORIZONTAL
  (function enableHorizontalWheel(){
    const wrap = document.querySelector('.calendar');
    if (!wrap) return;

    wrap.addEventListener('wheel', (e) => {
      // If the user holds Shift, let the browser do its default horizontal scroll.
      if (e.shiftKey) return;

      // Convert vertical wheel movement to horizontal scrolling.
      // Only if there actually is horizontal overflow.
      const canScrollX = wrap.scrollWidth > wrap.clientWidth;
      if (!canScrollX) return;

      // If vertical overflow exists and user is actively scrolling vertically inside the calendar,
      // don't hijack it (rare for this layout, but safe).
      const canScrollY = wrap.scrollHeight > wrap.clientHeight;
      if (canScrollY && Math.abs(e.deltaY) < Math.abs(e.deltaX)) return;

      e.preventDefault(); // we’re handling it
      wrap.scrollLeft += (e.deltaY || e.deltaX);
    }, { passive: false });
  })();

  // ANCHOR: RENDER_DEBOUNCE
  let _renderT = null;
  function scheduleRender(delayMs = 220){
    if (_renderT) clearTimeout(_renderT);
    _renderT = setTimeout(async ()=>{
      _renderT = null;
      try { await renderCalendar(); } catch(_){}
    }, delayMs);
  }

  // ANCHOR: BLOCK_WHEEL_ON_NUMBER
  (function blockWheelOnNumberInputs(){
    function stopWheel(e){
      // Only block when the event target is the input itself
      // or inside a .chip to avoid interfering elsewhere.
      const t = e.target;
      if (!(t instanceof HTMLElement)) return;
      const isNum = t.matches('input[type="number"]');
      const inChip = t.closest('.chip');
      const isBulkInv = t.id === 'inv-open' || t.id === 'inv-minstay';
      if (isNum && (inChip || isBulkInv)){
        e.preventDefault();
      }
    }
    // Delegate on the calendar + controls areas
    const cal = document.querySelector('.calendar');
    const ctrls = document.querySelector('.controls');
    if (cal)   cal.addEventListener('wheel', stopWheel, { passive:false });
    if (ctrls) ctrls.addEventListener('wheel', stopWheel, { passive:false });
  })();

  // ANCHOR: CAL_GRID_KB_NAV
  (function wireCalendarKeyboardNav(){
    const cal = document.getElementById('cal-grid');
    if (!cal) return;

    const KIND_ORDER = ['open','price','minstay','closed'];
    const ONE_DAY_MS = 86400000;

    function parseISO(s){ return new Date(s + 'T00:00:00Z'); }
    function iso(d){ return d.toISOString().slice(0,10); }

    function nextDate(isoStr, delta){
      const d = parseISO(isoStr);
      return iso(new Date(d.getTime() + delta*ONE_DAY_MS));
    }

    function focusCell(dateISO, kind){
      const container = document.getElementById('day-' + dateISO);
      if (!container) return false;
      // Ensure target day is visible in the horizontal scroller
      try {
        if (typeof scrollToDate === 'function') scrollToDate(dateISO);
        else container.scrollIntoView({ block: 'nearest', inline: 'nearest' });
      } catch(_) {}
      const sel = (kind === 'price')
        ? container.querySelector('.money input[data-kind="price"]')
        : container.querySelector(`input[data-kind="${kind}"]`);
      if (!sel) return false;
      sel.focus(); sel.select?.();
      return true;
    }


    cal.addEventListener('keydown', (e) => {
      const t = e.target;
      if (!(t instanceof HTMLElement)) return;
      const chipInput = t.closest('.chip')?.querySelector('input,textarea');
      if (!chipInput) return;

      const kind = chipInput.getAttribute('data-kind');     // 'open' | 'price' | 'minstay' | 'closed'
      const dateISO = chipInput.getAttribute('data-date');
      if (!kind || !dateISO) return;

      const k = e.key;
      if (!['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Enter'].includes(k)) return;

      // Always commit current field before moving (ensures 2-decimals / int normalization)
      function commitCurrent(){
        chipInput.dispatchEvent(new Event('blur', { bubbles:false }));
      }

      // Prevent default page scroll / form submit and stop other handlers from double-processing
      e.preventDefault();
      e.stopImmediatePropagation();

      if (k === 'ArrowLeft'){
        commitCurrent();
        const prev = nextDate(dateISO, -1);
        focusCell(prev, kind);
        return;
      }
      if (k === 'ArrowRight'){
        commitCurrent();
        const next = nextDate(dateISO, +1);
        focusCell(next, kind);
        return;
      }
      // Enter = move DOWN within same day; Shift+Enter = move UP
      if (k === 'Enter' && e.shiftKey){
        // Move UP within the day (no toggle on closed)
        if (kind !== 'closed') commitCurrent();
        const idx = KIND_ORDER.indexOf(kind);
        const upKind = KIND_ORDER[Math.max(0, idx - 1)];
        if (upKind !== kind) focusCell(dateISO, upKind);
        return;
      }

      if (k === 'Enter'){
        if (kind === 'closed'){
          // Toggle checkbox and STAY on the same cell (Space also toggles natively)
          if (chipInput.type === 'checkbox') {
            chipInput.checked = !chipInput.checked;
            chipInput.dispatchEvent(new Event('change', { bubbles: false }));
          }
          return;
        }
        // Commit then move DOWN within the same day
        commitCurrent();
        const idx = KIND_ORDER.indexOf(kind);
        const downKind = KIND_ORDER[Math.min(KIND_ORDER.length - 1, idx + 1)];
        if (downKind !== kind) focusCell(dateISO, downKind);
        return;
      }
      if (k === 'ArrowUp'){
        const idx = KIND_ORDER.indexOf(kind);
        const upKind = KIND_ORDER[Math.max(0, idx - 1)];
        if (upKind !== kind) focusCell(dateISO, upKind);
        return;
      }
      if (k === 'ArrowDown'){
        const idx = KIND_ORDER.indexOf(kind);
        const downKind = KIND_ORDER[Math.min(KIND_ORDER.length - 1, idx + 1)];
        if (downKind !== kind) focusCell(dateISO, downKind);
        return;
      }
    }, { capture:true });
  })();

  // Calendar render
  async function renderCalendar(){
    const __myEpoch = ++__renderEpoch;  // capture this call's epoch

    // Defer first paint until rate-plan chips have rendered/synced at least once
    if (!window.__plansReady) {
      const once = () => {
        document.removeEventListener('plans:rendered', once);
        // only re-run if this call is still the latest request
        if (__myEpoch === __renderEpoch) renderCalendar();
      };
      document.addEventListener('plans:rendered', once, { once: true });
      return;
    }

    if (!currentRoomTypeId){ setStatus("Pick a room type on the left.",""); return; }
    prepareRangeDefaults();
    if (!validateRangeOrWarn()) return;

    /* ANCHOR: RATEPLAN_PRIMARY_RESOLVE (stable) */
    // Room-scoped plan selection first; avoid global/localStorage mutations here
    let planIds = [];
    try {
      if (typeof getRoomPlanSelection === 'function') {
        planIds = getRoomPlanSelection(currentRoomTypeId) || [];
      }
    } catch(_) { planIds = []; }

      // Fallbacks (global chips → LS → STD)
      if (!Array.isArray(planIds) || !planIds.length) {
        planIds = Array.isArray(window.__selectedPlanIds)
          ? window.__selectedPlanIds.slice()
          : [];
        if (!planIds.length) {
          try {
            planIds = JSON.parse(localStorage.getItem('rateplan.selectedIds') || '[]');
          } catch (_) {
            planIds = [];
          }
        }
      }
      planIds = planIds.map(Number).filter(n => Number.isFinite(n) && n > 0);
      if (!planIds.length) planIds = [1];

      // Prefer any persisted per-room canonical plan id (e.g. server wrote to 12)
      try {
        let canonical = null;

        // First: in-memory map for this tab
        if (window.__roomCanonicalRatePlanId &&
            Number.isFinite(Number(window.__roomCanonicalRatePlanId[currentRoomTypeId]))) {
          canonical = Number(window.__roomCanonicalRatePlanId[currentRoomTypeId]);
        } else {
          // Second: per-room canonical id from localStorage (survives hard refresh)
          const key = `room:${currentRoomTypeId}:canonicalRatePlanId`;
          const raw = localStorage.getItem(key);
          const n = Number(raw);
          if (Number.isFinite(n)) {
            canonical = n;
          }
        }

        if (canonical && Number.isFinite(canonical) && canonical > 0) {
          const rest = planIds.filter(id => Number(id) !== canonical);
          planIds = [canonical, ...rest];
        }
      } catch (_) {
        // non-fatal; fall back to planIds as-is
      }

      const primaryPlanId = planIds[0];

      // Keep globals consistent for downstream code (do not write to LS here)
      window.__selectedPlanIds = planIds.slice();
      window.currentRatePlanId = primaryPlanId;

      // Build fetch URLs using the room-scoped primary plan
      const invUrl =
        `/extranet/property/rooms/${currentRoomTypeId}/inventory?start=${currentRangeStart}&end=${currentRangeEnd}`;
      const prcUrl =
        `/extranet/property/rooms/${currentRoomTypeId}/prices?start=${currentRangeStart}` +
        `&end=${currentRangeEnd}&ratePlanId=${encodeURIComponent(primaryPlanId)}`;

    if (localStorage.getItem('rooms_debug') === '1'){
      console.debug("Calendar fetch URLs", {
        roomId: currentRoomTypeId,
        invUrl, prcUrl,
        start: currentRangeStart, end: currentRangeEnd,
        primaryPlanId,
        selectedRatePlanIds: planIds.slice()
      });
    }

    disableWhileBusy(true);
    setStatus("Loading calendar…", "");
    setCalLoading(true);
    const [invRes, prcRes] = await Promise.all([
      fetchWithRetry(invUrl, {}, 2, 800),
      fetchWithRetry(prcUrl, {}, 2, 800)
    ]);
    setCalLoading(false);
    disableWhileBusy(false);

    // If a newer render started while we were fetching, bail out (stale)
    if (__myEpoch !== __renderEpoch) return;

    // We’re the latest render: now it’s safe to clear and paint
    calGrid.innerHTML = "";

    let invRows = []; let prcRows = [];
    if (invRes && invRes.ok){ try{ invRows = await invRes.json(); } catch(_){} }
    else { try{ const b = invRes ? await invRes.text() : ""; console.warn("Inventory load failed", { url: invUrl, status: invRes?.status, body: b.slice(0,500) }); } catch(_){} }

    if (prcRes && prcRes.ok){ try{ prcRows = await prcRes.json(); } catch(_){} }
    else { try{ const b = prcRes ? await prcRes.text() : ""; console.warn("Prices load failed", { url: prcUrl, status: prcRes?.status, body: b.slice(0,500) }); } catch(_){} }
    /* INSERT: PLAN_FALLBACK_IF_EMPTY (display-only, no persistence) */
    try {
      if (Array.isArray(prcRows) && prcRows.length === 0) {
        // Guard per (room|range|primaryPlanId) so we try only once per view
        const guardKey = `${currentRoomTypeId}|${currentRangeStart}|${currentRangeEnd}|${primaryPlanId}`;
        window.__planFallbackGuard = window.__planFallbackGuard || {};
        if (!window.__planFallbackGuard[guardKey]) {
          window.__planFallbackGuard[guardKey] = true;

          // Build candidates WITHOUT changing user selection
          let saved = [];
          try {
            saved = JSON.parse(localStorage.getItem('rateplan.selectedIds') || '[]') || [];
          } catch (_) {}

          const cur = Number(primaryPlanId);

          // Derive known plan ids from the visible chips to avoid brute-forcing 1..16
          let fromChips = [];
          try {
            const host = document.getElementById('rateplan-checks');
            if (host) {
              fromChips = [...host.querySelectorAll('input[type="checkbox"][data-plan-id]')]
                .map(n => Number(n.dataset.planId))
                .filter(n => Number.isFinite(n) && n !== cur);
            }
          } catch (_) {}

          // Candidates: saved (other than current) + visible chip ids (other than current)
          const candidates = [...new Set([
            ...saved.filter(n => Number.isFinite(n) && n !== cur),
            ...fromChips
          ])];

          for (const id of candidates) {
            const testUrl = `/extranet/property/rooms/${currentRoomTypeId}/prices?start=${currentRangeStart}&end=${currentRangeEnd}&ratePlanId=${id}`;
            const rr = await fetchWithRetry(testUrl, {}, 1, 0);
            if (rr && rr.ok) {
              let rows = [];
              try {
                rows = await rr.json();
              } catch (_) {}

              if (Array.isArray(rows) && rows.length > 0) {
                // DISPLAY ONLY: do not persist, update URL, or dispatch events.
                prcRows = rows;
                if (localStorage.getItem('rooms_debug') === '1') {
                  console.debug('[plan-fallback DISPLAY-ONLY] selected plan had 0 rows; showing plan', id, 'rows:', rows.length);
                }
                try {
                  setStatus('No prices for the selected plan in this range, showing another available plan (display only).', 'warn');
                } catch (_) {}
                break;
              }
            }
          }
        }
      }
    } catch (e) {
      console.warn('Plan fallback failed', e);
    }

    if (!(invRes?.ok) || !(prcRes?.ok)){
      setStatus(`Loaded with partial data (${invRes?.status ?? "ERR"}/${prcRes?.status ?? "ERR"})`, "warn");
      toast('Loaded with partial data', 'warn');
    }

    const invByDate = new Map(invRows.map(r => [String(r.date).slice(0,10), r]));

    // STICKY PRICE CACHE — keep last known prices per (room, plan) in memory + localStorage
    window.__priceCache = window.__priceCache || new Map();
    const __cacheKey = `${currentRoomTypeId}|${primaryPlanId}`;
    const LS_CACHE_KEY = 'rooms.priceCache.v1';

    // helpers for LS cache
    function __loadPriceLS(){
      try { const o = JSON.parse(localStorage.getItem(LS_CACHE_KEY) || '{}'); return (o && typeof o==='object') ? o : {}; }
      catch(_){ return {}; }
    }
    function __savePriceLS(obj){
      try { localStorage.setItem(LS_CACHE_KEY, JSON.stringify(obj)); } catch(_){}
    }

    let __lsCache = __loadPriceLS();

    try {
      if (Array.isArray(prcRows) && prcRows.length > 0) {
        // Update in-memory cache
        const map = new Map(window.__priceCache.get(__cacheKey) || []);
        prcRows.forEach(r => {
          const d = String(r.date).slice(0,10);
          const p = Number(r.price);
          if (Number.isFinite(p)) map.set(d, p);
        });
        window.__priceCache.set(__cacheKey, map);

        // Persist to localStorage (so values survive full page reload / hub hops)
        const obj = Object.fromEntries(map); // { "2025-10-09": 149.00, ... }
        __lsCache[__cacheKey] = obj;
        __savePriceLS(__lsCache);
      }
    } catch(_) {}

    let prcByDate = new Map(prcRows.map(r => [String(r.date).slice(0,10), r]));

    // If server returned no prices, hydrate from memory cache; if empty, try localStorage cache
    if (prcByDate.size === 0) {
      const mem = window.__priceCache.get(__cacheKey);
      if (mem && mem.size) {
        prcByDate = new Map([...mem.entries()].map(([d,p]) => [d, { date: d, price: p }]));
      } else {
        const lsObj = __lsCache[__cacheKey];
        if (lsObj && typeof lsObj === 'object') {
          const entries = Object.entries(lsObj);
          if (entries.length) {
            prcByDate = new Map(entries.map(([d,p]) => [d, { date: d, price: Number(p) }]));
          }
        }
      }
      if (prcByDate.size) { try { setStatus('Showing last known prices (cached).', 'warn'); } catch(_){} }
    }
    const ONE_DAY = 86400000;
    const daysBetween = (startISO,endISO) => {
      const s = new Date(startISO+"T00:00:00Z"); const e = new Date(endISO+"T00:00:00Z");
      const arr = []; for (let d = new Date(s); d <= e; d = new Date(d.getTime()+ONE_DAY)) arr.push(iso(d));
      return arr;
    };
    const days = daysBetween(currentRangeStart, currentRangeEnd);

    days.forEach(d => {
      const inv = invByDate.get(d);
      const prc = prcByDate.get(d);
      const invOpen    = inv ? clamp(Number(inv.roomsOpen)||0, 0, 9999) : 0;
      const invMinStay = inv && inv.minStay ? clamp(Number(inv.minStay)||1, 1, 365) : "";
      const isClosed   = !!(inv && inv.isClosed);

      const card = document.createElement("div");
      card.className = "day";
      card.id = `day-${d}`;         
      card.setAttribute('data-date', d);
      /* INSERT — ANCHOR: WEEKEND_FLAG */
      const _dow = new Date(d + "T00:00:00Z").getDay();
      const isWE = (_dow === 0 || _dow === 6);
      card.innerHTML = `
        <div class="date">${isWE ? '<span class="we-badge" aria-label="Weekend">WE</span>' : ''} ${d}</div>

        <div class="chip" title="Rooms Open">
          <span class="tag">Open</span>
          <input type="number" min="0" value="${invOpen}" data-date="${d}" data-kind="open">
        </div>

        <div class="chip" title="Price (USD)">
          <span class="tag">Price</span>
          <div class="money">
            <span class="prefix">$</span>
            <input type="text" value="${prc ? Number(prc.price).toFixed(2) : ""}" data-date="${d}" data-kind="price">
          </div>
        </div>

        <div class="chip" title="Min Stay">
          <span class="tag">MinStay</span>
          <input type="number" min="1" value="${invMinStay}" data-date="${d}" data-kind="minstay">
        </div>

        <div class="chip" title="Closed">
          <span class="tag">Closed</span>
          <input type="checkbox" ${isClosed ? 'checked' : ''} data-date="${d}" data-kind="closed">
        </div>
      `;

      // ANCHOR: DIRTY_BADGE_ON_RENDER
      if (dirty.has(d)) card.classList.add('is-dirty');

      ['open','price','minstay','closed'].forEach(kind => {
        const input = card.querySelector(`input[data-kind="${kind}"]`);
        if (!input) return;
        const eventName = (kind === 'closed') ? 'change' : 'input';

        input.addEventListener(eventName, () => {
          const date = input.getAttribute('data-date');

          if (kind === 'closed'){
            setDirty(date, 'isClosed', !!input.checked);
            updateDirtyUI();
            return;
          }

          let val = input.value;

          if (kind === 'open' || kind === 'minstay'){
            if (val === ''){
              input.classList.remove('error');
              setDirty(date, kind === 'open' ? 'roomsOpen' : 'minStay', undefined);
              updateDirtyUI();
              return;
            }
            const n = Number(val);
            if (!Number.isFinite(n) || n < (kind === 'open' ? 0 : 1)){
              input.classList.add('error');
              updateDirtyUI();
              return;
            }
            input.classList.remove('error');
            setDirty(date, kind === 'open' ? 'roomsOpen' : 'minStay', Math.floor(n));
            updateDirtyUI();
            return;
          }

          if (kind === 'price'){
            if (val === ''){
              input.classList.remove('error');
              setDirty(date, 'price', undefined);
              updateDirtyUI();
              return;
            }
            const ok = /^(\d+)(\.\d{1,2})?$/.test(val) && parseFloat(val) >= 0;
            if (!ok){
              input.classList.add('error');
              updateDirtyUI();
              return;
            }
            input.classList.remove('error');
            setDirty(date, 'price', parseFloat(val).toFixed(2));
            updateDirtyUI();
          }
        });
      });

      const priceEl = card.querySelector(`input[data-kind="price"]`);
      if (priceEl){
        priceEl.addEventListener('blur', () => {
          const v = priceEl.value.trim();
          if (v === ''){ updateDirtyUI(); return; }
          const ok = /^(\d+)(\.\d{1,2})?$/.test(v) && parseFloat(v) >= 0;
          if (ok){
            priceEl.value = parseFloat(v).toFixed(2);
            priceEl.classList.remove('error');
          } else {
            priceEl.classList.add('error');
          }
          updateDirtyUI();
        });
      }

      const openEl = card.querySelector(`input[data-kind="open"]`);
      if (openEl){
        openEl.addEventListener('blur', () => {
          const v = openEl.value.trim();
          if (v === ''){ updateDirtyUI(); return; }
          const n = Number(v);
          if (Number.isFinite(n) && n >= 0){
            openEl.value = String(Math.floor(n));
            openEl.classList.remove('error');
          } else {
            openEl.classList.add('error');
          }
          updateDirtyUI();
        });
      }

      const minEl = card.querySelector(`input[data-kind="minstay"]`);
      if (minEl){
        minEl.addEventListener('blur', () => {
          const v = minEl.value.trim();
          if (v === ''){ updateDirtyUI(); return; }
          const n = Number(v);
          if (Number.isFinite(n) && n >= 1){
            minEl.value = String(Math.floor(n));
            minEl.classList.remove('error');
          } else {
            minEl.classList.add('error');
          }
          updateDirtyUI();
        });
      }

      /* ANCHOR: CARD_FOCUS_TRACK */
      (function wireCardFocusTrack(){
        ['open','price','minstay','closed'].forEach(kind=>{
          const input = card.querySelector(`input[data-kind="${kind}"]`);
          if (!input) return;
          input.addEventListener('focus', ()=>{
            const dateISO = input.getAttribute('data-date');
            if (!dateISO) return;
            window.__lastCellFocus = { dateISO, kind };
          });
        });
      })();

      calGrid.appendChild(card);
    });

    // Scroll to the first day in the current window (range start)
    if (currentRangeStart) scrollToDate(currentRangeStart);

    updateDirtyUI();
    if (!status.className.includes("ok")) setStatus("Calendar ready.","");
    
    // Notify listeners that a render just completed (used by Apply buttons, etc.)
    try { document.dispatchEvent(new Event('calendar:rendered')); } catch(_) {}
  }

  /* ANCHOR: RESTORE_LAST_FOCUS */
  (function refocusAfterRender(){
    const last = window.__lastCellFocus;
    if (!last) return;

    // Ensure the target day is visible before refocusing
    try {
      if (typeof scrollToDate === 'function') scrollToDate(last.dateISO);
    } catch(_) {}

    const sel = (last.kind === 'price')
      ? document.querySelector(`#day-${last.dateISO} .money input[data-kind="price"]`)
      : document.querySelector(`#day-${last.dateISO} input[data-kind="${last.kind}"]`);

    if (sel) { try { sel.focus(); sel.select?.(); } catch(_){} }
  })();

  // expose for MN hardfix nav
  window.renderCalendar = renderCalendar;

  function shiftWeeks(deltaWeeks){
    const rsInput=el("range-start");
    const seed=(rsInput && rsInput.value) ? rsInput.value
      : (typeof currentRangeStart==="string"&&currentRangeStart) ? currentRangeStart
      : todayISO();
    const nextStart=new Date(seed+"T00:00:00Z");
    nextStart.setDate(nextStart.getDate() + (deltaWeeks * 7));
    currentAnchor=nextStart;
    applyMonthWindowToRange({ rerender:true });
    setMonthLabel();
  }
  if (monthPrevBtn) monthPrevBtn.addEventListener("click",()=>shiftWeeks(-visibleWeeks));
  if (monthNextBtn) monthNextBtn.addEventListener("click",()=>shiftWeeks(+visibleWeeks));

  // Bulk inventory
  el("apply-inv").addEventListener("click", async ()=>{
    if (!currentRoomTypeId) return setStatus("Select a room type.","error");
    if (!validateRangeOrWarn()) return;
    const start=el("range-start").value, end=el("range-end").value;
    const roomsOpenN=toNumber(el("inv-open").value);
    const minStayN=el("inv-minstay").value ? toNumber(el("inv-minstay").value) : NaN;
    const isClosed=!!el("inv-closed").checked;
    if (!Number.isFinite(roomsOpenN) || roomsOpenN<0) return setStatus("roomsOpen must be a non-negative number","error");
    if (el("inv-minstay").value && (!Number.isFinite(minStayN) || minStayN<1)) return setStatus("minStay must be ≥ 1","error");

    const ONE_DAY=86400000;
    const dates=[]; { const s=new Date(start+"T00:00:00Z"); const e=new Date(end+"T00:00:00Z");
      for(let d=new Date(s); d<=e; d=new Date(d.getTime()+ONE_DAY)) dates.push(iso(d)); }
    const items=dates.map(d=>{ const o={date:d,isClosed,roomsOpen:Math.floor(roomsOpenN)}; if (Number.isFinite(minStayN)) o.minStay=Math.floor(minStayN); return o; });

    disableWhileBusy(true);
    const res = await authFetch(`/extranet/property/rooms/${currentRoomTypeId}/inventory/bulk`, { method:"POST", body: JSON.stringify({ items }) });
    disableWhileBusy(false);

    // Parse body defensively so we never reference an undefined var
    let invResObj; let invRaw = "";
    try {
      invRaw = await res.text();
      try { invResObj = JSON.parse(invRaw); } catch { invResObj = { raw: invRaw }; }
    } catch(_) { invResObj = {}; }

    if (!res.ok){
      setStatus("Inventory apply failed ("+res.status+")","error");
      toast("Inventory apply failed","error");
      return;
    }

    // Correct success copy (Inventory, not Prices)
    setStatus(`Inventory applied to ${invResObj.upserted ?? invResObj.count ?? items.length} day(s) — saved automatically; no need to click “Save changes”.`,"ok");
    toast("Inventory applied (auto-saved)","ok");

    // Verify the same window comes back with updated inventory
    try {
      const verifyUrl = `/extranet/property/rooms/${currentRoomTypeId}/inventory?start=${start}&end=${end}`;
      const verifyRes = await authFetch(verifyUrl);
      const verifyRows = verifyRes.ok ? await verifyRes.json() : [];
      console.log("INV verify GET url:", verifyUrl);
      console.log("INV verify GET rows:", verifyRows);
    } catch(e) {
      console.warn("INV verify GET failed:", e);
    }

    await renderCalendar();
    flashDates(dates);
  });

    // Bulk prices (validates & auto-formats)
  el("apply-price").addEventListener("click", async ()=>{
    if (!currentRoomTypeId) return setStatus("Select a room type.","error");
    if (!validateRangeOrWarn()) return;

    const priceEl = el("price");
    const raw = (priceEl?.value ?? "").trim();
    const moneyRx = /^(\d+)(\.\d{1,2})?$/;

    if (!raw || !moneyRx.test(raw) || parseFloat(raw) < 0){
      if (priceEl) priceEl.classList.add("error");
      return setStatus("Enter a valid non-negative price","error");
    }

    // Normalize to two decimals for both UI and payload
    const priceFixed = parseFloat(raw).toFixed(2);
    if (priceEl){ priceEl.value = priceFixed; priceEl.classList.remove("error"); }

    // Resolve primary plan for the CURRENT ROOM:
    // 1) Prefer the calendar's currentRatePlanId (what renderCalendar actually uses)
    // 2) Then room-scoped selection
    // 3) Then legacy/global → STD(1)
    let ratePlanId;
    if (Number.isFinite(Number(window.currentRatePlanId))) {
      ratePlanId = Number(window.currentRatePlanId);
    } else if (typeof getRoomPlanSelection === 'function') {
      ratePlanId = (getRoomPlanSelection(currentRoomTypeId)[0] || 1);
    } else if (typeof getCanonicalPrimaryPlanId === 'function') {
      ratePlanId = getCanonicalPrimaryPlanId();
    } else {
      ratePlanId = Number(localStorage.getItem('rateplan.lastPlanId') || 1) || 1;
    }
    ratePlanId = (Number.isFinite(ratePlanId) && ratePlanId > 0) ? ratePlanId : 1;

    const start=el("range-start").value, end=el("range-end").value;
    const ONE_DAY=86400000;
    const dates=[]; { const s=new Date(start+"T00:00:00Z"); const e=new Date(end+"T00:00:00Z");
      for(let d=new Date(s); d<=e; d=new Date(d.getTime()+ONE_DAY)) dates.push(iso(d)); }

    // Build normalized items (coerce to Number and round to 2dp)
    const items=dates.map(d=>{
      const n = Number(priceFixed);
      return Number.isFinite(n) ? { date:d, price: Math.round(n * 100) / 100, ratePlanId } : null;
    }).filter(Boolean);

    if (!items.length){
      setStatus("No valid prices to apply.","error");
      return;
    }

    const prcUrl = `/extranet/property/rooms/${currentRoomTypeId}/prices/bulk`;
    console.log("PRC url (final):", prcUrl);
    console.log("PRC payload (final):", { items });

    disableWhileBusy(true);
    const res = await authFetch(prcUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ items })
    });
    disableWhileBusy(false);

      // Capture raw body for debugging even if it's not JSON
      let prcResObj;
      let respRaw = "";
      try {
        respRaw = await res.text();
        try { prcResObj = JSON.parse(respRaw); } catch { prcResObj = { raw: respRaw }; }
      } catch(_) {
        prcResObj = { parseError: true };
      }
      console.log("PRC status:", res.status, prcResObj);

      // Handle non-OK early
      if (!res.ok) {
        setStatus("Price apply failed (" + res.status + ")", "error");
        toast('Price apply failed', 'error');
        return;
      }

      // If server returns a different ratePlanId, sync UI to it (chips-aware)
      if (prcResObj && Number.isFinite(Number(prcResObj.ratePlanId))) {
        const serverPlanId = Number(prcResObj.ratePlanId);
        if (serverPlanId !== ratePlanId) {
          console.warn("Server wrote to different ratePlanId; syncing UI to chips:", serverPlanId);
          window.currentRatePlanId = serverPlanId;

          try {
            // 1) Put serverPlanId first in the chip selection (persisted)
            const LS_KEY = 'rateplan.selectedIds';
            let cur = [];
            try { cur = JSON.parse(localStorage.getItem(LS_KEY) || '[]'); } catch(_) { cur = []; }
            const rest = (Array.isArray(cur) ? cur : [])
              .map(Number)
              .filter(n => Number.isFinite(n) && n !== serverPlanId);
            const next = [serverPlanId, ...rest];
            localStorage.setItem(LS_KEY, JSON.stringify(next));

            // 2) Ensure its checkbox is checked in the UI
            const host = document.getElementById('rateplan-checks');
            const box = host?.querySelector(`input[type="checkbox"][data-plan-id="${serverPlanId}"]`);
            if (box && !box.checked) box.checked = true;

            // 3) Notify listeners so renderCalendar now fetches with the same plan id
            document.dispatchEvent(new CustomEvent('rateplans:changed', { detail: { ids: next } }));
            updateURLFromState?.();
            saveCtx?.();
          } catch(_) {}
        }
      }


      // Success UI
      setStatus(`Prices applied to ${prcResObj.upserted ?? prcResObj.count ?? items.length} day(s) — saved automatically; no need to click “Save changes”.`, "ok");
      toast('Prices applied (auto-saved)', 'ok');
      { const _pElClear = el('price'); if (_pElClear){ _pElClear.value = ''; _pElClear.classList.remove('error'); } }

      // If the GET endpoint returns no rows (backend filter mismatch),
      // still show the new price immediately so the user sees the change.
      // We'll try GET first; if empty, we optimistically fill the tiles.
      // Canonical verify GET using server ratePlanId
      let verifyRows = [];
      try {
        // 1) Canonical plan id from server response (supports flat or .data)
        const rawServerPlanId =
          prcResObj &&
          (prcResObj.ratePlanId ??
           (prcResObj.data && prcResObj.data.ratePlanId));

        const serverPlanId = Number(rawServerPlanId);

        // If server gives a numeric plan id, always trust it.
        const verifyPlan = Number.isFinite(serverPlanId)
          ? serverPlanId
          : ratePlanId;

        console.log(
          "[PRC verify] rawServerPlanId:",
          rawServerPlanId,
          "verifyPlan:",
          verifyPlan
        );

        // 2) Persist canonical plan id for this room into UI state
        try {
          // Global "current" plan for this tab
          window.currentRatePlanId = verifyPlan;

          // Memory-scoped per-room map
          if (!window.__roomCanonicalRatePlanId) {
            window.__roomCanonicalRatePlanId = {};
          }
          window.__roomCanonicalRatePlanId[currentRoomTypeId] = verifyPlan;

          // Persist per-room canonical plan id so it survives hard refreshes
          try {
            const key = `room:${currentRoomTypeId}:canonicalRatePlanId`;
            localStorage.setItem(key, String(verifyPlan));
          } catch (_) {}

          // Keep generic "last plan" for legacy bits
          try {
            localStorage.setItem('rateplan.lastPlanId', String(verifyPlan));
          } catch (_) {}
        } catch (persistErr) {
          console.warn(
            "[PRC verify] failed to persist verifyPlan into window/localStorage",
            persistErr
          );
        }

        // 3) Verify GET using canonical plan id
        const verifyUrl =
          `/extranet/property/rooms/${currentRoomTypeId}/prices` +
          `?start=${start}&end=${end}&ratePlanId=${encodeURIComponent(
            verifyPlan
          )}`;

        console.log("[PRC verify] GET url:", verifyUrl);

        const verifyRes = await authFetch(verifyUrl);
        verifyRows = verifyRes.ok ? await verifyRes.json() : [];

        console.log("[PRC verify] GET rows:", verifyRows);
      } catch (e) {
        console.warn("PRC verify GET failed:", e);
      }


      await renderCalendar();

      // If server GET returned nothing (or a different shape), paint the UI with the posted price.
      if (!Array.isArray(verifyRows) || verifyRows.length === 0) {
        const val = Number(priceFixed).toFixed(2);
        dates.forEach(d => {
          const card = document.getElementById(`day-${d}`);
          const input = card?.querySelector('input[data-kind="price"]');
          if (input) input.value = val;
        });
        console.warn("UI filled optimistically with posted price because verify GET was empty.");
      }

      flashDates(dates);
  });

  // Save (grid edits)
  el("save").addEventListener("click", async ()=>{
    const hasRoomEdits = pendingRoomUpdates.size > 0;
    const hasGridEdits = dirty.size > 0;
    const invalidCount = document.querySelectorAll('.chip input.error').length;
    if (invalidCount > 0){ setStatus(`Fix ${invalidCount} invalid field${invalidCount>1?'s':''} before saving.`,"error"); return; }
    if (!hasRoomEdits && !hasGridEdits){ setStatus("Nothing to save.","warn"); return; }

    setStatus("Saving…"); disableWhileBusy(true);
    try{
      // 1) Apply queued room edits
      if (hasRoomEdits){
        for (const [id, payload] of pendingRoomUpdates.entries()){
          const url = `/extranet/property/rooms/${id}`;
          let r = await authFetch(url, { method:"PATCH", body: JSON.stringify(payload) });

          if (!r.ok && r.status === 400 && Object.prototype.hasOwnProperty.call(payload, 'active')){
            const { active, ...rest } = payload;
            if (Object.keys(rest).length){
              const r2 = await authFetch(url, { method:"PATCH", body: JSON.stringify(rest) });
              if (r2.ok){
                setStatus("Saved. Status change may not be supported yet, skipped.", "warn");
                continue;
              } else {
                r = r2;
              }
            } else {
              setStatus("Status change may not be supported yet, skipped.", "warn");
              continue;
            }
          }

          if (!r.ok && (r.status === 405 || r.status === 404)) {
            r = await authFetch(url, { method:"PUT", body: JSON.stringify({ ...payload, id }) });
          }
          if (!r.ok) throw new Error(`Room ${id} update failed (${r.status})`);
        }
      }

      // 2) Apply calendar edits if any
      // ANCHOR: SAVE_PRIMARY_RATEPLAN
      // Resolve the primary plan id used for these edits (aligned with calendar)
      let _primaryPlanId;
      if (typeof getCanonicalPrimaryPlanId === 'function') {
        _primaryPlanId = getCanonicalPrimaryPlanId(currentRoomTypeId);
      } else {
        const _ids = (typeof window.getSelectedRatePlanIds === 'function')
          ? window.getSelectedRatePlanIds()
          : [];
        _primaryPlanId = _ids.length ? Number(_ids[0]) : Number(window.currentRatePlanId || 1);
      }
      _primaryPlanId = (Number.isFinite(_primaryPlanId) && _primaryPlanId > 0) ? _primaryPlanId : 1;

      // Keep legacy global in sync for other code paths
      window.currentRatePlanId = _primaryPlanId;

      const invItems=[], prcItems=[];
      for (const [date,obj] of dirty.entries()){
        const inv={};
        if (typeof obj.isClosed==='boolean') inv.isClosed = obj.isClosed;
        if (typeof obj.roomsOpen==='number') inv.roomsOpen = obj.roomsOpen;
        if (typeof obj.minStay==='number') inv.minStay = obj.minStay;
        if (Object.keys(inv).length) invItems.push({ date, ...inv });

        // Normalize price: must be a finite non-negative number; round to 2dp
        if (typeof obj.price==='string' && obj.price!=='') {
          const n = Number(obj.price);
          if (Number.isFinite(n) && n >= 0) {
            prcItems.push({ date, price: Math.round(n * 100) / 100, ratePlanId: _primaryPlanId });
          }
        }
      }

      const reqs=[];
      if (invItems.length) {
        reqs.push(authFetch(`/extranet/property/rooms/${currentRoomTypeId}/inventory/bulk`,{
          method:"POST",
          body:JSON.stringify({items:invItems})
        }));
      }
      if (prcItems.length) {
        // Debug visibility mirrors Apply Price path
        console.log("PRC url (save):", `/extranet/property/rooms/${currentRoomTypeId}/prices/bulk`);
        console.log("PRC payload (save):", { items: prcItems });
        reqs.push(authFetch(`/extranet/property/rooms/${currentRoomTypeId}/prices/bulk`,{
          method:"POST",
          body:JSON.stringify({items:prcItems})
        }));
      }
      if (reqs.length){
        const resps = await Promise.all(reqs);
        if (resps.some(r=>!r.ok)) throw new Error(`Grid save failed (${resps.map(r=>r.status).join('/')})`);
      }

      pendingRoomUpdates.clear();
      dirty.clear(); updateDirtyUI();
      await loadRooms();
      if (currentRoomTypeId) await renderCalendar();
      setStatus("Saved.","ok");
      toast('All changes saved', 'ok');
      if (prcItems && prcItems.length){
        const _pElClear2 = el('price');
        if (_pElClear2){ _pElClear2.value = ''; _pElClear2.classList.remove('error'); }
      }
    } catch (e) {
      console.error(e);
      setStatus(String(e.message || "Save error"), "error");
      toast('Save failed', 'error');
    } finally {
      disableWhileBusy(false);
    }
  });

  // Discard (clear unsaved)
  el("discard").addEventListener("click", async ()=>{
    if (busy) return;
    pendingRoomUpdates.clear();
    dirty.clear();
    updateDirtyUI();
    setStatus("Changes discarded.","warn");
    await loadRooms();
    if (currentRoomTypeId) await renderCalendar();
  });

  // Global hotkeys: Save (Cmd/Ctrl+S), Discard (Esc)
  window.addEventListener('keydown', (e) => {
    const saveBtn = el('save');
    const discardBtn = el('discard');
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') {
      e.preventDefault();
      if (saveBtn && !saveBtn.disabled && !busy) saveBtn.click();
    }
    if (e.key === 'Escape') {
      if (discardBtn && !discardBtn.disabled && !busy) discardBtn.click();
    }
  });

  // ANCHOR: HOTKEYS_ALT_NAV
  (function wireAltHotkeys(){
    const prevBtn = document.getElementById('month-prev');
    const nextBtn = document.getElementById('month-next');
    const todayBtn = document.getElementById('month-today');
    const priceEl = document.getElementById('price');
    const invOpenEl = document.getElementById('inv-open');

    window.addEventListener('keydown', (e)=>{
      // Ignore when user is typing in a text input except our combos
      const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
      const isTyping = (tag === 'input' || tag === 'textarea');

      if (e.altKey && !e.ctrlKey && !e.metaKey) {
        // Alt + ArrowLeft / ArrowRight — navigate weeks
        if (e.key === 'ArrowLeft') {
          e.preventDefault();
          prevBtn?.click();
          return;
        }
        if (e.key === 'ArrowRight') {
          e.preventDefault();
          nextBtn?.click();
          return;
        }
        // Alt + T — Today
        if (e.key.toLowerCase() === 't') {
          e.preventDefault();
          todayBtn?.click();
          return;
        }
        // Alt + P — focus Price
        if (e.key.toLowerCase() === 'p') {
          e.preventDefault();
          priceEl?.focus();
          priceEl?.select?.();
          return;
        }
        // Alt + I — focus Inventory roomsOpen
        if (e.key.toLowerCase() === 'i') {
          e.preventDefault();
          invOpenEl?.focus();
          invOpenEl?.select?.();
          return;
        }
      }

      // Prevent our nav combos from interfering when typing freely in inputs
      if (isTyping) return;
    });
  })();

  // ANCHOR: BACK_GUARD_UNSAVED
  (function guardBackWhenDirty(){
    const backBtn = document.getElementById('back');
    if (!backBtn) return;

    backBtn.addEventListener('click', (e)=>{
      const hasRoomEdits = pendingRoomUpdates.size > 0;
      const hasGridEdits = dirty.size > 0;
      const invalidCount = document.querySelectorAll('.chip input.error').length;

      if (hasRoomEdits || hasGridEdits || invalidCount > 0){
        e.preventDefault();
        let msg;
        if (invalidCount > 0) {
          const plural = invalidCount > 1 ? 's' : '';
          msg = 'You have ' + invalidCount + ' invalid field' + plural + '. Leave without fixing/saving?';
        } else {
          msg = 'You have unsaved changes. Leave without saving?';
        }
        if (confirm(msg)){
          // proceed to menu
          location.href = '/partners_app.html';
        }
        // else stay on page
      }
      // if nothing dirty, normal navigation continues via button's onclick
    }, { capture:true });
  })();

  // ANCHOR: COPY_LINK_BTN
    el('copy-link')?.addEventListener('click', async () => {
    // Build URL with both primary plan and the selected list
    const u = new URL(location.href);
    // Primary (first checked) — keep legacy ?plan=
    const ids = (typeof window.getSelectedRatePlanIds === 'function') ? window.getSelectedRatePlanIds() : [];
    const primary = ids.length ? Number(ids[0]) : Number(window.currentRatePlanId || 1);
    if (Number.isFinite(primary)) u.searchParams.set('plan', String(primary));
    // Full selection — new ?plans=1,2,3
    if (ids.length) u.searchParams.set('plans', ids.join(','));
    else u.searchParams.delete('plans');

    const url = u.toString();
    try {
      await navigator.clipboard.writeText(url);
      toast('Link copied to clipboard', 'ok');
    } catch(_) {
      // Fallback for older browsers
      const ta = document.createElement('textarea');
      ta.value = url; document.body.appendChild(ta);
      ta.select(); document.execCommand('copy'); ta.remove();
      toast('Link copied to clipboard', 'ok');
    }
  });

  /* ANCHOR: RATEPLAN_WIRE_NOOP_TO_CHIPS */
    // Canonicalize plan state whenever chips change
    (function wireCanonicalRatePlanSave(){
      function coerceIds(raw){
        try {
          if (Array.isArray(raw)) return raw.map(Number).filter(Number.isFinite);
          if (typeof raw === 'string') {
            return raw.split(',').map(s=>Number(s.trim())).filter(Number.isFinite);
          }
          // Set or iterable of numbers/strings
          if (raw && typeof raw === 'object') {
            const out = [];
            if (typeof raw.forEach === 'function') {
              raw.forEach(v => out.push(Number(v)));
              return out.filter(Number.isFinite);
            }
            if (Symbol.iterator in raw) {
              return Array.from(raw, v => Number(v)).filter(Number.isFinite);
            }
          }
        } catch(_) {}
        return [];
      }

      document.addEventListener('rateplans:changed', e => {
        try {
          const raw = (e && e.detail && e.detail.ids) || [];
          const ids = Array.from(new Set(coerceIds(raw)));
          if (!ids.length) return;

          const primary = ids[0];
          window.__selectedPlanIds = ids.slice();
          window.currentRatePlanId = primary;

          // Persist consistently
          try {
            localStorage.setItem('rateplan.selectedIds', JSON.stringify(ids));
            localStorage.setItem('rateplan.lastPlanId', String(primary));
          } catch(_) {}

          // Keep URL in sync (plan & plans)
          try {
            const url = new URL(location.href);
            if (String(url.searchParams.get('plan')) !== String(primary)) {
              url.searchParams.set('plan', String(primary));
            }
            const plansStr = ids.join(',');
            if (url.searchParams.get('plans') !== plansStr) {
              url.searchParams.set('plans', plansStr);
            }
            history.replaceState({}, '', url.toString());
          } catch(_) {}
          try { sessionStorage.setItem('rooms:lastURL', location.href); } catch(_) {}
          // console.log('[rp] canonicalized ->', { ids, primary });
        } catch(err){
          console.warn('RATEPLAN_WIRE_NOOP_TO_CHIPS canonicalization failed:', err);
        }
      });
    })();
    // === GLOBALIZE wireRatePlanSelector (shim-safe) ===
    (function(){
      if (typeof window.wireRatePlanSelector !== 'function') {
        // Prefer an existing local function if it's already defined
        const local = (typeof wireRatePlanSelector === 'function')
          ? wireRatePlanSelector
          : function(ctx){
              const host = document.getElementById('rateplan-checks');
              const targetId = Number(ctx?.ratePlanId);
              if (host && Number.isFinite(targetId)) {
                const box = host.querySelector(`input[type="checkbox"][data-plan-id="${targetId}"]`);
                if (box) {
                  if (!box.checked) {
                    box.checked = true;
                    box.dispatchEvent(new Event('change'));
                  }
                  window.currentRatePlanId = targetId;
                  return; // only set primary if the chip actually exists
                }
                // Target plan id not present among chips — ignore (no-op)
              }
              // No chips yet or invalid id — no-op; sanitizers will pick a valid primary
            };
        window.wireRatePlanSelector = local;
      }
    })();
  /* ANCHOR: SELECTED_IDS_HELPER (shim-safe) */
  (function(){
    // Always return a stable, non-empty array of numeric plan ids
    if (typeof window.getSelectedRatePlanIds !== 'function') {
      window.getSelectedRatePlanIds = function(){
        try {
          const raw = localStorage.getItem('rateplan.selectedIds') || '[]';
          const ids = JSON.parse(raw);
          const arr = Array.isArray(ids) ? ids.map(Number).filter(Number.isFinite) : [];
          if (arr.length) return arr;
        } catch(_) {}
        const last = Number(localStorage.getItem('rateplan.lastPlanId') || 1) || 1;
        return [last];
      };
    }

    // Single source of truth for the primary id used by renderCalendar()
    if (typeof window.getCanonicalPrimaryPlanId !== 'function') {
      window.getCanonicalPrimaryPlanId = function(){
        const ids = (typeof window.getSelectedRatePlanIds === 'function')
          ? window.getSelectedRatePlanIds()
          : [];
        const first = Number(ids[0]);
        if (Number.isFinite(first) && first > 0) return first;
        const last = Number(localStorage.getItem('rateplan.lastPlanId') || 1) || 1;
        return last;
      };
    }
  })();

  (async function init(){
  const ctx = loadCtx() || {};
    // NEW: restore any missing params from this-tab canonical URL
    (function restoreCanonicalURLFromSession(){
      try{
        const saved = sessionStorage.getItem('rooms:lastURL');
        if (!saved) return;

        const cur  = new URL(location.href);
        const last = new URL(saved, location.origin);

        // Only act on the same page; don't clobber explicit params
        const samePath  = (cur.pathname === last.pathname);
        const keys      = ['room','start','end','plan','plans'];
        let changed     = false;

        if (!samePath) return;

        keys.forEach(k => {
          const curVal  = cur.searchParams.get(k);
          const lastVal = last.searchParams.get(k);
          if (!curVal && lastVal){
            cur.searchParams.set(k, lastVal);
            changed = true;
          }
        });

        if (changed){
          const next = cur.pathname + '?' + cur.searchParams.toString() + cur.hash;
          history.replaceState(null, '', next);
        }
      }catch(_){}
    })();

  // ANCHOR: DEEPLINK_QUERY_IN
  try {
    const qs    = new URLSearchParams(location.search);
    const qRoom = qs.get('room');
    const qStart= qs.get('start');
    const qEnd  = qs.get('end');
    const qPlan = qs.get('plan');
    const qPlans= qs.get('plans'); // e.g., "1,2,6"

    // --- room: numeric or string ids supported
    if (qRoom) {
      const n = Number(qRoom);
      ctx.roomId = Number.isFinite(n) ? n : qRoom;
    }

    // --- date window: strict yyyy-mm-dd; we only seed ctx here, clamp below
    const isoRx = /^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])$/;
    if (qStart && qEnd && isoRx.test(qStart) && isoRx.test(qEnd)) {
      ctx.start = qStart;
      ctx.end   = qEnd;
    }

    // --- plans: single plan id has priority; otherwise use multi-plan list
    let list = [];
    if (qPlans) {
      list = qPlans.split(',')
        .map(s => Number(s.trim()))
        .filter(Number.isFinite);
    }

    if (Number.isFinite(Number(qPlan))) {
      ctx.ratePlanId  = Number(qPlan);
      ctx.ratePlanIds = list.length ? list.slice() : [ctx.ratePlanId];
    } else if (list.length) {
      // No explicit single plan — prefer the first from the list as primary
      ctx.ratePlanIds = list.slice();
      ctx.ratePlanId  = list[0];
    }

    // NOTE: Do NOT persist to localStorage here; RATE_PLAN_INIT owns persistence.
    // If you want to expose the deep-link list to later code:
    try { window.__initialSelectedRatePlanIds = Array.isArray(ctx.ratePlanIds) ? ctx.ratePlanIds.slice() : undefined; } catch(_){}
  } catch(_) {}

  // --- clamp ctx.start/end to today-or-later and sync initial UI (no persistence here)
  {
    const today = todayISO();

    if (ctx.start && ctx.end) {
      let s = String(ctx.start);
      let e = String(ctx.end);
      if (s < today) s = today;   // start must be today or later
      if (e < s)     e = s;       // end must be >= start

      currentRangeStart = s;
      currentRangeEnd   = e;

      const rs = el("range-start"), re = el("range-end");
      if (rs && re){ rs.value = s; re.value = e; }

      currentAnchor = new Date(s + "T00:00:00Z");
      setMonthLabel();
      updateURLFromState?.();      // normalize URL only
    } else {
      const startISO = today;
      currentAnchor = new Date(startISO + "T00:00:00Z");
      setMonthLabel();
      applyMonthWindowToRange({ rerender:false }); // also clamps end >= start
    }
  }

    // Seed initial chip selection from deep link if provided
    if (Array.isArray(ctx.ratePlanIds) && ctx.ratePlanIds.length) {
      window.__initialSelectedRatePlanIds = ctx.ratePlanIds.slice();
      try {
        localStorage.setItem('rateplan.selectedIds', JSON.stringify(window.__initialSelectedRatePlanIds));
      } catch(_) {}
    }

    if (ctx.roomId) currentRoomTypeId = ctx.roomId;
    setRightActive(!!currentRoomTypeId);

    // ANCHOR: RATE_PLAN_INIT
      {
        // Prefer URL ?plans/?plan first (deep links), then stored selection, then lastPlanId, else 1 (STD)
        const url = new URL(location.href);

        const plansRaw = String(url.searchParams.get('plans') || '').trim();
        const plansFromUrl = plansRaw
          ? plansRaw.split(',').map(s => Number(String(s).trim())).filter(Number.isFinite)
          : [];

        const planFromUrl = Number(url.searchParams.get('plan') || '');

        let selected = [];
        try { selected = JSON.parse(localStorage.getItem('rateplan.selectedIds') || '[]'); } catch(_){}
        selected = Array.isArray(selected) ? selected.map(n => Number(n)).filter(Number.isFinite) : [];

        // URL wins when present
        if (plansFromUrl.length) selected = plansFromUrl;

        let last = Number(localStorage.getItem('rateplan.lastPlanId') || '');
        if (!Number.isFinite(last)) last = undefined;

        // Primary: URL ?plan wins, else first selected, else last, else 1
        let primary = (Number.isFinite(planFromUrl) ? planFromUrl : (selected[0] ?? last));
        if (!Number.isFinite(primary)) {
          // Prefer STD from URL plans if present, otherwise leave to sanitize against DB
          primary = (plansFromUrl.length ? plansFromUrl[0] : NaN);
        }

        // Ensure primary is included in selected
        if (!selected.includes(primary)) selected = [primary, ...selected];
        selected = Array.from(new Set(selected));

        if (!Number.isFinite(primary)) primary = 1;

    // Expose for renderers and downstream listeners
    window.__selectedPlanIds = (selected.length ? selected : [primary]).filter(Number.isFinite);
    currentRatePlanId = primary;

    // Persist the resolved canonical state so later code reads the same truth
    try {
      localStorage.setItem('rateplan.selectedIds', JSON.stringify(window.__selectedPlanIds));
      localStorage.setItem('rateplan.lastPlanId', String(currentRatePlanId));
    } catch(_){}

    // Sync URL with the resolved state (plan + plans)
    try {
      if (String(url.searchParams.get('plan')) !== String(primary)) {
        url.searchParams.set('plan', String(primary));
      }
      if (window.__selectedPlanIds?.length) {
        const next = window.__selectedPlanIds.join(',');
        if (url.searchParams.get('plans') !== next) url.searchParams.set('plans', next);
      }
      history.replaceState({}, '', url.toString());
    } catch(_){}

    const roomFromUrl = new URLSearchParams(location.search).get('room');
    const rid = Number(window.currentRoomTypeId || roomFromUrl || 0);
    const plans = await fetchRatePlansSafe(rid);

    // Sanitize selected/primary against the actually available plans
    (function sanitizePrimaryAgainstPlans(){
      try{
        const list = (Array.isArray(plans) ? plans : []);
        const validIds = new Set(list.map(p => Number(p.id)).filter(Number.isFinite));

        // Resolve the real STD id from DB
        const stdId = (() => {
          const hit = list.find(p => String(p.code || '').toUpperCase() === 'STD');
          const n = Number(hit && hit.id);
          return Number.isFinite(n) ? n : 1;
        })();

        // Collect ids from runtime or storage
        let ids = Array.isArray(window.__selectedPlanIds) ? window.__selectedPlanIds.slice() : [];
        if (!ids.length) {
          try { ids = JSON.parse(localStorage.getItem('rateplan.selectedIds') || '[]'); } catch(_) {}
          if (!Array.isArray(ids)) ids = [];
          ids = ids.map(Number).filter(Number.isFinite);
        }

        // Translate legacy 1 -> stdId
        if (stdId !== 1) ids = ids.map(x => (x === 1 ? stdId : x));

        // Must always include STD
        if (!ids.length) ids = [stdId];

        // Keep only ids that exist
        ids = ids.filter(x => validIds.has(x));
        if (!ids.length) ids = [stdId];

        // Primary
        let primary = Number(window.currentRatePlanId);
        if (!Number.isFinite(primary)) primary = ids[0] || stdId;
        if (primary === 1 && stdId !== 1) primary = stdId;

        window.__selectedPlanIds = ids.slice();
        window.currentRatePlanId = primary;

        try {
          localStorage.setItem('rateplan.selectedIds', JSON.stringify(ids));
          localStorage.setItem('rateplan.lastPlanId', String(primary));
        } catch(_){}

        try { updateURLFromState?.(); } catch(_){}
      } catch(e){
        console.warn('sanitizePrimaryAgainstPlans failed', e);
      }
    })();

    populateRatePlanDropdown(plans);

    if (lastRatePlanLoadNote) {
      const sel = document.getElementById('ratePlanSelect');
      if (sel) sel.title = lastRatePlanLoadNote;
      setStatus(lastRatePlanLoadNote, lastRatePlanLoadNote.includes('error') ? 'error' : 'warn');
    }

    wireRatePlanSelector({ ratePlanId: currentRatePlanId });

    await loadRooms();
    if (currentRoomTypeId){
      await renderCalendar();
    } else {
      const first = document.querySelector(".room");
      if (first){ first.click(); void renderCalendar(); }
    }
    try { updateURLFromState(); } catch(_){}
    try { sessionStorage.setItem('rooms:lastURL', location.href); } catch(_){}
  }
  /* end RATE_PLAN_INIT */
})(); // closes the surrounding async IIFE

  /* ANCHOR: PLANS_PANEL_RENDER */
  function renderPlansPanel(plans){
    try{
      const list = document.getElementById('plans-list');
      if (!list) return;
      if (list.children && list.children.length > 0) return; // keep existing editable rows
      if (!Array.isArray(plans) || plans.length === 0){
        list.innerHTML = `<div class="note">No rate plans configured.</div>`;
        return;
      }

      function describeRule(p){
        const isStd = !!p.isDefault || (String(p.kind || '').toUpperCase() === 'NONE') || p.id === 1;
        if (isStd) return 'Standard price (base)';

        const kind = String(p.kind || '').toUpperCase();
        const val  = Number(p.value);
        if (kind === 'PERCENT' && Number.isFinite(val)){
          return (val >= 0 ? `+${val}% from Standard` : `${val}% from Standard`);
        }
        if (kind === 'ABSOLUTE' && Number.isFinite(val)){
          const v = Math.abs(val).toFixed(2);
          return (val >= 0 ? `+$${v} from Standard` : `−$${v} from Standard`);
        }
        return 'Derived from Standard';
      }

      list.innerHTML = plans.map(p => {
        const code = String(p.code || '').toUpperCase();
        // base label (no “(1)” suffixes)
        let name = String(p.name || p.code || `Plan ${p.id}`).replace(/\s*\(\d+\)\s*$/,'');

        const badge = p.code ? String(p.code) : (p.isDefault ? 'default' : `id:${p.id}`);
        return `
          <div style="display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center;padding:6px 8px;border:1px solid var(--border);border-radius:8px;background:var(--panel-2);">
            <div>
              <div style="font-weight:600">${name}</div>
              <div class="note">${describeRule(p)}</div>
            </div>
              <div class="note" style="padding:2px 8px;border:1px solid var(--border);border-radius:999px;background:var(--chip);">${badge}</div>
          </div>
        `;
      }).join('');
    }catch(_){}
  }

  // Populate once on load (uses existing fetchRatePlansSafe fallback behavior)
  (function ensurePlansPanel(){
    try{
      if (typeof fetchRatePlansSafe === 'function'){
        const roomFromUrl = new URLSearchParams(location.search).get('room');
        const rid = Number(window.currentRoomTypeId || roomFromUrl || 0);

        fetchRatePlansSafe(rid)
          .then(plans => { renderPlansPanel(plans); })
          .catch(() => { renderPlansPanel([{ id:1, name:'Standard', isDefault:true, kind:'NONE' }]); });
      } else {
        renderPlansPanel([{ id:1, name:'Standard', isDefault:true, kind:'NONE' }]);
      }
    }catch(_){
      renderPlansPanel([{ id:1, name:'Standard', isDefault:true, kind:'NONE' }]);
    }
  })();

  /* ANCHOR: PLAN_RULE_EDITORS */
  (function wirePlanRuleEditors(){
    const panel = document.getElementById('plans-panel');
    if (!panel) return;

  // Seed a single source of truth for rule drafts (read once from the panel)
  (function preloadRuleDrafts(){
    try {
      const rows = panel.querySelectorAll('.plan-row[data-plan-code]');
      const map = {};
      rows.forEach(row => {
        const code = String(row.getAttribute('data-plan-code') || '').toUpperCase();
        if (!code) return;

        const selSign  = row.querySelector('select[data-field="sign"]');
        const inpValue = row.querySelector('input[data-field="value"]');
        const selUnit  = row.querySelector('select[data-field="unit"]');

        const rawSign  = (selSign?.value || '').trim();          // '+' | '-' | ''
        const rawUnit  = (selUnit?.value || '').trim();          // '$' | '%' | ''
        const rawVal   = (inpValue?.value ?? '').trim();         // string (may be '')

        // keep as-is; the hydrator in attachRow will validate/normalize
        map[code] = {
          sign: rawSign,
          unit: rawUnit,
          value: rawVal
        };
      });
      window.__preloadedRuleDrafts = map;
    } catch (_) {
      window.__preloadedRuleDrafts = {};
    }
  })();

  // Draft persistence for numeric rules (survives refresh until a successful save)
  const LS_KEY_DRAFTS = 'rateplan.ruleDrafts'; // shape: { CODE: { sign:'-', unit:'%', value: 10 } }
  function loadDrafts(){
    try { return JSON.parse(localStorage.getItem(LS_KEY_DRAFTS) || '{}') || {}; } catch(_) { return {}; }
  }
  function saveDrafts(map){
    try { localStorage.setItem(LS_KEY_DRAFTS, JSON.stringify(map || {})); } catch(_) {}
  }
  const ruleDrafts = loadDrafts();

    // Local scratch state for pending edits
    const state = {}; // e.g., { BRKF: {sign:'-', unit:'$', value:15}, NRF:{sign:'-', unit:'%', value:10} }
    // === Draft persistence for rule editors (no overlap with existing symbols) ===
    const LS_KEY_RULE_DRAFTS = 'rateplan.ruleDrafts'; // { STD:{sign:'-',unit:'$',value:0}, BRKF:{…}, NRF:{…} }

    function loadRuleDrafts(){
      try {
        const raw = localStorage.getItem(LS_KEY_RULE_DRAFTS);
        const obj = raw ? JSON.parse(raw) : {};
        return (obj && typeof obj === 'object') ? obj : {};
      } catch(_) { return {}; }
    }

    function saveRuleDraft(code, cfg){
      try {
        const cur = loadRuleDrafts();
        cur[code] = { sign: cfg.sign, unit: cfg.unit, value: cfg.value };
        localStorage.setItem(LS_KEY_RULE_DRAFTS, JSON.stringify(cur));
      } catch(_) {}
    }

    function clearRuleDrafts(codes){
      try {
        if (!Array.isArray(codes) || !codes.length){
          localStorage.removeItem(LS_KEY_RULE_DRAFTS);
          return;
        }
        const cur = loadRuleDrafts();
        codes.forEach(c => delete cur[c]);
        localStorage.setItem(LS_KEY_RULE_DRAFTS, JSON.stringify(cur));
      } catch(_) {}
    }

    // Preload drafts for initial hydration in attachRow()
    const __preloadedRuleDrafts = loadRuleDrafts();

    /* === hydrate panel row from server === */
    function applyServerRuleToRow(row, plan){
      const selSign  = row.querySelector('select[data-field="sign"]');
      const selUnit  = row.querySelector('select[data-field="unit"]');
      const inpValue = row.querySelector('input[data-field="value"]');

      const kind = String(plan.kind || '').toUpperCase();  // 'PERCENT' | 'ABSOLUTE' | 'NONE'
      const v    = Number(plan.value);
      if (!Number.isFinite(v)) return;

      const sign = (v < 0) ? '-' : '+';
      const mag  = Math.abs(v);

      if (selSign)  selSign.value  = sign;
      if (selUnit)  selUnit.value  = (kind === 'PERCENT') ? '%' : '$';
      if (inpValue){
        inpValue.value = String(mag);
        // drive preview + validity without requiring user input
        inpValue.dispatchEvent(new Event('input'));
      }
    }

    /* when plans panel finishes rendering, push server rules into rows by code */
    document.addEventListener('plans:rendered', (e) => {
      const plans = Array.isArray(e.detail?.plans) ? e.detail.plans : [];
      plans.forEach(p => {
        const code = String(p.code || '').toUpperCase();
        if (!code) return;
        const row = panel.querySelector(`.plan-row[data-plan-code="${code}"]`);
        if (row) applyServerRuleToRow(row, p);
      });
    });

    const EXAMPLE_BASE = 100; // $100 example to show preview

    function calcPreview(sign, unit, value){
      const v = Number(value);
      if (!Number.isFinite(v) || v < 0) return null;
      let out = EXAMPLE_BASE;
      if (unit === '%'){
        const delta = (EXAMPLE_BASE * v) / 100;
        out = sign === '-' ? (EXAMPLE_BASE - delta) : (EXAMPLE_BASE + delta);
      } else {
        out = sign === '-' ? (EXAMPLE_BASE - v) : (EXAMPLE_BASE + v);
      }
      return Math.max(0, Math.round(out * 100) / 100);
    }

    function refreshSaveEnabled(){
    const btn = document.getElementById('save-plan-rules');
    if (!btn) return;

    const rows = panel.querySelectorAll('.plan-row[data-plan-code]');

    let numericInvalid   = false;  // any row has a bad numeric value
    let anyNumericGiven  = false;  // at least one row has a number filled in

    rows.forEach(row => {
      const code = row.getAttribute('data-plan-code');
      const cfg  = state[code] || {};

      // ---- numeric rules: empty is neutral/valid; if present must be >= 0
      const val = (cfg && cfg.value !== undefined) ? cfg.value : NaN;
      const hasNumber = (val !== '' && Number.isFinite(Number(val)));
      if (hasNumber) {
        anyNumericGiven = true;
        if (!(
          (cfg.sign === '+' || cfg.sign === '-') &&
          (cfg.unit === '$' || cfg.unit === '%') &&
          Number(val) >= 0
        )) {
          numericInvalid = true;
        }
      }
    });

    // Enable when:
    // - no invalid numbers, AND
    // - at least one numeric rule provided
    btn.disabled = !!(numericInvalid || !anyNumericGiven);
  }

    function attachRow(row){
      const code = String(row.getAttribute('data-plan-code') || '').toUpperCase();
      if (!code) return;

      const selSign  = row.querySelector('select[data-field="sign"]');
      const inpValue = row.querySelector('input[data-field="value"]');
      const selUnit  = row.querySelector('select[data-field="unit"]');
      const prevEl = row.querySelector('[data-field="preview"]');

      // Plan name element (used for display/metadata only)
      const nameEl = row.querySelector('[data-field="name"]');
      
      // Seed from drafts (if present), else from DOM
      const draft = __preloadedRuleDrafts[code];
      const seedSign  = (draft && (draft.sign === '+' || draft.sign === '-')) ? draft.sign : (selSign?.value || '-');
      const seedUnit  = (draft && (draft.unit === '%' || draft.unit === '$')) ? draft.unit : (selUnit?.value || '$');
      const seedValue = (draft && Number.isFinite(Number(draft.value))) ? Number(draft.value) : Number(inpValue?.value || inpValue?.placeholder || 0);

      // Write hydrated values into the inputs before first update()
      if (selSign)  selSign.value  = seedSign;
      if (selUnit)  selUnit.value  = seedUnit;
      if (inpValue) inpValue.value = String(seedValue);

      // Store seeded state
      state[code] = { sign: seedSign, unit: seedUnit, value: seedValue };

      try { document.dispatchEvent(new CustomEvent('planRules:hydrated', { detail:{ drafts: __preloadedRuleDrafts } })); } catch(_){}

      function update(){
        const sign  = selSign?.value || '-';
        const unit  = selUnit?.value || '$';
        const value = inpValue?.value === '' ? NaN : Number(inpValue.value);

        // Store
        state[code] = { sign, unit, value: Number.isFinite(value) ? value : NaN };

        // Persist draft immediately so a hard refresh restores it
        saveRuleDraft(code, { sign, unit, value: Number.isFinite(value) ? value : NaN });

        // Preview
        const sample = calcPreview(sign, unit, value);
        if (prevEl){
          if (sample == null){
            prevEl.textContent = `Example: $${EXAMPLE_BASE} → —`;
          } else {
            prevEl.textContent = `Example: $${EXAMPLE_BASE} → $${sample.toFixed(2)}`;
          }
        }
        // Update the small descriptor under the plan name to match current UI numbers
        const meta = row.querySelector('.plan-meta, .note');
        if (meta){
          const signTxt = (selSign?.value === '-') ? '−' : '+';
          const unitTxt = (selUnit?.value === '%') ? '%' : '$';
          const nVal    = Number.isFinite(value) ? Number(value) : NaN;
          if (!Number.isFinite(nVal)){
            meta.textContent = 'Rule applies to Standard price';
          } else {
            meta.textContent = (unitTxt === '%')
              ? `${signTxt}${nVal}% from Standard`
              : `${signTxt}$${nVal.toFixed(2)} from Standard`;
          }
        }

        // Basic validity styling
        if (inpValue){
          const bad = !(Number.isFinite(value) && value >= 0);
          inpValue.classList.toggle('error', bad);
        }

        refreshSaveEnabled();
      }

      ['change','input','blur'].forEach(ev => {
        selSign?.addEventListener(ev, update);
        selUnit?.addEventListener(ev, update);
        inpValue?.addEventListener(ev, update);
      });

      // Initial paint
      update();
    }

    panel.querySelectorAll('.plan-row[data-plan-code]').forEach(attachRow);
    
    /* reset a single row back to server rule */
    panel.addEventListener('click', async (e) => {
      const a = e.target.closest('a[data-act="reset"]');
      if (!a) return;
      e.preventDefault();
      const row = a.closest('.plan-row[data-plan-code]');
      const code = row?.getAttribute('data-plan-code');
      if (!code) return;
      try{
        const roomFromUrl = new URLSearchParams(location.search).get('room');
        const rid = Number(window.currentRoomTypeId || roomFromUrl || 0);
        const plans = await fetchRatePlansSafe(rid);

        const p = (plans || []).find(x => String(x.code || '').toUpperCase() === String(code).toUpperCase());
        if (p) applyServerRuleToRow(row, p);
      }catch(_){}
    });

    // Expose pending rules for later POST (next step will use this)
    window.__pendingPlanRules = state;
  })();
  
    /* ANCHOR: PLAN_RULES_SAVE */
    (function wirePlanRulesSave(){
    const btn = document.getElementById('save-plan-rules');
    if (!btn) return;

    btn.addEventListener('click', async () => {
      try {
        if (!window.__pendingPlanRules) {
          setStatus('No rule changes detected.', 'warn');
          return;
        }

        const rules = window.__pendingPlanRules || {};
        const rows = document.querySelectorAll('#plans-panel .plan-row[data-plan-code]');
        const plans = Array.from(rows).map(row => {
          const code   = row.getAttribute('data-plan-code');
          const cfg    = rules[code] || {};
          const nameEl = row.querySelector('[data-field="name"]');
          const name   = nameEl ? (nameEl.textContent || '').trim() : undefined;

          const sign  = (cfg.sign === '-') ? -1 : +1;
          const unit  = (cfg.unit === '%') ? 'PERCENT' : 'ABSOLUTE';
          const raw   = Number(cfg.value);
          const value = Number.isFinite(raw) ? (sign * Math.abs(raw)) : 0;

          return { code, name, kind: unit, value };
        }).filter(p => p && p.code);

        // Try backend save
        let status = 0, ok = false, res;
        try {
          const pid = getRatePlanPropertyId();
          const rid = Number(window.currentRoomTypeId);
          if (!Number.isFinite(pid) || pid <= 0 || !Number.isFinite(rid) || rid <= 0) throw new Error('missing ids');

          const postUrl =
            `/extranet/property/rateplans?propertyId=${encodeURIComponent(String(pid))}` +
            `&roomTypeId=${encodeURIComponent(String(rid))}`;

          res = await authFetch(postUrl, {
            method: 'POST',
            body: JSON.stringify({ plans })
          });
          status = res ? res.status : 0;
          ok = !!(res && res.ok);
        } catch(_){}

        if (ok) {
          setStatus('Plan rules saved.', 'ok');
          toast('Plan rules saved', 'ok');
          // Backend accepted — clear the saved drafts for the codes we just posted
          try {
            const postedCodes = (Array.isArray(plans) ? plans.map(p=>p.code).filter(Boolean) : []);
            clearRuleDrafts(postedCodes.length ? postedCodes : undefined); // if unknown, nuke all
          } catch(_) {}
        } else {
          setStatus(`Could not save plan rules (${status || 'ERR'}). UI kept your inputs.`, 'warn');
          toast('Save skipped — backend not ready', 'warn');
        }

        // Refresh plans and repaint UI
        try {
          const fresh = await fetchRatePlansSafe();
          try {
            document.dispatchEvent(new CustomEvent('rateplans:fetched', { detail:{ plans: fresh } }));
          } catch(_){}
          if (typeof populateRatePlanDropdown === 'function') populateRatePlanDropdown(fresh);
          if (typeof renderPlansPanel === 'function') renderPlansPanel(fresh);
        } catch(_) {}
      } catch (e) {
        console.warn('Plan rules save error:', e);
        setStatus('Save failed — see console for details.', 'error');
        toast('Plan rules save failed', 'error');
      }
    });
  })();
})(); /* end main IIFE */
</script>

<!-- FP: MN-HARDFIX-LOCK — single source of truth for month-nav; exact 3-week stepping -->
<script>
(() => {
  const iso = (d)=>d.toISOString().slice(0,10);
  const addDaysISO=(isoStr,n)=>{ const d=new Date(isoStr+"T00:00:00Z"); d.setDate(d.getDate()+n); return iso(d); };
  const setLabel = (sISO) => {
  const lbl = document.getElementById('month-label');
  if (!lbl) return;
  try {
    lbl.textContent = new Date(sISO + 'T00:00:00Z').toLocaleString(undefined, {
      month: 'short',
      year: 'numeric'
    });
  } catch (_) {
    lbl.textContent = sISO;
  }
};

// Current window size in days, default 7 if range not set
const getSpanDays = () => {
  const rsEl = document.getElementById('range-start');
  const reEl = document.getElementById('range-end');
  if (rsEl && reEl && rsEl.value && reEl.value) {
    const d1 = new Date(rsEl.value + 'T00:00:00Z');
    const d2 = new Date(reEl.value + 'T00:00:00Z');
    const ms = d2.getTime() - d1.getTime();
    const span = Math.round(ms / 86400000) + 1;
    if (span >= 1 && span <= 21) return span;
  }
  return 7; // default window
};

const setWindow = (sISO, doRender = true) => {
  const span = getSpanDays();
  const eISO = addDaysISO(sISO, span - 1);
  const rs = document.getElementById('range-start');
  const re = document.getElementById('range-end');
  if (rs && re) {
    rs.value = sISO;
    re.value = eISO;
  }
  window.currentRangeStart = sISO;
  window.currentRangeEnd = eISO;
  window.currentAnchor = new Date(sISO + 'T00:00:00Z');
  setLabel(sISO);
  if (typeof window.updateURLFromState === 'function') window.updateURLFromState();
  if (doRender && typeof window.renderCalendar === 'function') window.renderCalendar();
};

  const prev=document.getElementById('month-prev'), next=document.getElementById('month-next'), todayBtn=document.getElementById('month-today');
  if (!prev||!next){ console.warn('[MN-HARDFIX-LOCK] nav buttons missing'); return; }
  prev.onclick=null; next.onclick=null; if (todayBtn) todayBtn.onclick=null;
  const install=(el,dir)=>{ el.addEventListener('click',(ev)=>{ ev.stopImmediatePropagation(); ev.preventDefault();
    const rs=document.getElementById('range-start')?.value || window.currentRangeStart;
    const re=document.getElementById('range-end')?.value   || window.currentRangeEnd || rs;
    const span = getSpanDays();
    const nextStart = (dir === 'next') ? addDaysISO(re,+1) : addDaysISO(rs,-span);
    setWindow(nextStart,true);
  },{capture:true}); };
  install(prev,'prev'); install(next,'next');
  if (todayBtn){ todayBtn.addEventListener('click',(ev)=>{ ev.stopImmediatePropagation(); ev.preventDefault(); const t=iso(new Date()); setWindow(t,true); },{capture:true}); }
  const initial=document.getElementById('range-start')?.value || window.currentRangeStart || iso(new Date());
  setWindow(initial,false);
})();
</script>

<!-- PLANS PANEL: compact controls + vertical scroll -->
<style id="plans-panel-compact">
  #plans-panel .rule-editor select[data-field="sign"]{
    width: 3.2ch; min-width: 3.2ch; max-width: 3.2ch; text-align:center;
    padding-left: 6px; padding-right: 18px;
  }
  #plans-panel .rule-editor input[data-field="value"]{
    width: 6ch; min-width: 6ch; max-width: 6ch; text-align: right;
  }
  #plans-panel .rule-editor select[data-field="unit"]{
    width: 3.6ch; min-width: 3.6ch; max-width: 3.6ch; text-align:center;
    padding-left: 6px; padding-right: 18px;
  }
  .plans-panel{
    max-height: 42vh;
    overflow-y: auto;
    overscroll-behavior: contain;
  }
  #plans-panel .plan-meta{ margin-top: 2px; }
  #plans-panel .rule-editor{ gap: 6px; }
  #plans-panel [data-field="name"] .name-hint{
    font-weight: 400;
    opacity: .7;
    font-style: italic;
  }
</style>

<script>
(() => {
  const panel = document.getElementById('plans-panel');
  if (panel){
    panel.addEventListener('wheel', (e) => {
      const canScrollY = panel.scrollHeight > panel.clientHeight;
      if (canScrollY){
        e.stopPropagation();
      }
    }, { capture: true, passive: true });
  }
})();
</script>

<style id="plans-panel-2col">
  #plans-panel .plans-list{
    display: grid;
    grid-template-columns: 1fr;
    gap: 10px;
  }
  @media (min-width: 1100px){
    #plans-panel .plans-list{
      grid-template-columns: 1fr 1fr;
    }
  }
  /* Make each plan card stretch nicely within its grid cell */
  #plans-panel .plan-row{
    height: 100%;
  }
</style>
<!-- ANCHOR: PLANS_PANEL_SELF_HEAL (empty-panel recovery) -->
<script>
(function plansPanelSelfHeal(){
  // Debounce guard for repeated events
  const KEY = '__plansPanelHealTick';
  const LS_KEYS = ['rateplans.ids','rateplan.ids','rateplans.lastIds','rateplan.lastIds'];

  async function fetchPlans(roomId){
    const rid = Number(roomId);
    const list = await fetchRatePlansSafe(rid);
    return (Array.isArray(list) ? list : [])
      .map(p => ({
        id: Number(p.id),
        code: String(p.code || '').toUpperCase(),
        name: String(p.name || p.code || `Plan ${p.id}`)
      }))
      .filter(p => Number.isFinite(p.id));
  }

  async function ensurePlansRendered(sourceLabel){
    const roomId = window.currentRoomTypeId || (window.__lastRenderedRoom||{}).id;
    if (!roomId) return;

    const panel = document.getElementById('plans-panel');
    if (!panel) return;

    const hasRows = panel.querySelectorAll('.plan-row').length > 0;
    if (hasRows) return; // already good

    // Clear stale LS expectations that can fight the DOM
    try { LS_KEYS.forEach(k => localStorage.removeItem(k)); } catch(_){}

    // Use cache first
    window.__cachedPlansByRoom = window.__cachedPlansByRoom || new Map();
    let plans = window.__cachedPlansByRoom.get(roomId);

    if (!plans || !plans.length) {
      // Fetch fresh from API
      const apiPlans = await fetchPlans(roomId);
      plans = (typeof window.buildRenderablePlans === 'function')
        ? window.buildRenderablePlans(apiPlans)
        : apiPlans;
      window.__cachedPlansByRoom.set(roomId, plans);
    }

    // Render
    if (typeof window.renderPlansPanel === 'function') {
      window.renderPlansPanel(plans);
    }

    // Broadcast fresh IDs so integrity checks realign
    const ids = plans.map(p => p.id).sort((a,b)=>a-b);
    document.dispatchEvent(new CustomEvent('rateplans:changed', { detail:{ ids: ids.slice(), source: `heal:${sourceLabel||''}`}}));

    // Log for debug
    const domIds = Array.from(panel.querySelectorAll('.plan-row[data-plan-id]'))
                   .map(el => Number(el.dataset.planId)).sort((a,b)=>a-b);
    console.info('[PLANS_PANEL_SELF_HEAL]', { roomId, ids, domIds, source: sourceLabel });
  }

  // Also run after calendar (room) render just in case
  document.addEventListener('calendar:rendered', () => {
    cancelAnimationFrame(window[KEY]);
    window[KEY] = requestAnimationFrame(() => ensurePlansRendered('calendar:rendered'));
  }, { capture:false });
})();
</script>

<!-- ANCHOR: PLANS_PANEL_MIN_API_LOADER (define missing plan funcs) -->
<script>
(function ensurePlanFns(){
  // --- helpers ---------------------------------------------------------------
  function uniqNums(arr){
    var out = [];
    var seen = Object.create(null);
    for (var i=0; i<(arr||[]).length; i++){
      var n = arr[i];
      if (typeof n === 'number' && isFinite(n) && !seen[n]){
        seen[n] = true;
        out.push(n);
      }
    }
    return out;
  }

  function qsaNums(sel, attr, root){
    attr = attr || 'data-plan-id';
    root = root || document;
    var list = root.querySelectorAll(sel);
    var out = [];
    for (var i=0; i<list.length; i++){
      var v = Number(list[i].getAttribute(attr));
      if (isFinite(v)) out.push(v);
    }
    return out;
  }

  function buildCodeIdMap(plans){
    var map = new Map();
    var arr = Array.isArray(plans) ? plans : [];
    for (var i=0; i<arr.length; i++){
      var p = arr[i] || {};
      var id = Number(p.id || p.ratePlanId);
      var code = String(p.code || '').toUpperCase();
      if (isFinite(id) && code) map.set(code, id);
    }
    return map;
  }

    // --- shims (only if missing) ----------------------------------------------
  if (typeof window.buildRenderablePlans !== 'function') {
    window.buildRenderablePlans = function(planObjs){
      var arr = Array.isArray(planObjs) ? planObjs : [];
      var out = [];
      for (var i=0; i<arr.length; i++){
        var p = arr[i] || {};
        var id = Number(p.id || p.ratePlanId);
        if (!isFinite(id)) continue;
        out.push({
          id:   id,
          code: String(p.code || '').toUpperCase(),
          name: p.name || p.code || ('Plan ' + (p.id || p.ratePlanId)),
          // keep DB truth
          active: (p.active === undefined) ? true : !!p.active,
          isDefault: !!p.isDefault,
          kind: String(p.kind || '').toUpperCase(),
          value: (p.value === undefined || p.value === null) ? 0 : Number(p.value)
        });
      }
      return out;
    };
    console.info('[PLANS_PANEL] shimmed buildRenderablePlans');
  }

  if (typeof window.loadRatePlansForRoom !== 'function') {
    // Augments API plans with chip-derived plans before caching.
        window.loadRatePlansForRoom = function(roomId){
        if (!roomId) return Promise.resolve([]);

        function normPlans(raw){
          var out = [];
          var arr = Array.isArray(raw) ? raw : (raw && (raw.rows || raw.plans) ? (raw.rows || raw.plans) : []);
          for (var i = 0; i < arr.length; i++){
            var p  = arr[i] || {};
            var id = Number(p.id || p.ratePlanId);
            if (!isFinite(id)) continue;
            out.push({
              id:   id,
              code: String(p.code || '').toUpperCase(),
              name: p.name || p.code || ('Plan ' + (p.id || p.ratePlanId))
            });
          }
          return out;
        }

        function chipPlans(){
          var list = document.querySelectorAll('#rateplan-checks .chip[data-plan-id]');
          var out  = [];
          for (var i = 0; i < list.length; i++){
            var el  = list[i];
            var id  = Number(el.getAttribute('data-plan-id'));
            if (!isFinite(id)) continue;
            var code  = String(el.getAttribute('data-plan-code') || '').toUpperCase();
            var label = (el.textContent || '').trim();
            out.push({ id: id, code: code, name: label || code || ('Plan ' + id) });
          }
          return out;
        }

        function unionById(a, b){
          var seen = Object.create(null), out = [];
          function add(arr){
            for (var i = 0; i < (arr || []).length; i++){
              var p = arr[i]; if (!p) continue;
              var id = Number(p.id);
              if (!isFinite(id) || seen[id]) continue;
              seen[id] = 1;
              out.push(p);
            }
          }
          add(a);
          add(b);
          return out;
        }

        // Use cache first to avoid refetching for the same room repeatedly
        window.__cachedPlansByRoom = window.__cachedPlansByRoom || new Map();
        var cached = window.__cachedPlansByRoom.get(roomId);
        if (Array.isArray(cached) && cached.length){
          if (typeof window.renderPlansPanel === 'function') window.renderPlansPanel(cached);
          return Promise.resolve(cached);
        }

        var pid = Number((window.state && (window.state.partnerId || window.state.propertyId)) || 2);
        var url = '/extranet/property/rateplans?propertyId=' + encodeURIComponent(String(pid)) + '&roomTypeId=' + encodeURIComponent(String(roomId));
        var fetcher = (typeof window.authFetch === 'function') ? window.authFetch : fetch;

        return fetcher(url, { method: 'GET' })
          .then(function(r){ return r.json(); })
          .then(function(j){
            var apiPlans     = normPlans(j);
            var chipAugments = chipPlans();
            var merged       = unionById(apiPlans, chipAugments);

            // Cache by room so future callers hit memory instead of network
            window.__cachedPlansByRoom = window.__cachedPlansByRoom || new Map();
            window.__cachedPlansByRoom.set(roomId, merged);

            // Render panel from merged plans
            if (typeof window.renderPlansPanel === 'function') window.renderPlansPanel(merged);
            return merged;
          })
          .catch(function(e){
            // API failed, keep UI consistent with whatever chips indicate
            var fallback = chipPlans();
            window.__cachedPlansByRoom = window.__cachedPlansByRoom || new Map();
            window.__cachedPlansByRoom.set(roomId, fallback);
            if (typeof window.renderPlansPanel === 'function') window.renderPlansPanel(fallback);
            return fallback;
          });
      };
    console.info('[PLANS_PANEL] shimmed loadRatePlansForRoom (chip-augmented)');
  }

    // After calendar builds, ensure plans for current room are loaded at least once
    document.addEventListener('calendar:rendered', function(){
      try {
        var roomId = window.currentRoomTypeId || ((window.__lastRenderedRoom||{}).id);
        if (!roomId) return;

        // Use cache guard so we do not reload plans on every calendar render
        window.__cachedPlansByRoom = window.__cachedPlansByRoom || new Map();
        if (window.__cachedPlansByRoom.has(roomId)) return;

        if (typeof window.loadRatePlansForRoom === 'function') {
          window.loadRatePlansForRoom(roomId).catch(function(){});
        }
      } catch (e) {}
    }, { capture:false });
  })();
</script>

<script>
(() => {
  const LEGACY = ['rateplans.ids','rateplan.ids','rateplans.lastIds','rateplan.lastIds'];
  try { LEGACY.forEach(k => localStorage.removeItem(k)); } catch(_){}
})();
</script>

</body>
</html>

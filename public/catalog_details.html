<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lolaelo · Stay</title>
  <link rel="icon" href="https://www.lolaelo.com/logo2.png?cb=fav-v1" />
  <!-- ANCHOR: FONTS_PRECONNECT -->
  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/css/extranet.css?cb=font-unify-v1" />

  <style>
    /* === ANCHOR: DETAILS_LIGHT_SKIN ======================================= */
    :root{
      --bg:#ffffff;
      --fg:#111827;
      --muted:#6b7280;
      --line:#e5e7eb;
      --brand:#064e3b;          /* deep teal, matches index/catalog */
      --bubble:#ff6a3d;         /* orange accent for CTAs */
      --paper:#ffffff;
      --radius:20px;
      --shadow:0 12px 40px rgba(15,23,42,.10);
      --maxw:900px;             /* slightly tighter than catalog */
      /* ANCHOR: TYPO_BASE_VAR */ --body:11px;   /* ~80% of 15px */
    }

    *{ box-sizing:border-box; }
    /* ANCHOR: FONT_STACK_UNIFY */
    html, body,
    h1, h2, h3, h4, h5, h6,
    p, li, a, span, strong, em,
    table, thead, tbody, tfoot, tr, th, td, caption,
    input, button, select, textarea, label, small, code, pre {
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }

    /* ANCHOR: PAGE_SCROLL_FIX */
    html,body{ min-height:100%; margin:0; }
    body{
      font: var(--body)/1.5 Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color:var(--fg);
      background:#f3f4f6; /* same neutral backdrop as catalog.html */
      display:flex;
      flex-direction:column;
      align-items:center;
    }

    /* ANCHOR: DETAILS_TYPE_SCALE */
    html { font-size: 16px; }  /* baseline */
    body { font-size: 15px; line-height: 1.5; }

    h1 { font-size: clamp(30px, 4.8vw, 44px); line-height: 1.15; margin: 6px 0 10px; font-weight: 600; }
    h2 { font-size: clamp(18px, 2.4vw, 22px); line-height: 1.2; margin: 10px 0 8px; font-weight: 600; }

    p, li, .meta, .tag, .desc, .smalltext { font-size: 15px; }
    .small { font-size: 13px; color: var(--muted); }

    /* ANCHOR: A11Y_VISUALLY_HIDDEN */
    .visually-hidden{
      position:absolute !important;
      width:1px !important;
      height:1px !important;
      padding:0 !important;
      margin:-1px !important;
      overflow:hidden !important;
      clip:rect(0,0,0,0) !important;
      white-space:nowrap !important;
      border:0 !important;
    }

    /* ANCHOR: TYPO_REGULAR_ELEMS */
    p, li, td, th, input, select, button, .meta, .note { font-size: var(--body); }

    /* ANCHOR: DETAILS_PAPER_CLIP */
    .paper{
          width: 100%;
          max-width: var(--maxw);
          margin: 24px 20px;
          background: var(--paper);
          border-radius: var(--radius);
          box-shadow: var(--shadow);
          padding: 22px 22px 28px;
          overflow: hidden;
        }

    /* ANCHOR: TOAST_CSS */
    .toast{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      background: #111;
      color: #fff;
      font-size: 12px;
      padding: 10px 14px;
      border-radius: 999px;
      box-shadow: 0 10px 24px rgba(0,0,0,.18);
      opacity: 0;
      pointer-events: none;
      transition: opacity .15s ease, transform .15s ease;
      z-index: 1000;
    }
    .toast.show{
      opacity: 0.95;
      transform: translateX(-50%) translateY(-2px);
    }

    .hero-block{
      margin-top: 6px;
      margin-bottom: 18px;
    }

    /* ANCHOR: SCROLLTOP_CSS */
    .scrolltop-btn {
      position: fixed;
      bottom: 24px;
      right: 24px;
      background: var(--bubble);
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 44px;
      height: 44px;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      cursor: pointer;
      z-index: 1100;
    }
    .scrolltop-btn.show { display: flex; }

    /* ANCHOR: DETAILS_TOPBAR_CSS (revised) */
    .topbar{
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 0 18px 0;
    }

    .topbar .logo img{
      height: 54px;
      width: auto;
      display: block;
    }

    .topbar .title{
      margin: 0;
      font-size: clamp(18px, 2.6vw, 22px);
      font-weight: 600;
      text-align: right;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 4px;
    }

    /* Date range under hotel name */
    .stay-range{
      font-size: 12px;
      color: var(--muted);
    }

    /* ANCHOR: DETAILS_LAYOUT_COLS */
    .layout{
      display:grid;
      grid-template-columns: 1fr;
      gap:16px;
      align-items:start;
    }

    /* Keep two columns; collapse only below ~840px */
    @media (max-width:840px){
      .layout{ grid-template-columns: 1fr; }
    }

    /* ANCHOR: ROOMCAT_LIST_CSS */
    .roomcats { display: grid; gap: 10px; margin: 12px 0; }
    .roomcat {
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 12px;
      display: grid;
      grid-template-columns: 30px 100px 1fr auto;
      gap: 14px;
      align-items: center;
      background: #ffffff;
      box-shadow: 0 4px 12px rgba(15,23,42,0.05); /* subtle like catalog */
    }
    .roomcat h3 {
      margin: 0 0 2px 0;
      font-size: 14px;
      font-weight: 600;
    }
    .roomcat .meta {
      font-size: 13px;
      color: var(--muted);
    }
    .roomcat img {
      width: 100px;
      height: 72px;
      object-fit: cover;
      border-radius: 14px;
      background: #f3f4f6;
      display: block;
    }
    .roomcat .btn-select {
      background: var(--bubble);
      border: none;
      color: #fff;
      padding: 10px 14px;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      text-decoration: none;
      box-shadow: 0 2px 4px rgba(15,23,42,0.10);
    }

    @media (max-width: 840px){
      .roomcat{ grid-template-columns: 30px 72px 1fr; } /* + | thumb | text */
      .roomcat .btn-select{ grid-column: 1 / -1; justify-self: start; }
    }
    /* ANCHOR: ROOM_MODAL_CSS */
    .room-modal-backdrop{
      position: fixed;
      inset: 0;
      background: rgba(15,23,42,0.45);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 1200;
    }
    .room-modal-backdrop.is-open{
      display: flex;
    }

    .room-modal{
      position: relative;
      background: #fff;
      border-radius: 20px;
      /* wider, almost full-screen but with a small side margin */
      width: min(95vw, 1100px);
      max-height: 92vh;
      box-shadow: 0 24px 60px rgba(15,23,42,0.40);
      overflow: hidden;             /* keep rounded corners */
      display: flex;
      flex-direction: column;
    }

    .room-modal-close{
      position: absolute;
      top: 10px;
      right: 12px;
      border: none;
      background: rgba(255,255,255,0.9);
      border-radius: 999px;
      width: 30px;
      height: 30px;
      font-size: 18px;
      line-height: 1;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(15,23,42,0.25);
    }

    .room-modal-body{
      display: grid;
      /* approx 40% for hero block, 60% for details + plans */
      grid-template-rows: auto minmax(180px, 2fr) minmax(240px, 3fr);
      gap: 12px;
      padding: 18px 18px 20px;
      overflow-y: auto;   /* allow vertical scroll so thumbs + plans are always reachable */
      min-height: 0;      /* required for scrollable grid inside flex parent */
    }

    .room-modal-top{
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .room-modal-top h2{
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }

    .room-modal-hero{
      display: grid;
      grid-template-rows: minmax(180px, 1fr) auto;
      gap: 8px;
    }
    .room-modal-hero-main{
      position: relative;
      border-radius: 14px;
      overflow: hidden;
      border: 1px solid var(--line);
      background: #000; /* darker so letterboxing looks intentional */
      cursor: zoom-in;
    }
    .room-modal-hero-main img{
      width: 100%;
      height: 100%;
      object-fit: cover;   /* default = cropped, strong visual */
      display: block;
      transition: object-fit 0.2s ease;
    }
    .room-modal-hero-main:hover img{
      object-fit: contain; /* on hover = show full image, “fit to screen” inside hero */
    }

    .room-modal-thumbs{
      display: flex;
      gap: 8px;
      overflow-x: auto;
      padding-bottom: 2px;
    }
    .room-modal-thumbs button{
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 0;
      margin: 0;
      background: #fff;
      cursor: pointer;
      flex: 0 0 auto;
    }
    .room-modal-thumbs img{
      display: block;
      width: 96px;
      height: 64px;
      object-fit: cover;
      border-radius: 10px;
    }
    .room-modal-thumbs button[aria-current="true"]{
      border-color: var(--bubble);
      box-shadow: 0 0 0 2px rgba(255,106,61,0.25) inset;
    }

    .room-modal-plans{
      border-top: 1px solid #f3f4f6;
      padding-top: 10px;
      margin-top: 8px;
    }

    .room-modal-subtitle{
      margin: 0 0 4px 0;
      font-size: 14px;
      font-weight: 600;
    }

    /* Inner container that actually holds the pills */
    #roomModalPlans{
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: stretch;
      justify-content: center;  /* center the three bubbles */
    }

    /* Horizontal plan pills */
    .room-modal-plan-pill{
      flex: 1 1 0;
      min-width: 225px;    /* widened */
      max-width: 325px;    /* widened */
      padding: 14px 16px;  /* slightly more padding since wider */
      border-radius: 14px;
      border: 1px dashed var(--line);
      background: #fafafa;
      display: flex;
      flex-direction: column;
      align-items: center;     /* center content */
      justify-content: space-between; /* << THE FIX: aligns all Select buttons */
      text-align: center;
      gap: 6px;
    }

    .room-modal-plan-pill-title{
      font-size: 15px;
      font-weight: 600;
      text-align: center;
    }

    .room-modal-plan-pill-desc{
      font-size: 13px;
      color: var(--muted);
      text-align: center;
    }

    /* Center the Select button + keep the orange pill style */
    .room-modal-plan-pill-btn{
      margin-top: 8px;
      align-self: center;      /* centers button horizontally */
      padding: 6px 18px;
      border-radius: 999px;
      border: none;
      font-size: 13px;
      font-weight: 600;
      color: #fff;
      background: linear-gradient(135deg, #ff7a3c, #ff5a2a);
      box-shadow: 0 6px 16px rgba(255,106,61,0.45);
      cursor: pointer;
      transition: transform 0.08s ease, box-shadow 0.08s ease, opacity 0.08s ease;
    }

    .room-modal-plan-pill-btn:hover{
      transform: translateY(-1px);
      box-shadow: 0 8px 20px rgba(255,106,61,0.55);
      opacity: 0.96;
    }

    .room-modal-plan-pill-btn:active{
      transform: translateY(0);
      box-shadow: 0 4px 10px rgba(255,106,61,0.35);
      opacity: 0.9;
    }

    /* Slightly larger body text inside the modal only */
    .room-modal-body .small,
    .room-modal-body .muted,
    .room-modal-body li{
      font-size: 14px;
    }

    @media (max-width: 640px){
      .room-modal-body{
        padding: 14px 14px 16px;
        /* keep same 40/60 bias but slightly more compact on small screens */
        grid-template-rows: auto minmax(150px, 2fr) minmax(200px, 3fr);
      }
    }

    /* ANCHOR: ROOM_MODAL_LIGHTBOX_CSS */
    .room-modal-lightbox {
      position: absolute;
      inset: 0;
      display: none;               /* hidden until opened */
      align-items: center;
      justify-content: center;
      z-index: 999;                /* above modal body, below global modals */
    }

    .room-modal-lightbox.is-open {
      display: flex;
    }

    .room-modal-lightbox-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.55);   /* darken inside modal only */
      backdrop-filter: blur(2px);
    }

    .room-modal-lightbox-inner {
      position: relative;
      z-index: 1000;
      max-width: 92%;
      max-height: 92%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .room-modal-lightbox-img {
      max-width: 100%;
      max-height: 100%;
      border-radius: 14px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.35);
      object-fit: contain;
      background: #000;
    }

    .room-modal-lightbox-close {
      position: absolute;
      top: -40px;
      right: 0;
      font-size: 26px;
      border: none;
      background: none;
      color: #ffffff;
      cursor: pointer;
      z-index: 1100;
    }

    .room-modal-lightbox-prev,
    .room-modal-lightbox-next {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      font-size: 38px;
      border: none;
      background: none;
      color: #ffffff;
      cursor: pointer;
      z-index: 1100;
      padding: 8px 12px;
      user-select: none;
    }

    .room-modal-lightbox-prev { left: -46px; }
    .room-modal-lightbox-next { right: -46px; }

    /* On small screens, bring arrows inside */
    @media (max-width: 640px) {
      .room-modal-lightbox-prev { left: 6px; }
      .room-modal-lightbox-next { right: 6px; }
    }

    /* ANCHOR: ROOMCAT_PLANS_CSS */
    .roomcat .toggle {
      appearance: none;
      border: 1px solid var(--line);
      background: #fff;
      border-radius: 8px;
      width: 30px; height: 30px;
      display: inline-flex; align-items: center; justify-content: center;
      cursor: pointer; font-weight: 700;
    }
    .roomcat .toggle[aria-expanded="true"] { background: #fff0ea; border-color: #ffd3c2; color: #c2410c; }

    /* Smooth expand/collapse for sub-rows */
    .planlist{
      grid-column: 1 / -1;
      margin-top: 8px;

      /* animation */
      max-height: 0;
      overflow: hidden;
      opacity: 0;
      visibility: hidden;
      transition:
        max-height .28s ease,
        opacity .20s ease,
        visibility 0s linear .28s; /* hide after collapse */
    }
    .planlist.open{
      /* allow animation without display:none */
      max-height: 800px; /* large enough for several rows */
      opacity: 1;
      visibility: visible;
      transition:
        max-height .32s ease,
        opacity .20s ease,
        visibility 0s; /* show immediately */
    }

    /* Respect reduced-motion */
    @media (prefers-reduced-motion: reduce){
      .planlist, .planlist.open{
        transition: none !important;
      }
    }

    .planrow{
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border: 1px dashed var(--line);
      border-radius: 10px;
      background: #fafafa;
      margin-bottom: 8px;
    }
    .planrow .planname{
      font-weight: 600;
      font-size: 14px;
    }
    .planrow .meta{
      font-size: 12px;
      color: var(--muted);
    }
    .planrow .btn-select {
      border: 1px solid var(--bubble); background: var(--bubble); color: #fff;
      padding: 6px 10px; border-radius: 10px; font-weight: 700; cursor: pointer;
      text-decoration: none; display: inline-block;
    }

    @media (min-width:900px){
      .panel{
        position: sticky;
        top: 12px;
        align-self: start;
      }
    }

    .muted{
      color: var(--muted);
      font-size: 13px;
    }

    /* ANCHOR: DETAILS_PRICE_SIZE */
    .price{
      font-weight: 600;
      font-size: 24px;
      letter-spacing: .1px;
    }
    @media (min-width:1200px){
      .price{ font-size:26px; }
    }

    .book{ border:1px solid var(--bubble); background:var(--bubble); color:#fff; font-weight:700;
      border-radius:12px; padding:14px; width:100%; cursor:pointer; }

    /* Chips (optional, if amenities chips are shown elsewhere) */
    .chips{ display:flex; gap:6px; flex-wrap:wrap; margin:10px 0; }
    .chip{ font-size:11px; padding:4px 8px; border:1px solid var(--line); border-radius:999px; background:#fafafa; color:#444; }

    /* ANCHOR: DETAILS_TAGS */
    .tag{
      padding:4px 8px;
      border-radius:999px;
      font-size:12px;
      display:inline-block;
      border:1px solid transparent;
      font-weight:600;
    }
    .tag{ background:#dcfce7; color:#166534; border-color:#86efac; }
    .tag.off{ background:#fee2e2; color:#991b1b; border-color:#fca5a5; }

    /* ANCHOR: NUMERIC_UNIFY */
    .price,
    #from,
    .meta,
    .chip {
      font-variant-numeric: tabular-nums lining-nums;
    }

    /* ANCHOR: DETAILS_GALLERY_CSS */
    .hero{
      position: relative;
      border-radius: 18px;
      overflow: hidden;
      background:#f3f4f6;
      aspect-ratio: 16 / 9;
      width: 100%;
      min-height: 260px;
      max-height: 70vh;
      box-shadow: 0 16px 38px rgba(15,23,42,0.18);
    }
    .hero img{
      width:100%;
      height:100%;
      object-fit:cover;
      object-position:center;
      display:block;
      opacity: 1;
      transition: opacity .25s ease;
      background:#e5e7eb;
    }

    /* ANCHOR: GALLERY_NODRAG_CSS */
    .hero img, .thumbs img{ user-select: none; -webkit-user-drag: none; }

    /* ANCHOR: REDUCED_MOTION_CSS */
    @media (prefers-reduced-motion: reduce){
      .hero img{ transition: none !important; }
      .hero-nav{ transition: none !important; }
    }

    /* ANCHOR: HERO_NAV_CSS */
    .hero-nav {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(255,255,255,0.8);
      border: none;
      border-radius: 50%;
      width: 36px;
      height: 36px;
      font-size: 20px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    #hero-prev { left: 10px; }
    #hero-next { right: 10px; }
    .hero-nav:hover { background: rgba(255,255,255,0.95); }
    .hero-nav[disabled]{ opacity: .45; cursor: default; box-shadow: none; }
    .hero-nav.is-hidden{ display: none; }
    .hero img.is-fading{ opacity: 0; }

    .thumbs{
      display: grid;
      grid-auto-flow: column;
      grid-auto-columns: max-content;
      gap: 10px;
      margin: 12px 0 10px;
      padding: 6px 2px;
      overflow-x: auto;
      scrollbar-gutter: stable;
    }
    .thumbs button{
      appearance: none;
      border: 1px solid #e5e7eb;
      border-radius: 14px;
      background: #ffffff;
      padding: 0;
      margin: 0;
      line-height: 0;
      cursor: pointer;
      box-shadow: none;
      transition: border-color .12s ease, transform .12s ease;
    }
    .thumbs button:hover{
      border-color: #9ca3af;
      transform: translateY(-1px);
    }
    .thumbs img{
      display: block;
      width: 110px;
      height: 72px;
      object-fit: cover;
      background:#f3f4f6;
      border-radius: 14px;
    }
   .thumbs button:hover{ transform: translateY(-1px); box-shadow: 0 10px 22px rgba(0,0,0,.12); }
    .thumbs button:focus-visible{ outline: 2px solid var(--bubble); outline-offset: 2px; }
    .thumbs button[aria-current="true"]{ border-color: var(--bubble); box-shadow: 0 0 0 2px rgba(255,102,51,.25) inset; }

    /* ANCHOR: SKELETON_CSS */
    @keyframes shimmer {
      0% { background-position: -400px 0; }
      100% { background-position: 400px 0; }
    }
    .skeleton-bar{
      height: 12px;
      border-radius: 8px;
      background: #f3f4f6;
      background-image: linear-gradient(90deg, #f3f4f6 0px, #e5e7eb 40px, #f3f4f6 80px);
      background-size: 400px 100%;
      animation: shimmer 1.1s infinite linear;
    }
    .hero.is-loading::after{
      content: "";
      position: absolute; inset: 0;
      background-image: linear-gradient(90deg, rgba(0,0,0,0.02) 0%, rgba(0,0,0,0.06) 20%, rgba(0,0,0,0.02) 40%);
      background-size: 400px 100%;
      animation: shimmer 1.1s infinite linear;
    }
    /* ANCHOR: DETAILS_CTA_UNIFY */
    .book,
    .roomcat .btn-select,
    .planrow .btn-select{
      border: none;
      background: var(--bubble);
      color: #fff;
      font-weight: 600;
      border-radius: 999px;
      padding: 10px 16px;
      cursor: pointer;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      box-shadow: 0 4px 12px rgba(255,106,61,0.25);
      transition:
        filter .15s ease-out,
        box-shadow .15s ease-out,
        transform .12s ease-out;
    }

    .book:hover,
    .roomcat .btn-select:hover,
    .planrow .btn-select:hover{
      filter: brightness(.96);
      box-shadow: 0 6px 18px rgba(255,106,61,0.35);
      transform: translateY(-1px);
    }
    
    /* ANCHOR: ROOM_DIALOG_LAYOUT */
    /* Wider edit-room dialog */
    .dialog{
      width: min(760px, calc(100vw - 24px));
      max-width: 840px;
    }

    /* Column layout for Room details / Inclusions checkboxes */
    .ri-details-grid,
    .ri-inclusions-grid{
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px 12px;
      margin-bottom: 6px;
    }

    @media (min-width: 1024px){
      .ri-details-grid,
      .ri-inclusions-grid{
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
    }

    /* Make the textareas span full width and be comfortable height */
    #edit-room-summary,
    #edit-room-details,
    #edit-room-inclusions{
      width: 100%;
      resize: vertical;
      min-height: 60px;
    }

  </style>
</head>
<body>
  <div class="paper">
    <header>
      <!-- ANCHOR: DETAILS_TOPBAR -->
      <div class="topbar">
        <a class="logo" href="https://www.lolaelo.com/">
          <img
            src="https://www.lolaelo.com/logo.png?cb=logo-5x"
            alt="Lolaelo"
            decoding="async"
            loading="eager"
            style="display:block;height:54px;width:auto;"
          >
        </a>
          <h1 class="title">
            <span>
              <span id="prop-name">Loading…</span>
              <span id="src-badge" class="chip" style="display:none; margin-left:8px;">db</span>
            </span>
            <div id="stay-range" class="stay-range"></div>
          </h1>
      </div>
      <!-- /ANCHOR: DETAILS_TOPBAR -->
    </header>

    <!-- ANCHOR: DETAILS_HERO_BLOCK -->
    <section class="hero-block">
      <div id="hero" class="hero" aria-live="polite">
        <img id="hero-img" src="" alt="" width="1600" height="900">
        <button id="hero-prev" class="hero-nav" aria-label="Previous photo">‹</button>
        <button id="hero-next" class="hero-nav" aria-label="Next photo">›</button>
      </div>
      <div id="thumbs" class="thumbs" aria-label="More photos"></div>
    </section>

    <div class="layout">
      <section>
        <!-- ANCHOR: ROOMCAT_LIST_HTML -->
        <div id="roomCats" class="roomcats" aria-label="Available room categories (open only)"></div>
      </section>
    </div>

    <!-- ANCHOR: ROOM_MODAL_HTML -->
    <div id="roomModalBackdrop" class="room-modal-backdrop" aria-hidden="true">
      <div class="room-modal" role="dialog" aria-modal="true" aria-label="Room details">
        <button type="button" class="room-modal-close" aria-label="Close">×</button>
        <div class="room-modal-body">
          <div class="room-modal-top">
            <h2 id="roomModalTitle">Room</h2>
            <p id="roomModalMeta" class="small muted"></p>
          </div>

          <div class="room-modal-hero">
            <div class="room-modal-hero-main">
              <img
                id="roomModalHeroImg"
                src=""
                alt=""
                loading="lazy"
                decoding="async"
              >
            </div>
            <div
              id="roomModalThumbs"
              class="room-modal-thumbs"
              aria-label="Room photos"
            ></div>
          </div>
            <div class="room-modal-info">
            <p id="roomModalSummary" class="small"></p>

            <div id="roomModalSpecs" class="small muted"></div>

            <div class="room-modal-section" id="roomModalDetailsSection" style="display:none;">
              <p class="room-modal-subtitle">Room details</p>
              <ul id="roomModalDetailsList" class="small"></ul>
            </div>

            <div class="room-modal-section" id="roomModalInclusionsSection" style="display:none;">
              <p class="room-modal-subtitle">Inclusions</p>
              <ul id="roomModalInclusionsList" class="small"></ul>
            </div>
          </div>
          <div class="room-modal-plans">
            <p class="room-modal-subtitle">Available plans</p>
            <div id="roomModalPlans"></div>
          </div>
        </div>
        <!-- ANCHOR: ROOM_MODAL_LIGHTBOX -->
        <div id="roomModalLightbox" class="room-modal-lightbox" aria-hidden="true">
          <div class="room-modal-lightbox-backdrop"></div>

          <div class="room-modal-lightbox-inner">
            <button class="room-modal-lightbox-close" aria-label="Close">×</button>
            <button class="room-modal-lightbox-prev" aria-label="Previous image">‹</button>

            <img class="room-modal-lightbox-img" src="" alt="Room photo" />

            <button class="room-modal-lightbox-next" aria-label="Next image">›</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // === ANCHOR: DETAILS_SCRIPT ============================================
    const qs = new URLSearchParams(location.search);
    const propertyId = qs.get('propertyId');
    const start = qs.get('start') || new Date().toISOString().slice(0,10);
    const end   = qs.get('end')   || start;
    const plan  = qs.get('ratePlanId') || qs.get('plan');

    // ANCHOR: DETAILS_PLAN_PARAM_DEF
    const planParam = (qs.get('ratePlanId') || qs.get('plan') || '').trim();
    const planQS = planParam ? `&ratePlanId=${encodeURIComponent(planParam)}` : '';

    /* ANCHOR: DETAILS_SET_BACK */
    const backLink = document.querySelector('a.back');
    if (backLink){
      const guests = qs.get('guests') || '2';
      const plan   = qs.get('ratePlanId') || qs.get('plan') || '';
      const planPart = plan ? `&ratePlanId=${encodeURIComponent(plan)}` : '';
      backLink.href =
        `/catalog?start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}&guests=${encodeURIComponent(guests)}${planPart}`;
    }

    const hero = document.getElementById('hero-img');
    hero.decoding = 'async';
    hero.draggable = false;
    const heroWrap = document.getElementById('hero'); // container div for hero
    const thumbs = document.getElementById('thumbs');
    const fromEl = document.getElementById('from');
    const rangeEl = document.getElementById('stay-range');
    const nameEl = document.getElementById('prop-name');
    const amenities = document.getElementById('amenities'); // may not exist on this page
    const nightsNote = document.getElementById('nights-note'); // may not exist

    let images = [];
    let heroIndex = 0;

    /* ANCHOR: IMAGE_PLACEHOLDER_HELPER */
    function getPlaceholderSVG(label = 'Photo not available'){
      return 'data:image/svg+xml;utf8,' + encodeURIComponent(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 450">
          <rect width="800" height="450" fill="white"/>
          <rect x="20" y="20" width="760" height="410" fill="#f3f4f6" stroke="#e5e7eb"/>
          <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle"
                font-family="Inter, Arial, sans-serif" font-size="20" fill="#9ca3af">${label}</text>
        </svg>`
      );
    }

    /* ANCHOR: HERO_SRCSET_HELPER */
    function buildHeroSrcSet(url){
      try{
        const u = new URL(url, location.origin);
        if (!/picsum\.photos$/.test(u.hostname)) return null;
        const m = u.pathname.match(/\/id\/(\d+)\/(\d+)\/(\d+)/);
        if (!m) return null;
        const id = m[1], w = Number(m[2]), h = Number(m[3]);
        if (!Number.isFinite(w) || !Number.isFinite(h)) return null;
        const oneX  = `https://picsum.photos/id/${id}/${w}/${h}`;
        const twoX  = `https://picsum.photos/id/${id}/${w*2}/${h*2}`;
        return `${oneX} 1x, ${twoX} 2x`;
      }catch{ return null; }
    }

    /* ANCHOR: HERO_PRELOAD_HELPER */
    const __heroPreloaded = new Set();
    function preloadImage(url){
      if (!url || __heroPreloaded.has(url)) return;
      const img = new Image();
      img.loading = 'eager';
      img.decoding = 'async';
      img.src = url;
      __heroPreloaded.add(url);
    }

    function setHero(i){
      if (!images.length) return;

      // clamp
      i = Math.max(0, Math.min(images.length - 1, i));

      // if same index, do nothing (prevents redundant fade / “double blink”)
      if (i === heroIndex) return;

      heroIndex = i;
      const src = images[i];

      hero.classList.add('is-fading');
      const img = new Image();
      img.onload = () => {
        hero.src = src;

        const ss = buildHeroSrcSet(src);
        if (ss) {
          hero.setAttribute('srcset', ss);
          hero.setAttribute('sizes', '(min-width: 900px) 70vw, 100vw');
        } else {
          hero.removeAttribute('srcset');
          hero.removeAttribute('sizes');
        }

        hero.alt = `${nameEl.textContent || 'Property'} — hero image`;
        hero.loading = 'eager';
        hero.fetchPriority = 'high';

        requestAnimationFrame(() => {
          hero.classList.remove('is-fading');
          if (heroWrap) heroWrap.classList.remove('is-loading');
        });
      };
      img.onerror = () => {
        const ph = getPlaceholderSVG('Photo not available');
        hero.src = ph;
        hero.removeAttribute('srcset');
        hero.removeAttribute('sizes');
        hero.alt = `${nameEl.textContent || 'Property'} — photo not available`;
        requestAnimationFrame(() => {
          hero.classList.remove('is-fading');
          if (heroWrap) heroWrap.classList.remove('is-loading');
        });
      };
      img.src = src;

      thumbs.querySelectorAll('button.thumb').forEach((btn, idx) => {
        btn.setAttribute('aria-current', idx === i ? 'true' : 'false');
      });

      // Preload previous/next images
      const prevIdx = i - 1;
      const nextIdx = i + 1;
      if (prevIdx >= 0) preloadImage(images[prevIdx]);
      if (nextIdx < images.length) preloadImage(images[nextIdx]);

      // Toggle arrows
      const prevBtn = document.getElementById('hero-prev');
      const nextBtn = document.getElementById('hero-next');
      const n = images.length;

      if (n <= 1) {
        prevBtn.classList.add('is-hidden');
        nextBtn.classList.add('is-hidden');
      } else {
        prevBtn.classList.remove('is-hidden');
        nextBtn.classList.remove('is-hidden');

        const atStart = i <= 0;
        const atEnd   = i >= n - 1;

        prevBtn.disabled = atStart;
        nextBtn.disabled = atEnd;

        prevBtn.setAttribute('aria-disabled', atStart ? 'true' : 'false');
        nextBtn.setAttribute('aria-disabled', atEnd   ? 'true' : 'false');
      }
    }

    // ANCHOR: HERO_NAV_LOGIC
    (() => {
      const prevBtn = document.getElementById('hero-prev');
      const nextBtn = document.getElementById('hero-next');
      if (prevBtn) prevBtn.addEventListener('click', () => setHero(heroIndex - 1));
      if (nextBtn) nextBtn.addEventListener('click', () => setHero(heroIndex + 1));
    })();

    /* ANCHOR: HERO_TOUCH_SWIPE */
    (() => {
      const heroWrap = document.getElementById('hero');
      if (!heroWrap) return;

      let startX = 0, startY = 0, active = false;

      heroWrap.addEventListener('touchstart', (e) => {
        if (!e.touches || e.touches.length !== 1) return;
        const t = e.touches[0];
        startX = t.clientX;
        startY = t.clientY;
        active = true;
      }, { passive: true });

      heroWrap.addEventListener('touchmove', (e) => {
        if (!active || !e.touches || e.touches.length !== 1) return;
        const dy = Math.abs(e.touches[0].clientY - startY);
        if (dy > 20) active = false;
      }, { passive: true });

      heroWrap.addEventListener('touchend', (e) => {
        if (!active) return;
        active = false;
        const t = e.changedTouches && e.changedTouches[0];
        if (!t) return;
        const dx = t.clientX - startX;
        const threshold = 40;
        if (Math.abs(dx) < threshold) return;

        if (dx < 0) setHero(heroIndex + 1);
        else        setHero(heroIndex - 1);
      }, { passive: true });
    })();

    /* ANCHOR: GALLERY_KB_NAV */
    document.addEventListener('keydown', (e) => {
      if (e.altKey || e.ctrlKey || e.metaKey) return;
      if (e.key === 'ArrowLeft') { setHero(heroIndex - 1); e.preventDefault(); }
      if (e.key === 'ArrowRight') { setHero(heroIndex + 1); e.preventDefault(); }
    });

    /* ANCHOR: THUMB_SRC_HELPER */
    function buildThumbSrcAndSet(url){
      try{
        const u = new URL(url, location.origin);
        if (!/picsum\.photos$/.test(u.hostname)) return { src: url, srcset: null };
        const m = u.pathname.match(/\/id\/(\d+)\/(\d+)\/(\d+)/);
        if (!m) return { src: url, srcset: null };
        const id = m[1], w = 110, h = 72;
        const oneX = `https://picsum.photos/id/${id}/${w}/${h}`;
        const twoX = `https://picsum.photos/id/${id}/${w*2}/${h*2}`;
        return { src: oneX, srcset: `${oneX} 1x, ${twoX} 2x` };
      }catch{ return { src: url, srcset: null }; }
    }
    function thumbHTML(src, idx){
      const current = idx === 0 ? 'true' : 'false';
      const total = images.length || 0;
      const name = (nameEl && nameEl.textContent) ? nameEl.textContent : 'Property';
      const w = 110, h = 72;
      const { src: s, srcset } = buildThumbSrcAndSet(src);
      const srcsetAttr = srcset ? ` srcset="${srcset}" sizes="110px"` : '';
      return `<button class="thumb" type="button" data-idx="${idx}" aria-label="${name} photo ${idx+1} of ${total}" aria-current="${current}">
        <img src="${s}"${srcsetAttr} alt="${name} — photo ${idx+1} of ${total}" loading="lazy" decoding="async" width="${w}" height="${h}" draggable="false">
      </button>`;
    }

    function money(v){ const n=Number(v); return Number.isFinite(n) ? `$${n.toFixed(2)}` : '—'; }

    function formatYMD(ymd){
      if (!ymd || typeof ymd !== "string") return ymd;
      const parts = ymd.split("-");
      if (parts.length !== 3) return ymd;
      const [y, m, d] = parts.map(Number);
      if (!y || !m || !d) return ymd;
      const months = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
      const label = months[m - 1];
      if (!label) return ymd;
      return `${label} ${d}, ${y}`;
    }

    async function load(){
      // ANCHOR: DETAILS_FETCH_WITH_PLAN
      console.log("[details] fetching catalog details with:", {
        propertyId, start, end, plan, urlPreview:
        `/catalog/details?propertyId=${encodeURIComponent(propertyId)}&start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}${plan ? "&ratePlanId="+encodeURIComponent(plan) : ""}`
      });

      const planQS   = plan ? `&ratePlanId=${encodeURIComponent(plan)}` : '';
      const url      = `/catalog/details?propertyId=${encodeURIComponent(propertyId)}&start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}${planQS}`;
      const urlAlt   = `/api/catalog/details?propertyId=${encodeURIComponent(propertyId)}&start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}${planQS}`;

      // ANCHOR: SKELETON_START
      if (heroWrap) heroWrap.classList.add('is-loading');

      // Robust fetch with fallback
      let j;
      try {
        console.log('[details] GET', url);
        let r = await fetch(url, { cache: 'no-store' });
        if (!r.ok) {
          console.warn('[details] primary failed', r.status, r.statusText);
          if (r.status === 404) {
            console.log('[details] retrying fallback', urlAlt);
            r = await fetch(urlAlt, { cache: 'no-store' });
          }
        }
        if (!r.ok) throw new Error(`HTTP ${r.status} ${r.statusText}`);
        j = await r.json();
        // ===== DETAILS_PAYLOAD_TAP (insert) =====
        window.__detailsPayload = j;  // allow console inspection
        console.log("[details] images.summary", {
          hasImagesArray: Array.isArray(j?.images),
          imagesLen: Array.isArray(j?.images) ? j.images.length : 0,
          room0HasImages: Array.isArray(j?.rooms?.[0]?.images),
          room0ImagesLen: Array.isArray(j?.rooms?.[0]?.images) ? j.rooms[0].images.length : 0
        });
        // ===== DETAILS_PAYLOAD_TAP (insert end) =====
        // ===== DETAILS_PAYLOAD_DUMP (insert) =====
        console.log("[details] full payload", j);
        // ===== DETAILS_PAYLOAD_DUMP (insert end) =====
        // ===== DETAILS_IMG_DEBUG (insert) =====
        console.log("[details] payload keys:", Object.keys(j || {}));
        console.log("[details] j.images:", j?.images);
        console.log("[details] rooms[0].images:", j?.rooms?.[0]?.images);
        try {
          const badge = document.getElementById("src-badge");
          if (badge) {
            const a = Array.isArray(j?.images) ? j.images.length : 0;
            const b = Array.isArray(j?.rooms?.[0]?.images) ? j.rooms[0].images.length : 0;
            badge.textContent = `${j?._roomsSource || "src"} · img:${a} · r0:${b}`;
            badge.style.display = "inline-block";
          }
        } catch {}
        // ===== DETAILS_IMG_DEBUG (insert end) =====
      } catch (e) {
        console.error('[details] fetch error', e);
        throw e;
      }

      // Safe DOM writes
      if (nameEl) nameEl.textContent = j?.name || j?.meta?.property?.name || 'Stay';
      {
        const srcBadgeEl = document.getElementById('src-badge');
        if (srcBadgeEl) srcBadgeEl.style.display = (j?._roomsSource === 'db') ? 'inline-block' : 'none';
      }
      if (rangeEl){
        const fs = formatYMD(start);
        const fe = formatYMD(end);
        rangeEl.textContent = (start === end)
          ? fs
          : `${fs} to ${fe}`;
      }

      // Compute fromPrice from daily rows (first room) if available
      const daily0  = (j?.rooms?.[0]?.daily || []);
      const priced  = daily0.filter(d => typeof d.price === 'number');
      const minPrice = priced.length ? Math.min(...priced.map(d => Number(d.price))) : null;
      if (fromEl) fromEl.textContent = (minPrice != null) ? money(minPrice) : '—';

      /* ANCHOR: DETAILS_AMENITIES_RENDER (optional chips if present elsewhere) */
      {
        const raw = Array.isArray(j?.amenities)
          ? j.amenities
          : (Array.isArray(j?.meta?.property?.amenities) ? j.meta.property.amenities : []);
        const chips = [...new Set(raw.map(a => String(a).trim()).filter(Boolean))].slice(0, 8);
        if (chips.length) {
          const amenities = document.getElementById('amenities');
          if (amenities) {
            amenities.style.display = 'flex';
            amenities.innerHTML = chips.map(a => `<span class="chip">${a}</span>`).join("");
          }
        }
      }

      // Prefer details.images (DB-backed) with cover support; fallback to first room images
      const rawImages =
        Array.isArray(j?.images) ? j.images
        : (Array.isArray(j?.rooms?.[0]?.images) ? j.rooms[0].images : []);

      // Try to detect the designated cover across common key names / flags
      const coverObj = Array.isArray(j?.images)
        ? j.images.find(it =>
            typeof it === 'object' &&
            (it?.isCover === true || it?.is_cover === true || it?.isPrimary === true || it?.is_primary === true)
          )
        : null;
      const coverUrl = coverObj
        ? (coverObj.url || coverObj.photoUrl || coverObj.imageUrl || coverObj.src || coverObj.href || null)
        : null;

      // Normalize to plain URL strings across common key names
      images = rawImages
        .map(it => {
          if (typeof it === 'string') return it;
          return it?.url || it?.photoUrl || it?.imageUrl || it?.src || it?.href || "";
        })
        .filter(Boolean);

      // If we found a coverUrl, move it to the front
      if (coverUrl) {
        const idx = images.indexOf(coverUrl);
        if (idx > 0) images.splice(0, 0, ...images.splice(idx, 1));
      }
      
      // ===== DETAILS_IMG_FALLBACKS (streamlined) =====
      // 1) Try alternates in the details payload
      if (!images.length) {
        const pick = (arr) => (Array.isArray(arr) ? arr : [])
          .map(it => typeof it === 'string'
            ? it
            : (it?.url || it?.photoUrl || it?.imageUrl || it?.src || it?.href || ""))
          .filter(Boolean);

        images = pick(j?.meta?.property?.photos);
        if (!images.length) images = pick(j?.meta?.photos);
        if (!images.length) images = pick(j?.rooms?.[0]?.photos);
      }

      // 2) Primary public source (same wiring as catalog cards): /catalog/search
      if (!images.length) {
        try {
          const q  = `start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}&partnerId=${encodeURIComponent(propertyId)}&limit=1`;
          const sr = await fetch(`/catalog/search?${q}`, { cache: 'no-store' });
          console.log("[details][search] status:", sr.status);
          if (sr.ok) {
            const sj = await sr.json();
            console.log("[details][search] keys:", Object.keys(sj || {}));

            const pidStr  = String(propertyId);
            const pickUrl = (it) => (typeof it === 'string') ? it :
              (it?.url || it?.photoUrl || it?.imageUrl || it?.src || it?.href || "");
            const pickList = (arr) => (Array.isArray(arr) ? arr : []).map(pickUrl).filter(Boolean);

            // Prefer map-style if present; otherwise use properties[].images
            let arr = [];
            const maps = [sj?.photosByPid, sj?.photos_by_pid, sj?.byPid, sj?.photosMap, sj?.photos_map];
            for (const m of maps) {
              if (m && typeof m === "object") {
                if (Array.isArray(m[pidStr]))           { arr = pickList(m[pidStr]); break; }
                if (Array.isArray(m[Number(pidStr)]))   { arr = pickList(m[Number(pidStr)]); break; }
              }
            }
            if (!arr.length) {
              const props = Array.isArray(sj?.properties) ? sj.properties : (Array.isArray(sj) ? sj : []);
              const item  = props.find(it => String(it?.partnerId ?? it?.propertyId ?? it?.id) === pidStr) || props[0];
              if (item) {
                arr = pickList(item.images || item.photos || []);
                if (!arr.length && item?.cover)    arr = pickList([item.cover.url || item.cover]);
                if (!arr.length && item?.coverUrl) arr = pickList([item.coverUrl]);
                if (!arr.length && item?.image)    arr = pickList([item.image]);
              }
            }
            if (arr.length) {
              images = arr;
              console.log("[details] photos from /catalog/search:", images.length);
            }
          }
        } catch (e) {
          console.warn("[details] search photos fallback error", e);
        }
      }

      // NOTE: we intentionally skip /extranet/property/photos (auth) and
      // /catalog/property/photos|/catalog/photos (non-existent) to avoid 401/404 noise.
      // ===== DETAILS_IMG_FALLBACKS (end) =====

      const placeholder = 'data:image/svg+xml;utf8,' +
        encodeURIComponent(
          `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 450">
             <rect width="800" height="450" fill="white"/>
             <rect x="20" y="20" width="760" height="410" fill="#f3f4f6" stroke="#e5e7eb"/>
             <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle"
                   font-family="Inter, Arial, sans-serif" font-size="20" fill="#9ca3af">
               Photo not available
             </text>
           </svg>`
        );

      if (!images.length) {
        thumbs.innerHTML = '';
        hero.src = placeholder;
        hero.removeAttribute('srcset');
        hero.removeAttribute('sizes');
        hero.alt = `${nameEl.textContent || 'Property'} — photo not available`;
      } else {
        thumbs.innerHTML = images.map((src, i)=>thumbHTML(src, i)).join("");
        setHero(0);
      }

      if (thumbs) {
        thumbs.addEventListener('click', (e) => {
          const b = e.target.closest('.thumb'); if (!b) return;
          setHero(Number(b.dataset.idx || '0'));
        });
        thumbs.addEventListener('mouseover', (e) => {
          const b = e.target.closest('.thumb'); if (!b) return;
          setHero(Number(b.dataset.idx || '0'));
        });
      }
  
      /* ANCHOR: ROOMCAT_LIST_JS (expandable with per-plan subrows; self-contained) */
      (function(){
        const listEl = document.getElementById('roomCats');
        if (!listEl) return;

        // local helpers
        function getSelectedPlanIds(){
          try { const a = JSON.parse(localStorage.getItem('rateplan.selectedIds')||'[]'); return Array.isArray(a)?a.map(Number).filter(Number.isFinite):[]; }
          catch { return []; }
        }
        function getCustomLabels(){
          try { return JSON.parse(localStorage.getItem('rateplan.customLabels')||'{}')||{}; }
          catch { return {}; }
        }
        function friendlyPlanName(id){
          if (Number(id) === 1) return 'Standard';
          const labels = getCustomLabels();
          return labels.CUS1 || labels.CUS2 || `Plan ${Number(id)}`;
        }
        function derivePlansForDisplay(){
          // 1) Try localStorage (set by partners_rooms.html)
          let ids = [];
          try {
            const a = JSON.parse(localStorage.getItem('rateplan.selectedIds') || '[]');
            if (Array.isArray(a)) ids = a.map(Number).filter(Number.isFinite);
          } catch {}

          // 2) If empty, fall back to URL (?plans=1,2,6 or ?plan=1)
          if (!ids.length) {
            try {
              const u = new URL(location.href);
              const csv = (u.searchParams.get('plans') || '').trim();
              if (csv) {
                ids = csv.split(',').map(s => Number(s.trim())).filter(Number.isFinite);
              } else {
                const p = Number(u.searchParams.get('ratePlanId') || u.searchParams.get('plan'));
                if (Number.isFinite(p)) ids = [p];
              }
            } catch {}
          }

          // 3) Default to Standard if still empty
          if (!ids.length) ids = [1];

          // 4) Build display objects with friendly names
          let labels = {};
          try { labels = JSON.parse(localStorage.getItem('rateplan.customLabels') || '{}') || {}; } catch {}
          const items = ids.map(id => ({
            id,
            name: (id === 1) ? 'Standard'
                : (labels.CUS1 || labels.CUS2 || `Plan ${id}`)
          }));

          // 5) Ensure Standard is present when nothing else included
          if (!items.some(p => p.id === 1)) items.unshift({ id:1, name:'Standard' });

          // 6) Dedupe by id, preserving order
          const seen = new Set();
          return items.filter(p => (seen.has(p.id) ? false : (seen.add(p.id), true)));
        }

        const payload = window.__detailsPayload || {};
        const rooms = Array.isArray(payload.rooms) ? payload.rooms : [];

        function getPlanPriceForRoom(roomTypeId, ratePlanId) {
          const rid = Number(roomTypeId);
          const pid = Number(ratePlanId);

          try {
            const payload = window.__detailsPayload || {};
            const rooms = Array.isArray(payload.rooms) ? payload.rooms : [];
            const room = rooms.find(rm => {
              const rtId = rm.roomTypeId != null ? Number(rm.roomTypeId) : null;
              const id   = rm.id != null ? Number(rm.id) : null;
              return rtId === rid || id === rid;
            });
            if (!room) return null;

            // 1) If backend gives per-plan summary, trust that first
            if (Array.isArray(room.ratePlanSummaries)) {
              const rp = room.ratePlanSummaries.find(x => Number(x.ratePlanId) === pid);
              if (rp) {
                const v = Number(rp.priceFrom);
                if (Number.isFinite(v)) return v;
              }
            }

            // 2) Derive a base STANDARD nightly price from room.daily or priceFrom
            let baseStd = null;

            if (Array.isArray(room.daily) && room.daily.length) {
              const nums = room.daily
                .map(d => {
                  if (d == null) return NaN;
                  if ("price" in d) return Number(d.price);
                  if ("amount" in d) return Number(d.amount);
                  if ("basePrice" in d) return Number(d.basePrice);
                  return NaN;
                })
                .filter(Number.isFinite);

              if (nums.length) {
                // use the minimum as "from" price, consistent with how you show From $X
                baseStd = Math.min.apply(null, nums);
              }
            }

            if (baseStd == null && room.priceFrom != null) {
              const v = Number(room.priceFrom);
              if (Number.isFinite(v)) baseStd = v;
            }

            if (baseStd == null) return null;

            // 3) Apply rate plan rules on top of the base STANDARD price
            if (pid === 1) {
              // Standard: base
              return baseStd;
            }
            if (pid === 2) {
              // Non-refundable: -10 percent
              return Math.round(baseStd * 0.9 * 100) / 100;
            }
            if (pid === 3) {
              // With Breakfast: +10
              return baseStd + 10;
            }

            // Fallback for any other plan ids
            return baseStd;
          } catch (e) {
            console.warn("[getPlanPriceForRoom] failed", e);
            return null;
          }
        }

        const openRooms = rooms
          .map(r => {
            const daily = Array.isArray(r.daily) ? r.daily : [];
            const openNights = daily.filter(d => !d.closed && Number(d.inventory ?? d.open ?? 0) > 0);
            const minPrice = openNights.length
              ? Math.min(...openNights.map(d => Number(d.price ?? Infinity)))
              : null;
            return { room: r, openNights, minPrice };
          })
          .filter(x => x.openNights.length > 0);

        // Update the big right-hand "From" price to the lowest across all open rooms
        try {
          const globalMin = openRooms.reduce((acc, x) => {
            const p = Number(x.minPrice);
            if (!Number.isFinite(p)) return acc;
            return acc == null ? p : Math.min(acc, p);
          }, null);
          if (typeof fromEl !== 'undefined' && fromEl && globalMin != null) {
            fromEl.textContent = money(globalMin);
          }
        } catch (_) {}

        if (!openRooms.length){
          listEl.innerHTML = `
            <div class="small" style="color:var(--muted); padding:4px 0;">
              No room categories with open inventory for these dates.
            </div>`;
          return;
        }

        const ph = (label='Room') => 'data:image/svg+xml;utf8,' + encodeURIComponent(
          `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 270">
            <rect width="400" height="270" fill="#f3f4f6"/>
            <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle"
              font-family="Inter, Arial, sans-serif" font-size="16" fill="#9ca3af">${label}</text>
          </svg>`);

        const plans = derivePlansForDisplay(); // [{id,name}, …]

        function planRowsHTML(roomId) {
        // Fixed 3 core plans, in the order you want to show them
        const basePlans = [
          { id: 1, label: 'Standard',       desc: 'Flexible standard rate with free cancellation.' },
          { id: 2, label: 'Non-refundable', desc: 'Lower price, no refunds or changes.' },
          { id: 3, label: 'With Breakfast', desc: 'This rate includes breakfast for 2.' }
        ];

        const plansQS = '';

        // Try to get the Standard plan price from the payload
        const stdFromBackend = getPlanPriceForRoom(roomId, 1);
        const baseStd = stdFromBackend != null && Number.isFinite(Number(stdFromBackend))
          ? Number(stdFromBackend)
          : null;

        const rows = basePlans.map(p => {
          // First choice: use backend per-plan price if present
          let rawPrice = getPlanPriceForRoom(roomId, p.id);
          let numPrice = rawPrice != null ? Number(rawPrice) : null;

          // Fallback: derive per-plan price from Standard using your rules
          if (numPrice == null || !Number.isFinite(numPrice)) {
            if (baseStd != null) {
              if (p.id === 1) {
                // Standard: base price
                numPrice = baseStd;
              } else if (p.id === 2) {
                // Non-refundable: -10 percent
                numPrice = Math.round(baseStd * 0.9 * 100) / 100;
              } else if (p.id === 3) {
                // With Breakfast: +10
                numPrice = baseStd + 10;
              }
            }
          }
            const hasPrice = numPrice != null && Number.isFinite(numPrice);
            const priceLabel = hasPrice ? money(numPrice) : null;
            const priceHtml = hasPrice
              ? `<div class="meta"><strong>${priceLabel}</strong> / night</div>`
              : '';

            const url =
              `/room_details.html?propertyId=${encodeURIComponent(propertyId)}` +
              `&roomId=${encodeURIComponent(roomId)}` +
              `&start=${encodeURIComponent(start)}` +
              `&end=${encodeURIComponent(end)}` +
              `&ratePlanId=${encodeURIComponent(p.id)}` +
              `&planLabel=${encodeURIComponent(p.label)}` +
              `${plansQS}`;

            return `
              <div class="planrow" data-plan-id="${p.id}">
                <div>
                  <div class="planname">${p.label}</div>
                  <div class="meta">${p.desc}</div>
                  ${priceHtml}
                </div>
                <a class="btn-select" href="${url}" aria-label="Select ${p.label}">Select</a>
              </div>`;
          }).join('');

          return rows;
        }
     
        listEl.innerHTML = openRooms.map(({ room, minPrice }) => {
          const rid = room.roomTypeId ?? room.typeId ?? room.id ?? room.roomId ?? room.code ?? '';
          const name = String(room.name ?? 'Room').trim() || 'Room';
          // Prefer room-level images; fall back to property-level/detail images; then placeholder
          let thumb = null;
          if (Array.isArray(room.images) && room.images.length) {
            thumb = room.images[0]?.url || room.images[0] || null;
          }
          if (!thumb) {
            try {
              const payload = window.__detailsPayload || {};
              if (Array.isArray(payload.images) && payload.images.length) {
                const it = payload.images[0];
                thumb = (typeof it === "string")
                  ? it
                  : (it?.url || it?.photoUrl || it?.imageUrl || it?.src || it?.href || null);
              }
            } catch {}
          }
          if (!thumb && Array.isArray(images) && images.length) {
            const it = images[0];
            thumb = (typeof it === "string")
              ? it
              : (it?.url || it?.photoUrl || it?.imageUrl || it?.src || it?.href || null);
          }
          if (!thumb) {
            thumb = ph(name);
          }

          // Transparent nightly pricing for this room within the search window
          const daily = Array.isArray(room.daily) ? room.daily : [];
          const pricedNights = daily
            .filter(d => !d?.closed && Number(d?.inventory ?? d?.open ?? 0) > 0)
            .map(d => {
              if (!d) return NaN;
              if ("price" in d) return Number(d.price);
              if ("amount" in d) return Number(d.amount);
              if ("basePrice" in d) return Number(d.basePrice);
              return NaN;
            })
            .filter(Number.isFinite);

          let avg = null, min = null, max = null;
          if (pricedNights.length) {
            const sum = pricedNights.reduce((s, v) => s + v, 0);
            avg = sum / pricedNights.length;
            min = Math.min(...pricedNights);
            max = Math.max(...pricedNights);
          }

          const m2 = room.areaM2 ?? room.areaSqm ?? null;
          const ft2 = room.areaFt2 ?? (m2 ? Math.round(m2 * 10.7639) : null);
          const m2txt = m2 ? `${m2} m²` : '';
          const ft2txt = ft2 ? `${ft2} ft²` : '';
          const area = (m2txt || ft2txt) ? ` · ${[m2txt, ft2txt].filter(Boolean).join(' / ')}` : '';

          let priceMeta;
          if (avg != null && isFinite(avg)) {
            const avgStr = `$${avg.toFixed(2)}`;
            if (min != null && max != null && isFinite(min) && isFinite(max) && min !== max) {
              priceMeta = `Avg ${avgStr} per night (range $${min.toFixed(2)}–$${max.toFixed(2)})`;
            } else {
              priceMeta = `Avg ${avgStr} per night`;
            }
          } else {
            priceMeta = 'Price unavailable for these dates';
          }

          return `
            <div class="roomcat" data-room-id="${rid}">
            ${ (plans && plans.length >= 1)
                ? `<button class="toggle" type="button" aria-expanded="false" aria-label="Show plans" tabindex="0" role="button">+</button>`
                : `<span class="visually-hidden">Single rate plan</span>` }

            <img src="${thumb}" alt="${name} thumbnail" loading="lazy" decoding="async">
            <div>
              <h3>${name}</h3>
              <div class="meta">${priceMeta}${area}</div>
            </div>

            <a class="btn-select"
              href="/room_details.html?propertyId=${encodeURIComponent(String(propertyId))}&start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}&ratePlanId=${
                encodeURIComponent((() => { try {
                  const u = new URL(location.href);
                  const p = u.searchParams.get('ratePlanId') || u.searchParams.get('plan');
                  if (p && Number.isFinite(Number(p))) return String(Number(p));
                  const last = Number(localStorage.getItem('rateplan.lastPlanId') || '');
                  return Number.isFinite(last) ? String(last) : '1';
                } catch(_) { return '1'; } })())
              }"
              aria-label="Select ${name}">Select</a>

            ${ (plans && plans.length >= 1)
                ? `<div class="planlist" aria-label="Rate plans for ${name}">
                    ${planRowsHTML(rid)}
                  </div>`
                : `` }
          </div>
        `;
        }).join('');

        setTimeout(() => {
          try { hydratePlansFromPartners?.(); }
          catch (e) { console.warn('[hydrate] after render failed', e); }
        }, 0);

        // (no MutationObserver auto-rehydrate block here anymore)

        // ANCHOR: PARTNER_HYDRATE_AFTER_RENDER
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            try { hydratePlansFromPartners?.(); } catch (e) { console.warn('[hydrate] failed', e); }
          });
        });

        // === Persist expand/collapse per property+room (session only) ===
        const EXPAND_KEY = `details.expand.${propertyId}`;
        function loadExpandMap(){
          try { return JSON.parse(sessionStorage.getItem(EXPAND_KEY) || '{}') || {}; } catch { return {}; }
        }
        function saveExpandMap(map){
          try { sessionStorage.setItem(EXPAND_KEY, JSON.stringify(map || {})); } catch {}
        }
        function applyExpandedFromStorage(){
          const map = loadExpandMap();
          document.querySelectorAll('#roomCats .roomcat').forEach(cat => {
            const rid = cat.getAttribute('data-room-id');
            if (!rid) return;
            if (map[rid]) {
              const panel = cat.querySelector('.planlist');
              const toggle = cat.querySelector('.toggle');
              if (panel) panel.classList.add('open');
              if (toggle) { toggle.setAttribute('aria-expanded','true'); toggle.textContent = '−'; }
            }
          });
        }
        applyExpandedFromStorage();

        // === Partner-managed rate plans: hydrate per-room plan names/ids ===
        window.hydratePlansFromPartners = async function hydratePlansFromPartners(){
          // helpers
          function selectedIds(){
            try {
              const a = JSON.parse(localStorage.getItem('rateplan.selectedIds') || '[]');
              return Array.isArray(a) ? a.map(Number).filter(Number.isFinite) : [];
            } catch { return []; }
          }
          function customLabels(){
            try { return JSON.parse(localStorage.getItem('rateplan.customLabels') || '{}') || {}; }
            catch { return {}; }
          }
          function labelFor(plan){
            const code = String(plan.code || '').toUpperCase();
            const lbls = customLabels(); // { CUS1: "...", CUS2: "..." }

            // Partner overrides
            if (code === 'CUS1' && lbls.CUS1) return lbls.CUS1;
            if (code === 'CUS2' && lbls.CUS2) return lbls.CUS2;

            // Built-ins
            if (code === 'STD' || Number(plan.id) === 1) return 'Standard';
            if (code === 'BRKF' || /breakfast/i.test(plan.name || '')) return 'With Breakfast';
            if (code === 'NRF' || /non[-\s]?ref/i.test(plan.name || '')) return 'Non-refundable';

            // Fallback
            return String(plan.name || plan.code || `Plan ${plan.id}`);
          }

          function describePlan(plan){
            const label = labelFor(plan);

            if (/non[-\s]?ref/i.test(label)) {
              return 'Lower price, no refunds or changes.';
            }
            if (/with breakfast/i.test(label)) {
              return 'This rate includes breakfast for 2.';
            }
            if (/standard/i.test(label)) {
              return 'Flexible standard rate with free cancellation.';
            }
            return 'Standard conditions apply for this rate.';
          }

          function planSortKey(plan){
            const label = labelFor(plan);

            if (/non[-\s]?ref/i.test(label))   return 1; // cheapest
            if (/standard/i.test(label))       return 2;
            if (/with breakfast/i.test(label)) return 3; // most expensive

            return 99; // unknown / custom at the end
          }

          async function fetchPlans(roomId){
            if (!roomId) return [];
            const rid = String(roomId).trim();

            // include propertyId and send cookies for auth
            const url = `/extranet/property/rateplans?propertyId=${encodeURIComponent(propertyId)}&roomTypeId=${encodeURIComponent(rid)}`;

            try {
              const fetcher = (typeof window.authFetch === 'function') ? window.authFetch : fetch;
              const r = await fetcher(url, {
                method: 'GET',
                cache: 'no-store',
                credentials: 'include'
              });

              if (!r.ok) throw new Error(`HTTP ${r.status}`);

              const j = await r.json();
              const raw = Array.isArray(j) ? j : (j.rows || j.plans || j.data || j.result || []);

              const parsed = raw
                .map(p => ({
                  id: Number(p.id ?? p.ratePlanId ?? p.rate_plan_id),
                  code: String(p.code ?? p.ratePlanCode ?? p.rate_plan_code ?? '').toUpperCase(),
                  name: p.name ?? p.label ?? p.code ?? `Plan ${p.id ?? p.ratePlanId}`
                }))
                .filter(p => Number.isFinite(p.id));

              if (!parsed.length) {
                console.warn('[hydratePlansFromPartners] no usable rateplans for room', rid);
              }

              return parsed;
            } catch (err) {
              console.warn('[hydratePlansFromPartners] fetchPlans failed for room', rid, err);
              return [];
            }
          }

          function renderPlanRows(roomId, plans){
            const sel = selectedIds();
            const plansQS = sel.length ? `&plans=${encodeURIComponent(sel.join(','))}` : '';
            // If partners selected specific plans, filter to those; otherwise keep all
            const inScope = sel.length ? plans.filter(p => sel.includes(p.id)) : plans.slice();
            // Ensure Standard (id:1) shows when nothing selected
            const rows = (inScope.length ? inScope : [{ id:1, code:'STD', name:'Standard' }])
              .map(p => {
                const name = labelFor(p);
                const desc = describePlan(p);

                // NEW: pull per-plan price for this room+plan from /catalog/details payload
                const rawPrice = getPlanPriceForRoom(roomId, p.id);
                const hasPrice = rawPrice != null && Number.isFinite(Number(rawPrice));
                const priceLabel = hasPrice ? money(rawPrice) : null;
                const priceHtml = hasPrice
                  ? `<div class="meta"><strong>${priceLabel}</strong> / night</div>`
                  : '';

                const url =
                  `/room_details.html?propertyId=${encodeURIComponent(propertyId)}` +
                  `&roomId=${encodeURIComponent(roomId)}` +
                  `&start=${encodeURIComponent(start)}` +
                  `&end=${encodeURIComponent(end)}` +
                  `&ratePlanId=${encodeURIComponent(p.id)}` +
                  `&planLabel=${encodeURIComponent(name)}` +
                  `${plansQS}`;

                return `
                  <div class="planrow" data-plan-id="${p.id}">
                    <div>
                      <div class="planname">${name}</div>
                      <div class="meta">${desc}</div>
                      ${priceHtml}
                    </div>
                    <a class="btn-select" href="${url}" aria-label="Select ${name}">Select</a>
                  </div>`;
              }).join('');
            return rows;
          }

          // === HYDRATE_LOOP_BEGIN (drop-in replacement) ===
          async function waitForCats(maxTries = 20){
            for (let i = 0; i < maxTries; i++){
              const nodes = document.querySelectorAll('#roomCats .roomcat');
              if (nodes.length) return nodes;
              await new Promise(r => setTimeout(r, 100));
            }
            return document.querySelectorAll('#roomCats .roomcat');
          }

          // Pull room ids from the payload (authoritative) and wait for DOM rows
          const payloadRoomIds = (Array.isArray(j?.rooms) ? j.rooms : [])
            .map(r =>
              r.roomTypeId ?? r.typeId ?? r.id ?? r.roomId ?? r.code
            )
            .filter(Boolean)
            .map(v => String(v));

          await waitForCats();

          for (const ridRaw of payloadRoomIds){
            const rid = String(ridRaw);
            const selector = `#roomCats .roomcat[data-room-id="${CSS.escape(rid)}"]`;
            const cat = document.querySelector(selector);
            if (!cat) continue;

            let panel = cat.querySelector('.planlist');
            if (!panel){
              panel = document.createElement('div');
              panel.className = 'planlist';
              panel.setAttribute('aria-label', 'Rate plans');
              cat.appendChild(panel);
            }

            let plans = await fetchPlans(rid);        // [{id,code,name}]
            if (!plans.length) continue;

            // sync with locally stored partner state (selectedIds/customLabels)
            try {
              const sel = JSON.parse(localStorage.getItem('rateplan.selectedIds') || '[]');
              const lbls = JSON.parse(localStorage.getItem('rateplan.customLabels') || '{}') || {};
              const activeIds = Array.isArray(sel) ? sel.map(Number).filter(Number.isFinite) : [];

              if (activeIds.length) plans = plans.filter(p => activeIds.includes(p.id));
              plans.forEach(p => {
                if (p.code === 'CUS1' && lbls.CUS1) p.name = lbls.CUS1;
                if (p.code === 'CUS2' && lbls.CUS2) p.name = lbls.CUS2;
              });
            } catch {}

            if (!plans.length) continue;

            panel.innerHTML = renderPlanRows(rid, plans);          // render rows
            panel.setAttribute('data-hydrated', 'true');           // mark as partner-authoritative
            panel.dataset.hydratedAt = String(Date.now());         // (optional) timestamp for debugging

            // Update the top-right Select link to primary (cheapest) in-scope plan
            const selIds = (function(){
              try {
                const a = JSON.parse(localStorage.getItem('rateplan.selectedIds') || '[]');
                return Array.isArray(a) ? a.map(Number).filter(Number.isFinite) : [];
              } catch { return []; }
            })();
            const plansQS = selIds.length ? `&plans=${encodeURIComponent(selIds.join(','))}` : '';

            let inScopeTop = selIds.length ? plans.filter(p => selIds.includes(p.id)) : plans.slice();
            if (!inScopeTop.length) {
              inScopeTop = [{ id:1, code:'STD', name:'Standard' }];
            }

            const sortedTop = inScopeTop.slice().sort((a, b) => {
              const pa = planSortKey(a);
              const pb = planSortKey(b);
              if (pa !== pb) return pa - pb;
              return (Number(a.id) || 0) - (Number(b.id) || 0);
            });

            const primary = sortedTop[0] || { id:1 };

            const topLink = cat.querySelector('.btn-select');
            if (topLink){
              const href = `/room_details.html?propertyId=${encodeURIComponent(propertyId)}&roomId=${encodeURIComponent(rid)}&start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}&ratePlanId=${encodeURIComponent(primary.id)}${plansQS}`;
              topLink.setAttribute('href', href);
            }

            // Keep the toggle visible on details page as long as there is at least one plan.
            const hasAnyPlan = plans.length > 0;
            let toggle = cat.querySelector('.toggle');

            if (hasAnyPlan && !toggle) {
              // Re-create the button if markup was missing
              toggle = document.createElement('button');
              toggle.className = 'toggle';
              toggle.type = 'button';
              toggle.setAttribute('aria-expanded', 'false');
              toggle.setAttribute('aria-label', 'Show plans');
              toggle.textContent = '+';
              cat.insertBefore(toggle, cat.firstElementChild);
            } else if (!hasAnyPlan && toggle) {
              // Only strip the toggle if we truly have zero plans
              toggle.replaceWith(document.createElement('span'));
            }
          }
          // === HYDRATE_LOOP_END ===
        };
        hydratePlansFromPartners().catch(()=>{});

        // Re-hydrate when returning from partners hub or when labels/selection change
        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'visible') {
            // re-run the partner plan hydration to pick up latest state
            (async () => { try { await (async function(){ await hydratePlansFromPartners?.(); })(); } catch(_){} })();
          }
        });

        // Also react to cross-tab/local edits (selectedIds, customLabels)
        window.addEventListener('storage', (e) => {
          if (!e) return;
          if (e.key === 'rateplan.selectedIds' || e.key === 'rateplan.customLabels') {
            (async () => { try { await (async function(){ await hydratePlansFromPartners?.(); })(); } catch(_){} })();
          }
        });

        // ANCHOR: ROOM_MODAL_CLICK_WIRE
        listEl.addEventListener('click', (e) => {
          const btn = e.target.closest('.planrow .btn-select, .roomcat > .btn-select');
          if (!btn) return;

          // Let keyboard / accessibility still focus the element
          e.preventDefault();

          const cat = btn.closest('.roomcat');
          if (!cat) return;

          const rid = cat.getAttribute('data-room-id') || '';
          const payload = window.__detailsPayload || {};
          const rooms = Array.isArray(payload.rooms) ? payload.rooms : [];

          // Match room by same id mapping used elsewhere
          const room = rooms.find(r => {
            const cand =
              r.roomTypeId ?? r.typeId ?? r.id ?? r.roomId ?? r.code ?? '';
            return String(cand) === String(rid);
          }) || null;

          // Pull plan info if this is inside a planrow
          let planId = null;
          let planLabel = null;

          const row = btn.closest('.planrow');
          if (row) {
            const pid = Number(row.getAttribute('data-plan-id'));
            if (Number.isFinite(pid)) planId = pid;

            const nameEl = row.querySelector('.planname');
            if (nameEl) planLabel = String(nameEl.textContent || '').trim() || null;
          }

          // Fallback: derive planId from href if not on a planrow
          if (!planId && btn.href) {
            try {
              const u = new URL(btn.href, location.href);
              const p = Number(u.searchParams.get('ratePlanId'));
              if (Number.isFinite(p)) planId = p;
            } catch {}
          }

          if (!planLabel && planId) {
            planLabel = `Plan ${planId}`;
          }

          const ctx = { room, roomId: rid, planId, planLabel };

          if (typeof window.openRoomModal === 'function') {
            window.openRoomModal(ctx);
          } else {
            console.log('[room-modal] handler: openRoomModal missing, ctx=', ctx);
          }
        });

        // Persist last chosen plan when any "Select" is clicked
        listEl.addEventListener('click', (e) => {
          const link = e.target.closest('.planrow .btn-select, .roomcat > .btn-select');
          if (!link) return;

          try {
            // Prefer data-plan-id from plan rows; otherwise read from link href
            const row = e.target.closest('.planrow');
            let pid = row ? Number(row.getAttribute('data-plan-id')) : NaN;
            if (!Number.isFinite(pid)) {
              const u = new URL(link.href, location.href);
              pid = Number(u.searchParams.get('ratePlanId'));
            }
            if (Number.isFinite(pid)) {
              localStorage.setItem('rateplan.lastPlanId', String(pid));
              // optional: mirror into selectedIds if partner has none
              const sel = JSON.parse(localStorage.getItem('rateplan.selectedIds') || '[]');
              if (Array.isArray(sel) && !sel.map(Number).includes(pid)) {
                localStorage.setItem('rateplan.selectedIds', JSON.stringify([...sel, pid]));
              }
            }
          } catch {}
        });

        /* Toggle open/closed with mouse */
        listEl.addEventListener('click', (e) => {
          const t = e.target.closest('.toggle');
          if (!t) return;
          const cat = t.closest('.roomcat');
          const panel = cat.querySelector('.planlist');
          if (!panel) return;
          const open = panel.classList.toggle('open');

          // close any other open room panels (accordion behavior)
          if (open) {
            document.querySelectorAll('#roomCats .roomcat .planlist.open').forEach(pl => {
              if (pl === panel) return;
              pl.classList.remove('open');
              pl.setAttribute('aria-hidden','true');
              const btn = pl.closest('.roomcat')?.querySelector('.toggle');
              if (btn){
                btn.setAttribute('aria-expanded','false');
                btn.setAttribute('aria-label','Show plans');
                btn.textContent = '+';
              }
              // keep persistence in sync for the room we just closed
              const rid2 = pl.closest('.roomcat')?.getAttribute('data-room-id');
              if (rid2){
                const map = loadExpandMap();
                map[rid2] = false;
                saveExpandMap(map);
              }
            });
          }

          panel.setAttribute('aria-hidden', open ? 'false' : 'true');
          t.setAttribute('aria-expanded', open ? 'true' : 'false');
          t.setAttribute('aria-label', open ? 'Hide plans' : 'Show plans');
          t.textContent = open ? '−' : '+';
          if (open) { cat.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); }

          // persist expanded state (sessionStorage)
          const rid = cat.getAttribute('data-room-id');
          const map = loadExpandMap();
          map[rid] = !!open;
          saveExpandMap(map);
        });
     
        /* Also support keyboard (Enter/Space) on the toggle */
        listEl.addEventListener('keydown', (e) => {
          const t = e.target.closest('.toggle');
          if (!t) return;
          if (e.key !== 'Enter' && e.key !== ' ') return;
          e.preventDefault();
          const cat = t.closest('.roomcat');
          const panel = cat.querySelector('.planlist');
          if (!panel) return;
          const open = panel.classList.toggle('open');

          // close any other open room panels (accordion behavior)
          if (open) {
            document.querySelectorAll('#roomCats .roomcat .planlist.open').forEach(pl => {
              if (pl === panel) return;
              pl.classList.remove('open');
              pl.setAttribute('aria-hidden','true');
              const btn = pl.closest('.roomcat')?.querySelector('.toggle');
              if (btn){
                btn.setAttribute('aria-expanded','false');
                btn.setAttribute('aria-label','Show plans');
                btn.textContent = '+';
              }
              // keep persistence in sync for the room we just closed
              const rid2 = pl.closest('.roomcat')?.getAttribute('data-room-id');
              if (rid2){
                const map = loadExpandMap();
                map[rid2] = false;
                saveExpandMap(map);
              }
            });
          }

          panel.setAttribute('aria-hidden', open ? 'false' : 'true');
          t.setAttribute('aria-expanded', open ? 'true' : 'false');
          t.setAttribute('aria-label', open ? 'Hide plans' : 'Show plans');
          t.textContent = open ? '−' : '+';
          if (open) { cat.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); }

          // persist expanded state (sessionStorage)
          const rid = cat.getAttribute('data-room-id');
          const map = loadExpandMap();
          map[rid] = !!open;
          saveExpandMap(map);
        });

        // ANCHOR: ROOM_MODAL_CLICK_WIRE
        listEl.addEventListener('click', (e) => {
          const btn = e.target.closest('.planrow .btn-select, .roomcat > .btn-select');
          if (!btn) return;

          // We are handling this click for the modal, so stop navigation
          e.preventDefault();

          const cat = btn.closest('.roomcat');
          if (!cat) return;

          const rid = cat.getAttribute('data-room-id') || '';
          const payload = window.__detailsPayload || {};
          const rooms = Array.isArray(payload.rooms) ? payload.rooms : [];

          // Match room by the same id mapping used elsewhere
          const room = rooms.find(r => {
            const cand =
              r.roomTypeId ?? r.typeId ?? r.id ?? r.roomId ?? r.code ?? '';
            return String(cand) === String(rid);
          }) || null;

          // Pull plan info if this is inside a planrow
          let planId = null;
          let planLabel = null;

          const row = btn.closest('.planrow');
          if (row) {
            const pid = Number(row.getAttribute('data-plan-id'));
            if (Number.isFinite(pid)) planId = pid;

            const nameEl = row.querySelector('.planname');
            if (nameEl) planLabel = String(nameEl.textContent || '').trim() || null;
          }

          // Fallback: derive planId from href if not on a planrow
          if (!planId && btn.href) {
            try {
              const u = new URL(btn.href, location.href);
              const p = Number(u.searchParams.get('ratePlanId'));
              if (Number.isFinite(p)) planId = p;
            } catch {}
          }

          if (!planLabel && planId) {
            planLabel = `Plan ${planId}`;
          }

          const ctx = { room, roomId: rid, planId, planLabel };

          if (typeof window.openRoomModal === 'function') {
            window.openRoomModal(ctx);
          } else {
            console.log('[room-modal] handler: openRoomModal missing, ctx=', ctx);
          }
        });

        // When the top-right "Select" button is clicked, open the room modal instead of navigating
        listEl.addEventListener('click', (e) => {
          const btn = e.target.closest('.roomcat > .btn-select');
          if (!btn) return;

          const cat = btn.closest('.roomcat');
          const rid = cat ? cat.getAttribute('data-room-id') : null;
          if (!rid) return;

          e.preventDefault();
          e.stopPropagation();

          if (typeof window.openRoomModalById === 'function') {
            window.openRoomModalById(rid);
          }
        });

        // Persist chosen plan and ensure &plans= follows the link
        listEl.addEventListener('click', (e) => {
          const a = e.target.closest('.planrow .btn-select, .roomcat > .btn-select');
          if (!a) return;

          try {
            // 1) Persist last clicked plan id (for top "Select" and subrows)
            const row = e.target.closest('.planrow');
            const pid = row ? Number(row.getAttribute('data-plan-id')) : null;
            if (Number.isFinite(pid)) {
              localStorage.setItem('rateplan.lastPlanId', String(pid));
            }

            // 2) Append &plans=<csv> from localStorage if present
            const sel = (() => {
              try {
                const arr = JSON.parse(localStorage.getItem('rateplan.selectedIds') || '[]');
                return Array.isArray(arr)
                  ? [...new Set(arr.map(Number).filter(Number.isFinite))]
                  : [];
              } catch { return []; }
            })();

            if (sel.length) {
              const u = new URL(a.href, location.origin);
              u.searchParams.set('plans', sel.join(','));
              a.setAttribute('href', u.toString());
            }
          } catch (_) {}
        });

        /* Repaint sub-rows if plans changed while away (hub -> back) — delegate to partner hydration */
        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState !== 'visible') return;
          try {
            // Re-run the authoritative partner hydrate instead of repainting from the local fallback.
            hydratePlansFromPartners?.();
          } catch (_) {
            // no-op
          }
        });
      })();
    }

    // ANCHOR: ROOM_MODAL_STUB
    window.openRoomModal = function openRoomModal(ctx) {
      // ctx: { room, roomId, planId, planLabel }
      console.log('[room-modal] openRoomModal called with:', ctx);

    // Step 3 will build the actual modal DOM and 25/50/25 layout.
    };

    /* ANCHOR: ROOM_MODAL_JS */
    (function(){
      const backdrop   = document.getElementById("roomModalBackdrop");
      const modalImg   = document.getElementById("roomModalHeroImg");
      const modalTitle = document.getElementById("roomModalTitle");
      const modalMeta  = document.getElementById("roomModalMeta");
      const thumbsWrap = document.getElementById("roomModalThumbs");
      const plansWrap  = document.getElementById("roomModalPlans");

      const modalSummary        = document.getElementById("roomModalSummary");
      const modalSpecs          = document.getElementById("roomModalSpecs");
      const detailsSection      = document.getElementById("roomModalDetailsSection");
      const detailsList         = document.getElementById("roomModalDetailsList");
      const inclusionsSection   = document.getElementById("roomModalInclusionsSection");
      const inclusionsList      = document.getElementById("roomModalInclusionsList");

      // ANCHOR: ROOM_MODAL_LIGHTBOX_JS
      const lightboxEl  = document.getElementById("roomModalLightbox");
      const lbBackdrop  = lightboxEl ? lightboxEl.querySelector(".room-modal-lightbox-backdrop") : null;
      const lbImg       = lightboxEl ? lightboxEl.querySelector(".room-modal-lightbox-img") : null;
      const lbCloseBtn  = lightboxEl ? lightboxEl.querySelector(".room-modal-lightbox-close") : null;
      const lbPrevBtn   = lightboxEl ? lightboxEl.querySelector(".room-modal-lightbox-prev") : null;
      const lbNextBtn   = lightboxEl ? lightboxEl.querySelector(".room-modal-lightbox-next") : null;

      let lbImages = [];
      let lbIndex  = 0;
      let lbBound  = false;

      function lbRender(){
        if (!lbImg || !lbImages.length) return;
        if (lbIndex < 0) lbIndex = 0;
        if (lbIndex >= lbImages.length) lbIndex = lbImages.length - 1;
        lbImg.src = lbImages[lbIndex];
      }

      function lbOpen(startIndex){
        if (!lightboxEl || !lbImages.length) return;
        if (Number.isFinite(startIndex)) {
          lbIndex = Math.min(Math.max(startIndex, 0), lbImages.length - 1);
        } else {
          lbIndex = 0;
        }
        lbRender();
        lightboxEl.classList.add("is-open");
        lightboxEl.setAttribute("aria-hidden","false");
      }

      function lbClose(){
        if (!lightboxEl) return;
        lightboxEl.classList.remove("is-open");
        lightboxEl.setAttribute("aria-hidden","true");
      }

      function lbStep(delta){
        if (!lbImages.length) return;
        const len = lbImages.length;
        lbIndex = (lbIndex + delta + len) % len;
        lbRender();
      }

      function lbBindOnce(){
        if (lbBound || !lightboxEl) return;
        lbBound = true;

        if (lbCloseBtn) {
          lbCloseBtn.addEventListener("click", lbClose);
        }

        if (lbBackdrop) {
          lbBackdrop.addEventListener("click", lbClose);
        }

        if (lbPrevBtn) {
          lbPrevBtn.addEventListener("click", () => lbStep(-1));
        }

        if (lbNextBtn) {
          lbNextBtn.addEventListener("click", () => lbStep(1));
        }

        // Basic swipe support
        let touchStartX = null;
        lightboxEl.addEventListener("touchstart", (e) => {
          if (e.touches && e.touches.length === 1) {
            touchStartX = e.touches[0].clientX;
          }
        }, { passive: true });

        lightboxEl.addEventListener("touchend", (e) => {
          if (touchStartX == null || !e.changedTouches || !e.changedTouches.length) return;
          const dx = e.changedTouches[0].clientX - touchStartX;
          touchStartX = null;
          if (Math.abs(dx) < 40) return; // ignore tiny swipes
          if (dx < 0) {
            lbStep(1);   // swipe left -> next
          } else {
            lbStep(-1);  // swipe right -> prev
          }
        }, { passive: true });

        // Keyboard support when lightbox is open
        document.addEventListener("keydown", (e) => {
          if (!lightboxEl.classList.contains("is-open")) return;
          if (e.key === "Escape") {
            lbClose();
          } else if (e.key === "ArrowRight") {
            lbStep(1);
          } else if (e.key === "ArrowLeft") {
            lbStep(-1);
          }
        });
      }

      // Share room-info metadata with partners extranet via localStorage
      const ROOM_INFO_LS_KEY = "extranet_roomInfo_v1";

      function loadRoomInfoMap(){
        try{
          const raw = localStorage.getItem(ROOM_INFO_LS_KEY);
          if (!raw) return {};
          const obj = JSON.parse(raw);
          return (obj && typeof obj === "object") ? obj : {};
        }catch(_){
          return {};
        }
      }

      if (!backdrop) return;

      const DETAIL_LABELS = {
        city_view:        "City view",
        sea_view:         "Sea / ocean view",
        garden_view:      "Garden view",
        pool_view:        "Pool view",
        high_floor:       "High floor",
        ground_floor:     "Ground floor",
        connecting:       "Connecting rooms available",
        accessible:       "Accessible room",
        kitchenette:      "Kitchenette",
        separate_living:  "Separate living area",
      };

      const INCLUSION_LABELS = {
        breakfast:       "Breakfast included",
        half_board:      "Half board",
        full_board:      "Full board",
        all_inclusive:   "All inclusive",
        free_parking:    "Free parking",
        airport_shuttle: "Airport shuttle",
        late_checkout:   "Late checkout (subject to availability)",
        early_checkin:   "Early check-in (subject to availability)",
        pool_access:     "Pool access",
        spa_access:      "Spa / wellness access",
      };

      // Canonical 3 plans only: 1 = Standard, 2 = With Breakfast, 3 = Non-Refundable
      function getModalSelectedPlanIds(){
        let ids = [];

        // 1) localStorage from partners_rooms
        try{
          const raw = localStorage.getItem('rateplan.selectedIds') || '[]';
          const arr = JSON.parse(raw);
          if (Array.isArray(arr)) {
            ids = arr.map(Number).filter(Number.isFinite);
          }
        }catch{}

        // 2) URL (?plans=1,2,3 or ?ratePlanId=1)
        if (!ids.length){
          try{
            const qs  = new URLSearchParams(location.search || '');
            const csv = (qs.get('plans') || '').trim();
            if (csv){
              ids = csv
                .split(',')
                .map(s => Number(s.trim()))
                .filter(Number.isFinite);
            }else{
              const single = Number(qs.get('ratePlanId') || qs.get('plan'));
              if (Number.isFinite(single)) ids = [single];
            }
          }catch{}
        }

        // 3) Default to all three if still empty
        if (!ids.length) ids = [1,2,3];

        // Only allow our three canonical plans and dedupe
        const allowed = [1,2,3];
        const seen = new Set();
        return ids.filter(id => {
          if (!allowed.includes(id)) return false;
          if (seen.has(id)) return false;
          seen.add(id);
          return true;
        });
      }

      function getModalPlanLabel(id){
        if (id === 1) return "Standard";
        if (id === 2) return "With Breakfast";
        if (id === 3) return "Non-Refundable";
        return `Plan ${id}`;
      }

      function getModalPlanDescription(id){
        if (id === 1){
          return "Flexible standard rate with free cancellation.";
        }
        if (id === 2){
          return "This rate includes breakfast for 2.";
        }
        if (id === 3){
          return "Lower price, no refunds or changes.";
        }
        return "Standard conditions apply for this rate.";
      }

      function fillList(ul, labels, extraText) {
        if (!ul) return;
        while (ul.firstChild) ul.removeChild(ul.firstChild);

        (labels || []).forEach(lbl => {
          if (!lbl) return;
          const li = document.createElement("li");
          li.textContent = lbl;
          ul.appendChild(li);
        });

        if (extraText && String(extraText).trim()) {
          const li = document.createElement("li");
          li.textContent = String(extraText).trim();
          ul.appendChild(li);
        }
      }

      function normalizeRoomImages(room){
        let imgs = [];
        if (Array.isArray(room?.images)) {
          imgs = room.images
            .map(it => typeof it === "string"
              ? it
              : (it.url || it.photoUrl || it.imageUrl || it.src || it.href))
            .filter(Boolean);
        }

        if (!imgs.length) {
          const payload = window.__detailsPayload || {};
          if (Array.isArray(payload.images)) {
            imgs = payload.images
              .map(it => typeof it === "string"
                ? it
                : (it.url || it.photoUrl || it.imageUrl || it.src || it.href))
              .filter(Boolean);
          }
        }

        if (!imgs.length) {
          imgs = [ getPlaceholderSVG("No photo available") ];
        }
        return imgs;
      }

      function openRoomModal(room){
        if (!room) return;

        // Overlay metadata from localStorage (partners_rooms edit modal)
        try{
          const rid = String(
            room.roomTypeId ?? room.typeId ?? room.id ?? room.roomId ?? room.code ?? ""
          );
          if (rid) {
            const infoMap  = loadRoomInfoMap();
            const local    = infoMap && infoMap[rid];
            if (local && typeof local === "object") {
              const overrides = {};

              // Text fields
              if (local.summary && String(local.summary).trim()) {
                overrides.summary = String(local.summary).trim();
              }
              if (local.details && String(local.details).trim()) {
                overrides.details_text = String(local.details).trim();
              }
              if (local.inclusions && String(local.inclusions).trim()) {
                overrides.inclusion_text = String(local.inclusions).trim();
              }

              // Size fields
              if (local.sizeSqm) {
                const v = Number(local.sizeSqm);
                overrides.size_sqm = Number.isFinite(v) ? v : local.sizeSqm;
              }
              if (local.sizeSqft) {
                const v = Number(local.sizeSqft);
                overrides.size_sqft = Number.isFinite(v) ? v : local.sizeSqft;
              }

              // Checkbox selections
              if (Array.isArray(local.detailsKeys) && local.detailsKeys.length) {
                overrides.details_keys = local.detailsKeys;
              }
              if (Array.isArray(local.inclusionKeys) && local.inclusionKeys.length) {
                overrides.inclusion_keys = local.inclusionKeys;
              }

              room = Object.assign({}, room, overrides);
            }
          }
        }catch(_){}

        // Title
        modalTitle.textContent = room.name || "Room";

        // Size and specs (use new fields first, fall back to old ones)
        const sizeSqm  = room.size_sqm ?? room.areaM2 ?? room.areaSqm ?? null;
        const sizeSqft = room.size_sqft ?? (sizeSqm ? Math.round(sizeSqm * 10.7639) : (room.areaFt2 ?? null));
        const sizeTxt = sizeSqm
          ? `${sizeSqm} m² / ${sizeSqft} ft²`
          : (sizeSqft ? `${sizeSqft} ft²` : "");

        const maxGuests = room.maxGuests ?? room.occupancy ?? null;
        const specsParts = [];
        if (maxGuests) specsParts.push(`Sleeps up to ${maxGuests} guests`);
        if (sizeTxt)   specsParts.push(sizeTxt);

        if (modalMeta) {
          // Keep a simple, always-present line
          modalMeta.textContent = sizeTxt || "";
        }
        if (modalSpecs) {
          const txt = specsParts.join(" • ");
          modalSpecs.textContent = txt;
          modalSpecs.style.display = txt ? "" : "none";
        }

        // Summary
        if (modalSummary) {
          const s = (room.summary || "").trim();
          modalSummary.textContent = s;
          modalSummary.style.display = s ? "" : "none";
        }

        // Details and inclusions from keys + free text
        const detailKeys = Array.isArray(room.details_keys) ? room.details_keys : [];
        const inclusionKeys = Array.isArray(room.inclusion_keys) ? room.inclusion_keys : [];
        const detailLabels = detailKeys.map(k => DETAIL_LABELS[k]).filter(Boolean);
        const inclusionLabels = inclusionKeys.map(k => INCLUSION_LABELS[k]).filter(Boolean);

        if (detailsSection) {
          const hasAny = detailLabels.length || (room.details_text && String(room.details_text).trim());
          detailsSection.style.display = hasAny ? "" : "none";
          if (hasAny) fillList(detailsList, detailLabels, room.details_text);
        }

        if (inclusionsSection) {
          const hasAny = inclusionLabels.length || (room.inclusion_text && String(room.inclusion_text).trim());
          inclusionsSection.style.display = hasAny ? "" : "none";
          if (hasAny) fillList(inclusionsList, inclusionLabels, room.inclusion_text);
        }

        // Images + lightbox + hover hero update
        const imgs = normalizeRoomImages(room);

        if (!imgs.length) {
          if (modalImg) {
            modalImg.removeAttribute("src");
          }
          if (thumbsWrap) {
            thumbsWrap.innerHTML = "";
          }
        } else {
          if (modalImg) {
            modalImg.src = imgs[0];
            modalImg.style.cursor = "zoom-in";
          }

          // Share images with lightbox
          lbImages = imgs.slice();
          lbBindOnce();
          lbIndex = 0;
          lbRender();

          // Build thumbnails
          thumbsWrap.innerHTML = imgs.map((src, i) => `
            <button type="button" data-i="${i}" aria-current="${i === 0 ? "true" : "false"}">
              <img src="${src}" alt="Photo ${i+1}">
            </button>
          `).join("");

          const thumbButtons = thumbsWrap.querySelectorAll("button");

          thumbButtons.forEach(btn => {
            const idx = Number(btn.dataset.i || "0");

            // Hover: update hero + selected index
            btn.addEventListener("mouseenter", () => {
              if (!imgs.length) return;
              const safeIdx = Number.isFinite(idx) ? idx : 0;
              lbIndex = safeIdx;
              modalImg.src = imgs[safeIdx] || imgs[0];
              thumbButtons.forEach(b => b.removeAttribute("aria-current"));
              btn.setAttribute("aria-current","true");
            });

            // Click: open lightbox at that image
            btn.addEventListener("click", () => {
              if (!imgs.length) return;
              const safeIdx = Number.isFinite(idx) ? idx : 0;
              lbIndex = safeIdx;
              lbOpen(safeIdx);
            });
          });

          // Hero click opens lightbox at current image
          if (modalImg) {
            modalImg.onclick = () => {
              if (!lbImages.length) return;
              lbOpen(lbIndex);
            };
          }
        }

        // Rate plans – 3 canonical plans, horizontal pills with Select buttons
        try {
          if (plansWrap) {
            plansWrap.innerHTML = "";

            const payload    = window.__detailsPayload || {};
            const propertyId = payload.propertyId ?? payload.id ?? "";
            const roomId     = room.roomTypeId ?? room.typeId ?? room.id ?? room.roomId ?? room.code ?? "";

            let start = "";
            let end   = "";
            try {
              const qs = new URLSearchParams(location.search || "");
              start = qs.get("start") || "";
              end   = qs.get("end")   || "";
            } catch {}

            const ids = getModalSelectedPlanIds();

            ids.forEach(id => {
              if (!Number.isFinite(id)) return;

              const label = getModalPlanLabel(id);        // Standard / With Breakfast / Non-Refundable
              const desc  = getModalPlanDescription(id);

              const url =
                `/room_details.html?propertyId=${encodeURIComponent(propertyId)}` +
                `&roomId=${encodeURIComponent(roomId)}` +
                (start ? `&start=${encodeURIComponent(start)}` : "") +
                (end   ? `&end=${encodeURIComponent(end)}`   : "") +
                `&ratePlanId=${encodeURIComponent(id)}`;

              const pill = document.createElement("div");
              pill.className = "room-modal-plan-pill";
              pill.innerHTML =
                `<div class="room-modal-plan-pill-title">${label}</div>
                 <div class="room-modal-plan-pill-desc">${desc}</div>
                 <a class="btn-select room-modal-plan-pill-btn"
                    href="${url}"
                    aria-label="Select ${label}">
                   Select
                 </a>`;

              plansWrap.appendChild(pill);
            });
          }
        } catch (_) {}

        backdrop.classList.add("is-open");
        backdrop.setAttribute("aria-hidden","false");
      }

      function openRoomModalById(roomId){
        const payload = window.__detailsPayload || {};
        const rooms   = Array.isArray(payload.rooms) ? payload.rooms : [];
        const ridStr  = String(roomId);
        const room    = rooms.find(r => String(
          r.roomTypeId ?? r.typeId ?? r.id ?? r.roomId ?? r.code
        ) === ridStr);

        if (room) openRoomModal(room);
      }

      window.openRoomModal    = openRoomModal;
      window.openRoomModalById = openRoomModalById;

      function closeModal(){
        backdrop.classList.remove("is-open");
        backdrop.setAttribute("aria-hidden","true");
      }

      backdrop.addEventListener("click", (e) => {
        if (e.target === backdrop) closeModal();
      });

      const closeBtn = document.querySelector(".room-modal-close");
      if (closeBtn){
        closeBtn.addEventListener("click", closeModal);
      }

      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && backdrop.classList.contains("is-open")) {
          closeModal();
        }
      });
    })();

    /* ANCHOR: TOAST_JS_HELPER */
    function showToast(msg, ms=1600){
      let t = document.querySelector('.toast');
      if (!t){
        t = document.createElement('div');
        t.className = 'toast';
        t.setAttribute('role', 'status');
        t.setAttribute('aria-live', 'polite');
        document.body.appendChild(t);
      }
      t.textContent = msg;
      void t.offsetWidth; // restart transition
      t.classList.add('show');
      clearTimeout(t._hideTimer);
      t._hideTimer = setTimeout(()=>{ t.classList.remove('show'); }, ms);
    }

    load().catch(err=>{
      console.error(err);
      showToast('Failed to load details');

      // Stop the hero shimmer and show a neutral placeholder
      if (heroWrap) heroWrap.classList.remove('is-loading');
      const heroEl = document.getElementById('hero-img');
      if (heroEl) {
        const ph = getPlaceholderSVG('Photo failed to load');
        heroEl.src = ph;
        heroEl.removeAttribute('srcset');
        heroEl.removeAttribute('sizes');
        heroEl.alt = 'Photo failed to load';
      }
    });
    // ANCHOR: ROOM_INFO_EXPORT
    async function exportRoomInfoMock(){
      try{
        const blob = new Blob([JSON.stringify(roomInfoById, null, 2)], {type: 'application/json'});
        const fileHandle = await window.showSaveFilePicker({
          suggestedName: '_room_info_mock.json',
          types: [{ description: 'JSON', accept: {'application/json': ['.json']} }]
        });
        const writable = await fileHandle.createWritable();
        await writable.write(blob);
        await writable.close();
        alert("Saved _room_info_mock.json — upload this to /public/_mock/ in lolaelo-api.");
      }catch(_){}
    }

    // Simple UI to export manually (kept hidden)
    window.exportRoomInfoMock = exportRoomInfoMock;

  </script>

  <!-- ANCHOR: SCROLLTOP_HTML -->
  <button id="scrollTopBtn" class="scrolltop-btn" aria-label="Scroll to top" title="Back to top">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true">
      <path d="M6 14l6-6 6 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
  </button>
  <script>
    // ANCHOR: SCROLLTOP_JS
    (function () {
      const btn = document.getElementById('scrollTopBtn');
      if (!btn) return;

      const prefersReduced =
        window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      const hero = document.querySelector('.hero, #hero, .gallery-hero');
      const baselinePx = 400;
      const threshold = () => {
        if (!hero) return baselinePx;
        const rect = hero.getBoundingClientRect();
        const pageY = window.scrollY + rect.top + rect.height; // bottom of hero
        return Math.max(pageY * 0.02, Math.min(pageY, 800));
      };

      let ticking = false;
      const onScroll = () => {
        if (ticking) return;
        ticking = true;
        requestAnimationFrame(() => {
          const show = window.scrollY > threshold();
          btn.classList.toggle('show', show);
          ticking = false;
        });
      };

      window.addEventListener('scroll', onScroll, { passive: true });
      window.addEventListener('resize', onScroll);

      btn.addEventListener('click', (e) => {
        e.preventDefault();
        try {
          window.scrollTo({ top: 0, behavior: prefersReduced ? 'auto' : 'smooth' });
        } catch {
          document.documentElement.scrollTop = 0;
          document.body.scrollTop = 0;
        }
      });

      onScroll();
    })();
  </script>
  <!-- PARTNER BADGE & IMAGE FALLBACK (insert above </body>) -->
  <script>
  (function () {
    const qs = new URLSearchParams(location.search);
    const pid = Number(qs.get("propertyId"));
    const start = qs.get("start") || "";
    const end = qs.get("end") || "";
    if (!Number.isFinite(pid) || !start || !end) return;
    // If the main loader already rendered images, skip this fallback.
    const __thumbs = document.getElementById("thumbs");
    const __heroImg = document.getElementById("hero-img");
    if (__thumbs && __thumbs.children.length > 0 && __heroImg && __heroImg.src) return;

    const placeholder = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1200 800'><defs><linearGradient id='g' x1='0' y1='0' x2='1' y2='1'><stop offset='0%' stop-color='%23e5e7eb'/><stop offset='100%' stop-color='%23c7d2fe'/></linearGradient></defs><rect width='1200' height='800' fill='url(%23g)'/><g fill='%239ca3af' font-family='system-ui,Segoe UI,Roboto,Helvetica,Arial' text-anchor='middle'><text x='600' y='420' font-size='56'>No photo</text><text x='600' y='470' font-size='28'>Partner provides images in Extranet</text></g></svg>";

    fetch(`/catalog/details?propertyId=${pid}&start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}`)
      .then(r => r.ok ? r.json() : {})
      .then(d => {
        // 1) Hero image fallback (if your page has an <img> for cover)
        const hero = document.getElementById("hero-img");
        const first = Array.isArray(d?.images) && d.images.length ? d.images[0] : null;
        if (hero) {
          hero.src = first || placeholder;
          hero.alt = d?.name || "Property";
        } else if (first) {
          // If no hero container exists, inject a simple one up top
          const img = document.createElement("img");
          img.src = first; img.alt = d?.name || "Property";
          img.style.cssText = "width:100%;max-height:360px;object-fit:cover;border-radius:12px;margin:8px 0";
          document.body.insertBefore(img, document.body.firstChild);
        }
      })
      .catch(()=>{});
  })();
  </script>
</body>
</html>

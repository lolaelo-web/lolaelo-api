<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lolaelo · Stay</title>
  <link rel="icon" href="/images/logo2.png" />
  <!-- ANCHOR: FONTS_PRECONNECT -->
  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/css/extranet.css?cb=font-unify-v1" />
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/flatpickr@4.6.13/dist/flatpickr.min.css"
  />

  <style>
    /* === ANCHOR: DETAILS_LIGHT_SKIN ======================================= */
    :root{
      --bg:#ffffff;
      --fg:#111827;
      --muted:#6b7280;
      --line:#e5e7eb;
      --brand:#064e3b;          /* deep teal, matches index/catalog */
      --bubble:#ff6a3d;         /* orange accent for CTAs */
      --paper:#ffffff;
      --radius:20px;
      --shadow:0 12px 40px rgba(15,23,42,.10);
      --maxw:900px;             /* slightly tighter than catalog */
      /* ANCHOR: TYPO_BASE_VAR */ --body:15px;   /* ~80% of 15px */
    }

    *{ box-sizing:border-box; }
    /* ANCHOR: FONT_STACK_UNIFY */
    html, body,
    h1, h2, h3, h4, h5, h6,
    p, li, a, span, strong, em,
    table, thead, tbody, tfoot, tr, th, td, caption,
    input, button, select, textarea, label, small, code, pre {
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }

    /* ANCHOR: PAGE_SCROLL_FIX */
    html,body{
      min-height:100%;
      margin:0;
      width:100%;
      max-width:100%;
      overflow-x:hidden;   /* prevent horizontal scroll / right jump */
    }

    body{
      font: var(--body)/1.5 Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color:var(--fg);
      background:#f3f4f6; /* same neutral backdrop as catalog.html */
      display:flex;
      flex-direction:column;
      align-items:center;
    }

    /* ANCHOR: DETAILS_TYPE_SCALE */
    html { font-size: 16px; }  /* baseline */
    body {
      font-size: 15px;
      line-height: 1.5;
      overflow-x: hidden; /* prevent horizontal scroll / right-jump */
    }

    h1 { font-size: clamp(30px, 4.8vw, 44px); line-height: 1.15; margin: 6px 0 10px; font-weight: 600; }
    h2 { font-size: clamp(18px, 2.4vw, 22px); line-height: 1.2; margin: 10px 0 8px; font-weight: 600; }

    .small { font-size: 13px; color: var(--muted); }

    /* ANCHOR: A11Y_VISUALLY_HIDDEN */
    .visually-hidden{
      position:absolute !important;
      width:1px !important;
      height:1px !important;
      padding:0 !important;
      margin:-1px !important;
      overflow:hidden !important;
      clip:rect(0,0,0,0) !important;
      white-space:nowrap !important;
      border:0 !important;
    }

    /* ANCHOR: TYPO_REGULAR_ELEMS */
    p, li, td, th, input, select, button, .meta, .note { font-size: var(--body); }

    /* ANCHOR: DETAILS_PAPER_CLIP */
    .paper{
          width: 100%;
          max-width: var(--maxw);
          margin: 24px 20px;
          background: var(--paper);
          border-radius: var(--radius);
          box-shadow: var(--shadow);
          padding: 22px 22px 28px;
          overflow: hidden;
        }

    /* ANCHOR: TOAST_CSS */
    .toast{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      background: #111;
      color: #fff;
      font-size: 12px;
      padding: 10px 14px;
      border-radius: 999px;
      box-shadow: 0 10px 24px rgba(0,0,0,.18);
      opacity: 0;
      pointer-events: none;
      transition: opacity .15s ease, transform .15s ease;
      z-index: 1000;
    }
    .toast.show{
      opacity: 0.95;
      transform: translateX(-50%) translateY(-2px);
    }

    .hero-block{
      margin-top: 6px;
      margin-bottom: 18px;
    }

    /* === DETAILS: FULL-PAGE LOADING OVERLAY (LOGO ONLY) === */
    .details-loading{
      position: fixed;
      inset: 0;
      background: #f3f4f6;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 5000;
    }

    .details-loading.is-on{
      display: flex;
    }

    /* Centered logo pulse only */
    .details-loading-pulse-only{
      display:flex;
      align-items:center;
      justify-content:center;
      position: relative;
    }

    /* ANCHOR: DETAILS_LOADING_LOGO_SIZE */
    .details-loading-logo{
      width: 132px;  /* 1.5x from 88px */
      height: 132px; /* 1.5x from 88px */
      object-fit: contain;
      animation: lolaeloPulse 1.15s ease-in-out infinite;
      filter: drop-shadow(0 10px 26px rgba(15,23,42,.12));
      opacity: 0.95;
    }

    /* Soft expanding ring */
    .details-loading-pulse-only::after{
      content:"";
      position:absolute;
      width: 198px;  /* 1.5x from 132px */
      height: 198px; /* 1.5x from 132px */
      border-radius: 999px;
      border: 2px solid rgba(6,78,59,0.18);
      animation: lolaeloRing 1.15s ease-in-out infinite;
    }
    /* Animations */
    @keyframes lolaeloPulse{
      0%   { transform: scale(0.96); opacity: .75; }
      50%  { transform: scale(1.06); opacity: 1; }
      100% { transform: scale(0.96); opacity: .75; }
    }

    @keyframes lolaeloRing{
      0%   { transform: scale(0.82); opacity: 0; }
      40%  { opacity: .35; }
      100% { transform: scale(1.25); opacity: 0; }
    }

    /* Respect reduced motion */
    @media (prefers-reduced-motion: reduce){
      .details-loading-logo,
      .details-loading-pulse-only::after{
        animation: none !important;
      }
    }

    /* ANCHOR: SCROLLTOP_CSS */
    .scrolltop-btn {
      position: fixed;
      bottom: 24px;
      right: 24px;
      background: var(--bubble);
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 44px;
      height: 44px;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      cursor: pointer;
      z-index: 1100;
    }
    .scrolltop-btn.show { display: flex; }

    /* ANCHOR: DETAILS_TOPBAR_CSS */
    .topbar{
      display:grid;
      grid-template-columns: auto 1fr; /* logo | title */
      align-items:center;
      column-gap:12px;
      padding:12px 16px 8px;
      border-bottom:1px solid var(--line);
    }

    .topbar .logo{
      display:inline-flex;
      align-items:center;
    }
    .topbar .logo img{
      height: 48px;
      width:auto;
      display:block;
    }

    /* Title block stays on the RIGHT because it fills the 2nd column and aligns itself */
    .topbar .title{
      margin:0;
      display:flex;
      flex-direction:column;
      align-items:flex-end;
      text-align:right;
      gap:2px;
    }

    /* Row that contains hotel name + badge */
    .topbar .title > span{
      display:flex;
      align-items:baseline;
      justify-content:flex-end;
      gap:10px;
    }

    .title{
      font-size:14px;
      line-height:1.3;
      font-weight:600;
      color:var(--fg);
    }

    /* Hotel name styling */
    #prop-name{
      font-size:22px;
      line-height:1.15;
      font-weight:700;
      letter-spacing:-0.02em;
      color: var(--brand);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width:min(560px, 58vw);
    }

    @media (max-width: 640px){
      #prop-name{
        font-size:16px;
        line-height:1.1;
        font-weight:700;
        letter-spacing:-0.01em;
        color: var(--brand);
        max-width: 62vw;
      }

      .topbar{
        padding: 10px 14px 8px;
      }
    }

    .stay-range{
      font-size:12px;
      color:var(--muted);
      margin-top:2px;
    }

    /* ANCHOR: DETAILS_DATE_BAR_CSS */
    .detail-date-bar{
      display:flex;
      align-items:flex-end; /* default for non-card usages */
      gap:8px;
      margin-top:2px;
      font-size:12px;
      width:100%;
      max-width:100%;
      box-sizing:border-box;
    }

    /* Desktop: in the summary date card, stack button under the date pill */
    .summary-dates .detail-date-bar{
      flex-direction:column;
      align-items:stretch;
    }

    .summary-dates #detail-dates-apply{
      width:100%;
      justify-content:center;
    }

    .detail-date-bar .detail-date-field{
      flex:1 1 auto;
      display:flex;
      flex-direction:column;
      gap:4px;
    }

    .detail-date-label{
      font-size:11px;
      color:var(--muted);
    }

    /* Combined dates pill (landing / catalog style) */
    .detail-dates-shell{
      display:flex;
      align-items:center;
      gap:8px;
      border-radius:12px;
      border:1px solid var(--line);       /* match outer card outline */
      background:var(--surface-subtle);
      padding:6px 10px;
    }

    .detail-dates-shell .icon{
      font-size:14px;
    }

    .details-dates-display{
      border:none;
      background:transparent;
      padding:0;
      margin:0;
      flex:1;
      text-align:left;
      font:inherit;
      font-size:13px;
      color:var(--fg);
      cursor:pointer;
    }

    .details-dates-display-label{
      opacity:0.7;
    }

    .detail-dates-combined.has-dates .details-dates-display-label{
      opacity:1;
      font-weight:500;
    }

    /* Invisible Flatpickr driver */
    .details-dates-driver{
      position:absolute;
      width:1px;
      height:1px;
      opacity:0;
      pointer-events:none;
    }

    /* Hide native date inputs – keep for JS and accessibility */
    #detail-checkin,
    #detail-checkout{
      position:absolute;
      left:0;
      top:0;
      width:1px;
      height:1px;
      opacity:0;
      pointer-events:none;
      overflow:hidden;
    }

    /* Style ONLY the "Update dates" button */
    #detail-dates-apply{
      display:inline-flex;              /* makes vertical centering reliable */
      align-items:center;
      justify-content:center;
      padding:6px 12px;
      border-radius:999px;
      border:1px solid var(--bubble);
      background:#ffffff;
      font-size:12px;
      font-weight:500;
      cursor:pointer;
      white-space:nowrap;
      max-width: 100%;
      box-sizing: border-box;
      padding: 6px 10px;
    }

    @media (max-width: 640px){
      /* Mobile: allow the dates row to wrap so the button never gets clipped */
      .detail-date-bar{
        flex-wrap: wrap;
        align-items: stretch;
      }

      .detail-date-bar .detail-date-field{
        flex: 1 1 100%;
        min-width: 0;
      }

      /* Put the button on its own line, full width */
      #detail-dates-apply{
        flex: 1 1 100%;
        width: 100%;
        text-align: center;
        justify-content: center;
      }
    }

    /* ANCHOR: DETAILS_LAYOUT_COLS */
    .layout{
      display:grid;
      grid-template-columns: 1fr;
      gap:16px;
      align-items:start;
    }

    /* Keep two columns; collapse only below ~840px */
    @media (max-width:840px){
      .layout{ grid-template-columns: 1fr; }
    }

    /* ANCHOR: ROOMCAT_LIST_CSS */
    .roomcats { display: grid; gap: 10px; margin: 12px 0; }
    .roomcat {
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 12px;
      display: grid;
      grid-template-columns: 30px 100px 1fr auto;
      gap: 14px;
      align-items: center;
      background: #ffffff;
      box-shadow: 0 4px 12px rgba(15,23,42,0.05); /* subtle like catalog */
    }
    .roomcat h3 {
      margin: 0 0 2px 0;
      font-size: 14px;
      font-weight: 600;
    }
    .roomcat .meta {
      font-size: 13px;
      color: var(--muted);
    }
    .roomcat img {
      width: 100px;
      height: 72px;
      object-fit: cover;
      border-radius: 14px;
      background: #f3f4f6;
      display: block;
    }
    .roomcat .btn-select {
      background: var(--bubble);
      border: none;
      color: #fff;
      padding: 10px 14px;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      text-decoration: none;
      box-shadow: 0 2px 4px rgba(15,23,42,0.10);
    }

    .roomcat-plan-btn{
      height: 36px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      margin-top: 6px;
      padding: 7px 18px;
      border-radius: 999px;
      border: 1px solid #14b8a6; /* teal outline */
      background:
        linear-gradient(135deg,
          rgba(34,211,238,0.06),
          rgba(16,185,129,0.12));
      color: #0f766e;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      text-decoration: none;
      box-shadow:
        0 0 0 1px rgba(20,184,166,0.20),
        0 4px 12px rgba(15,23,42,0.08);
    }

    .roomcat-plan-btn:hover{
      box-shadow:
        0 0 0 1px rgba(20,184,166,0.35),
        0 6px 16px rgba(15,23,42,0.12);
      transform: translateY(-0.5px);
    }

    .roomcat-plan-btn:active{
      transform: translateY(1px);
    }

    @media (max-width: 840px){
      .roomcat{ grid-template-columns: 30px 72px 1fr; } /* + | thumb | text */
      .roomcat .btn-select{ grid-column: 1 / -1; justify-self: start; }
    }

    /* Mobile: simplify room row + plan rows so nothing gets squeezed */
    @media (max-width: 640px){
      .roomcat{
        grid-template-columns: 30px 1fr;
        gap: 10px;
        align-items: start;
      }

      .roomcat img{
        grid-column: 1 / -1;
        width: 100%;
        height: 180px;
        border-radius: 14px;
      }

      .roomcat .btn-select,
      .roomcat-plan-btn{
        width: 100%;
        justify-content: center;
      }

      .planrow{
        grid-template-columns: 1fr;
        gap: 8px;
      }

      .planrow .plan-actions{
        width: 100%;
        justify-content: flex-start;
      }

      .planrow .qty-inline{
        flex-wrap: wrap;
        justify-content: flex-start;
      }
        /* Mobile: let room text use full width (avoid narrow left column feel) */
      .roomcat h3,
      .roomcat .meta{
        grid-column: 1 / -1;
      }

      /* Keep toggle in top-left but prevent it from stealing horizontal space */
      .roomcat .toggle{
        grid-column: 1;
        grid-row: 1;
      }
        /* Make the room text container span full width */
      .roomcat > div{
        grid-column: 1 / -1;
      }
    }

    /* ANCHOR: ROOM_MODAL_CSS */
    .room-modal-backdrop{
      position: fixed;
      inset: 0;
      background: rgba(15,23,42,0.45);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 1200;
    }
    .room-modal-backdrop.is-open{
      display: flex;
    }

    .room-modal{
      position: relative;
      background: #fff;
      border-radius: 20px;
      /* wider, almost full-screen but with a small side margin */
      width: min(95vw, 1100px);
      max-height: 92vh;
      box-shadow: 0 24px 60px rgba(15,23,42,0.40);
      overflow: hidden;             /* keep rounded corners */
      display: flex;
      flex-direction: column;
    }

    .room-modal-close {
        position: absolute;
        top: 44px;
        right: 48px !important;

        /* Make the background match the date-card outline style */
        background: #FFFFFF;
        border: 1px solid #E5E7EB;

        /* Proper sizing for text instead of the tiny X-circle */
        padding: 6px 14px; 
        border-radius: 10px;

        font-size: 14px;
        color: #0F1C2E;

        cursor: pointer;
        z-index: 50;

        display: flex;
        align-items: center;
        justify-content: center;

        box-shadow: 0 4px 12px rgba(0,0,0,0.10);
        transition: background 0.15s ease;
    }

    .room-modal-close:hover {
        background: #F3F4F6; /* subtle gray hover */
    }

    .room-modal-body{
      /* column layout with scroll safety */
      display: flex;
      flex-direction: column;

      gap: 12px;
      padding: 18px 18px 36px;

      /* scroll container */
      flex: 1;
      overflow-y: auto;
      min-height: 0;
    }

    /* ANCHOR: ROOM_MODAL_PADDING_AND_COLUMNS */
    .room-modal-two-cols{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
      padding: 0 24px;          /* restores left/right indent */
      box-sizing: border-box;
    }

    @media (max-width: 820px){
      .room-modal-two-cols{
        grid-template-columns: 1fr;
        padding: 0 16px;
      }
    }

    /* ANCHOR: ROOM_MODAL_HERO_CAP */
    .room-modal-hero{
      max-height: 260px;        /* cap hero height */
      flex-shrink: 0;           /* never collapse */
      overflow: hidden;
      border-radius: 12px;
    }

    .room-modal-hero img{
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .room-modal-top{
      padding: 18px 26px 8px;
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:stretch; /* key: allow children to use full width */
    }
    /* Keep description/specs full width inside the modal */
    #roomModalSummary,
    #roomModalSpecs{
      width: 100%;
    }

    .room-modal-top h2{
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }

    .room-modal-hero{
      display: grid;
      grid-template-rows: minmax(180px, 1fr) auto;
      gap: 8px;
    }
    .room-modal-hero-main{
      position: relative;
      border-radius: 14px;
      overflow: hidden;
      border: 1px solid var(--line);
      background: #000; /* darker so letterboxing looks intentional */
      cursor: zoom-in;
    }
    .room-modal-hero-main img{
      width: 100%;
      height: 100%;
      object-fit: cover;   /* default = cropped, strong visual */
      display: block;
      transition: object-fit 0.2s ease;
    }
    .room-modal-hero-main:hover img{
      object-fit: contain; /* on hover = show full image, “fit to screen” inside hero */
    }

    .room-modal-thumbs{
      display: flex;
      gap: 8px;
      overflow-x: auto;
      padding-bottom: 2px;
      flex-shrink: 0; /* keep thumbs from collapsing in flex column */
    }
    .room-modal-thumbs button{
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 0;
      margin: 0;
      background: #fff;
      cursor: pointer;
      flex: 0 0 auto;
    }
    .room-modal-thumbs img{
      display: block;
      width: 96px;
      height: 64px;
      object-fit: cover;
      border-radius: 10px;
    }
    .room-modal-thumbs button[aria-current="true"]{
      border-color: var(--bubble);
      box-shadow: 0 0 0 2px rgba(255,106,61,0.25) inset;
    }

    /* ANCHOR: ROOM_MODAL_DESC_CLAMP */
    #roomModalSummary{
      /* default (expanded) behavior */
      white-space: normal;
      overflow-wrap: anywhere;
    }

    /* clamped preview (4 lines) */
    #roomModalSummary.is-clamped{
      display: -webkit-box;
      -webkit-box-orient: vertical;
      -webkit-line-clamp: 4;

      /* add standard property to silence the compatibility warning */
      line-clamp: 4;

      overflow: hidden;
    }

    /* when expanded, undo the clamp */
    .room-modal-info.is-expanded #roomModalSummary{
      display: block;
      overflow: visible;
    }

    .room-modal-readmore{
      align-self: flex-start;
      border: 1px solid var(--line);
      background: #fff;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      cursor: pointer;
    }

    .room-modal-readmore[hidden]{
      display: none !important;
    }

    .room-modal-info{
      margin-top: 12px;
      padding: 0 24px;
      display: grid;
      grid-template-columns: minmax(0, 1.2fr) minmax(0, 1fr);
      column-gap: 40px;
      row-gap: 8px;
      align-items: flex-start;
    }

    .room-modal-info > #roomModalSummary,
    .room-modal-info > #roomModalSpecs{
      grid-column: 1 / -1;   /* summary + size span both columns */
    }

    #roomModalDetailsSection{
      grid-column: 1;        /* Room details on the left */
    }

    #roomModalInclusionsSection{
      grid-column: 2;        /* Property Facilities & Inclusions on the right */
    }

    /* ANCHOR: ROOM_MODAL_PLANS_CSS */
    .room-modal-plans{
      border-top: 1px solid #f3f4f6;
      padding: 10px 40px 0;   /* match room-modal-info horizontal padding */
      margin-top: 8px;
      margin-bottom: 24px;
    }

    .room-modal-subtitle{
      margin: 0 0 4px 0;
      font-size: 14px;
      font-weight: 600;
    }

    /* Inner container that actually holds the pills */
    #roomModalPlans{
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: stretch;
      justify-content: center;  /* center the three bubbles */
    }

    /* Horizontal plan pills */
    .room-modal-plan-pill{
      flex: 1 1 0;
      min-width: 225px;    /* widened */
      max-width: 325px;    /* widened */
      padding: 14px 16px;  /* slightly more padding since wider */
      border-radius: 14px;
      border: 1px dashed var(--line);
      background: #fafafa;
      display: flex;
      flex-direction: column;
      align-items: center;     /* center content */
      justify-content: space-between; /* << THE FIX: aligns all Select buttons */
      text-align: center;
      gap: 6px;
    }

    .room-modal-plan-pill-title{
      font-size: 15px;
      font-weight: 600;
      text-align: center;
    }

    .room-modal-plan-pill-desc{
      font-size: 13px;
      color: var(--muted);
      text-align: center;
    }

    .room-modal-plan-pill-price{
      margin-top: 4px;
      font-size: 14px;
      font-weight: 600;
      text-align: center;
    }

    /* Modal: split Available + Qty into two pills (match inline behavior) */
    .room-modal-plan-pill .qty-inline{
      display:flex;
      align-items:center;
      gap:10px;
      white-space:nowrap;

      /* IMPORTANT: prevent the global .qty-inline container styling
        from turning this into one big combined box */
      border: none !important;
      background: transparent !important;
      padding: 0 !important;
      border-radius: 0 !important;
      box-shadow: none !important;
    }

    .room-modal-plan-pill .qty-avail,
    .room-modal-plan-pill .qty-pick{
      height: 34px;
      display:flex;
      align-items:center;
      padding: 0 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background:#fff;
    }

    .room-modal-plan-pill .qty-avail{
      font-size:12px;
      color:var(--muted);
    }

    .room-modal-plan-pill .qty-avail-val{
      font-weight:600;
      color:var(--fg);
    }

    .room-modal-plan-pill .qty-label{
      font-size:12px;
      color:var(--muted);
      margin-right:6px;
    }

    .room-modal-plan-pill .qty-select{
      height: 30px;
      padding: 0 8px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background:#fff;
      color:var(--fg);
      font-weight:600;
    }

    /* Standardize “Book now” height to match pills */
    .room-modal-plan-pill-btn{
      height: 34px;
      padding: 0 20px;              /* overrides old padding */
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .room-modal-plan-pill-btn.is-disabled{
      opacity: .45;
      pointer-events: none;
    }

    /* Teal outline “Book now” button inside plan pills */
    .room-modal-plan-pill-btn{
      margin-top: 6px;
      padding: 7px 20px;
      border-radius: 999px;
      border: 1px solid #14b8a6; /* teal outline */
      background: linear-gradient(
        135deg,
        #ffffff 0%,      /* pure white start */
        #f4fffc 55%,     /* very light aqua */
        #eafff7 100%     /* subtle tint, no bleed */
      );
      color: #0f766e; /* teal text */
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      box-shadow:
        0 0 0 1px rgba(20,184,166,0.25),
        0 6px 16px rgba(15,23,42,0.08);
      transition:
        transform 0.08s ease,
        box-shadow 0.08s ease,
        opacity 0.08s ease;
    }

    .room-modal-plan-pill-btn:hover{
      box-shadow:
        0 0 0 1px rgba(20,184,166,0.35),
        0 8px 20px rgba(15,23,42,0.14);
      transform: translateY(-0.5px);
      opacity: 0.98;
    }

    .room-modal-plan-pill-btn:active{
      transform: translateY(1px);
      box-shadow:
        0 0 0 1px rgba(20,184,166,0.35),
        0 4px 10px rgba(15,23,42,0.18);
      opacity: 0.92;
    }

    /* Slightly larger body text inside the modal only */
    .room-modal-body .small,
    .room-modal-body .muted,
    .room-modal-body li{
      font-size: 14px;
    }

    @media (max-width: 640px){
      .room-modal-body{
        padding: 14px 14px 16px;
        /* top | hero | info | plans */
        grid-template-rows: auto minmax(150px, 2fr) auto minmax(200px, 3fr);
      }
    }

    /* ANCHOR: ROOM_MODAL_LIGHTBOX_CSS */
    .room-modal-lightbox {
      position: absolute;
      inset: 0;
      display: none;               /* hidden until opened */
      align-items: center;
      justify-content: center;
      z-index: 999;                /* above modal body, below global modals */
    }

    .room-modal-lightbox.is-open {
      display: flex;
    }

    .room-modal-lightbox-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.55);   /* darken inside modal only */
      backdrop-filter: blur(2px);
    }

    .room-modal-lightbox-inner {
      position: relative;
      z-index: 1000;
      max-width: 92%;
      max-height: 92%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .room-modal-lightbox-img {
      max-width: 100%;
      max-height: 100%;
      border-radius: 14px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.35);
      object-fit: contain;
      background: #000;
    }

    .room-modal-lightbox-close {
      position: absolute;
      top: 12px;
      right: 16px;
      border-radius: 999px;
      padding: 4px 14px;
      border: 1px solid rgba(148,163,184,0.55);
      background: linear-gradient(135deg, #ffffff, #f3f4f6);
      color: #111827;
      font-size: 12px;
      font-weight: 500;
      line-height: 1.2;
      cursor: pointer;
      z-index: 1100;
      box-shadow: 0 2px 8px rgba(15,23,42,0.25);
    }

    .room-modal-lightbox-prev,
    .room-modal-lightbox-next {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      font-size: 38px;
      border: none;
      background: none;
      color: #ffffff;
      cursor: pointer;
      z-index: 1100;
      padding: 8px 12px;
      user-select: none;
    }

    .room-modal-lightbox-prev { left: -46px; }
    .room-modal-lightbox-next { right: -46px; }

    /* On small screens, bring arrows inside */
    @media (max-width: 640px) {
      .room-modal-lightbox-prev { left: 6px; }
      .room-modal-lightbox-next { right: 6px; }
    }

    /* ANCHOR: ROOM_MODAL_HERO_CAP */
    .room-modal .room-modal-hero,
    .room-modal .room-modal-hero img {
      max-height: 240px; /* matches pre-flex visual height */
    }

    .room-modal .room-modal-hero {
      overflow: hidden;
      border-radius: 12px;
    }

    .room-modal .room-modal-hero img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    /* === ROOM DESCRIPTION (READ MORE) === */
    .room-desc{
      margin-top: 6px;
    }

    /* clamp lives on the TEXT node */
    .room-desc-text{
      line-height: 1.45;
      font-size: 13px;
      color: var(--muted);
    }

    .room-desc-text.is-expanded{
      -webkit-line-clamp: unset;
      line-clamp: unset;
      overflow: visible;
    }

    /* Button styling reused by the room modal */
    .room-desc-toggle{
      margin-top: 6px;
      font-size: 12px;
      font-weight: 600;
      color: var(--accent);
      background: none;
      border: none;
      padding: 0;
      cursor: pointer;
    }

    /* === ROOM DESCRIPTION FULL-WIDTH, ALIGNED WITH CONTENT GUTTERS === */
    .room-desc-block{
      grid-column: 1 / -1;   /* span full width of the modal grid */
      padding-left: 0;
      padding-right: 0;
      width: 100%;
    }

    @media (max-width: 768px){
      .room-desc-block{
        padding-left: 20px;
        padding-right: 20px;
      }
    }

    /* ANCHOR: ROOMCAT_PLANS_CSS */
    .qty-inline{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-top:8px;
      padding:8px 10px;
      border:1px solid rgba(0,0,0,0.08);
      border-radius:12px;
      background:#fff;
    }
    .qty-avail{
      font-size:13px;
      color:#0f172a;
    }
    .qty-label{
      font-size:12px;
      color:var(--muted);
    }

    .qty-avail,
    .qty-pick{
      height: 34px;                 /* standard height */
      display:flex;
      align-items:center;
      padding: 0 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background:#fff;
      white-space: nowrap;
    }

    .qty-select{
      height: 34px;                 /* standard height */
      padding: 0 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background:#fff;
      color:var(--fg);
      font-weight:600;
    }

    /* Standardize Book now height to match */
    .roomcat-plan-btn{
      height: 34px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding: 0 14px;              /* overrides old padding */
    }
    .roomcat-plan-btn.is-disabled{
      opacity: .45;
      pointer-events: none;
    }

    .roomcat .toggle {
      appearance: none;
      border: 1px solid var(--line);
      background: #fff;
      border-radius: 8px;
      width: 30px; height: 30px;
      display: inline-flex; align-items: center; justify-content: center;
      cursor: pointer; font-weight: 700;
    }
    .roomcat .toggle[aria-expanded="true"] { background: #fff0ea; border-color: #ffd3c2; color: #c2410c; }

    /* Smooth expand/collapse for sub-rows */
    .planlist{
      grid-column: 1 / -1;
      margin-top: 8px;

      /* animation */
      max-height: 0;
      overflow: hidden;
      opacity: 0;
      visibility: hidden;
      transition:
        max-height .28s ease,
        opacity .20s ease,
        visibility 0s linear .28s; /* hide after collapse */
    }
    .planlist.open{
      /* allow animation without display:none */
      max-height: 800px; /* large enough for several rows */
      opacity: 1;
      visibility: visible;
      transition:
        max-height .32s ease,
        opacity .20s ease,
        visibility 0s; /* show immediately */
    }

    /* Respect reduced-motion */
    @media (prefers-reduced-motion: reduce){
      .planlist, .planlist.open{
        transition: none !important;
      }
    }

    .planrow{
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border: 1px dashed var(--line);
      border-radius: 10px;
      background: #fafafa;
      margin-bottom: 8px;
    }
    .planrow .plan-actions{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap:10px;
    }

    @media (max-width: 520px){
      .planrow .plan-actions{
        flex-direction:column;
        align-items:flex-end;
        gap:8px;
      }
    .planrow .qty-inline{
        justify-content:flex-end;
      }
    }
    .planrow .qty-inline{
      display:flex;
      align-items:center;
      gap:10px;
      white-space:nowrap;

      /* force container to NOT look like a pill */
      border: none !important;
      background: transparent !important;
      padding: 0 !important;
      border-radius: 0 !important;
      box-shadow: none !important;
    }

    .planrow .qty-avail-pill,
    .planrow .qty-pick-pill{
      display:inline-flex;
      align-items:center;
      gap:6px;

      height: 36px;                 /* STANDARD HEIGHT */
      padding: 0 12px;              /* vertical handled by height */
      border-radius: 9999px;
      border: 1px solid var(--border);
      background:#fff;
      font-size:12px;
      flex: 0 0 auto;
    }

    .planrow .qty-avail-pill{
      color:var(--muted);
    }

    .planrow .qty-avail-val{
      font-weight:600;
      color:var(--fg);
    }

    .planrow .qty-label{
      font-size:12px;
      color:var(--muted);
    }

    .planrow .qty-select{
      height: 30px;                 /* fits inside 36px pill */
      padding: 0 8px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background:#fff;
      color:var(--fg);
      font-weight:600;
    }

    .planrow .planname{
      font-weight: 600;
      font-size: 14px;
    }
    .planrow .meta{
      font-size: 12px;
      color: var(--muted);
    }
    .planrow .btn-select {
      border: 1px solid var(--bubble); background: var(--bubble); color: #fff;
      padding: 6px 10px; border-radius: 10px; font-weight: 700; cursor: pointer;
      text-decoration: none; display: inline-block;
    }

    @media (min-width:900px){
      .panel{
        position: sticky;
        top: 12px;
        align-self: start;
      }
    }

    /* qty validation error */
    .qty-select.is-error{
      border-color:#ef4444 !important;
      box-shadow: 0 0 0 3px rgba(239,68,68,.18) !important;
    }

    /* error highlight ONLY on the pill */
    .qty-pick-pill.is-error{
      border-color:#ef4444 !important;
      box-shadow: 0 0 0 3px rgba(239,68,68,.18) !important;
    }

    /* prevent the inner select from also looking "outlined" */
    .qty-pick-pill.is-error .qty-select{
      border-color: transparent !important;
      box-shadow: none !important;
      outline: none !important;
    }

    .muted{
      color: var(--muted);
      font-size: 13px;
    }
    /* ANCHOR: DETAILS_PRICE_SIZE */

    .price{
      font-weight: 600;
      font-size: 24px;
      letter-spacing: .1px;
    }
    @media (min-width:1200px){
      .price{ font-size:26px; }
    }

    .book{ border:1px solid var(--bubble); background:var(--bubble); color:#fff; font-weight:700;
      border-radius:12px; padding:14px; width:100%; cursor:pointer; }

    /* Chips (optional, if amenities chips are shown elsewhere) */
    .chips{ display:flex; gap:6px; flex-wrap:wrap; margin:10px 0; }
    .chip{ font-size:11px; padding:4px 8px; border:1px solid var(--line); border-radius:999px; background:#fafafa; color:#444; }

    /* Make Amenities chips match the darker Description text color */
    .summary-bubble .summary-chip{
      color: #0F1C2E !important;   /* dark navy */
    }

    /* ANCHOR: DETAILS_TAGS */
    .tag{
      padding:4px 8px;
      border-radius:999px;
      font-size:12px;
      display:inline-block;
      border:1px solid transparent;
      font-weight:600;
    }
    .tag{ background:#dcfce7; color:#166534; border-color:#86efac; }
    .tag.off{ background:#fee2e2; color:#991b1b; border-color:#fca5a5; }

    /* ANCHOR: NUMERIC_UNIFY */
    .price,
    #from,
    .meta,
    .chip {
      font-variant-numeric: tabular-nums lining-nums;
    }

    /* ANCHOR: DETAILS_GALLERY_CSS */
    .hero{
      position: relative;
      border-radius: 18px;
      overflow: hidden;
      background:#f3f4f6;
      aspect-ratio: 16 / 9;
      width: 100%;
      min-height: 260px;
      max-height: 70vh;
      box-shadow: 0 16px 38px rgba(15,23,42,0.18);
    }
    .hero img{
      width:100%;
      height:100%;
      object-fit:cover;
      object-position:center;
      display:block;
      opacity: 1;
      transition: opacity .25s ease;
      background:#e5e7eb;
    }

    /* ANCHOR: GALLERY_NODRAG_CSS */
    .hero img, .thumbs img{ user-select: none; -webkit-user-drag: none; }

    /* Shimmer overlay while loading (you already have @keyframes shimmer) */
    .hero.is-loading::after{
      content:"";
      position:absolute;
      inset:0;
      background-image: linear-gradient(
        90deg,
        rgba(0,0,0,0.02) 0%,
        rgba(0,0,0,0.06) 20%,
        rgba(0,0,0,0.02) 40%
      );
      background-size: 400px 100%;
      animation: shimmer 1.1s infinite linear;
      pointer-events:none;
    }
    /* Hide arrows until hero is ready (prevents awkward pop-in) */
    .hero-nav{
      opacity: 0;
      pointer-events: none;
      transition: opacity .15s ease;
    }

    /* ANCHOR: HERO_NAV_CSS */
    .hero.is-ready .hero-nav{
      opacity: 1;
      pointer-events: auto;
    }
    .hero-nav{
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(255,255,255,0.8);
      border: none;
      border-radius: 50%;
      width: 36px;
      height: 36px;
      font-size: 20px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    #hero-prev { left: 10px; }
    #hero-next { right: 10px; }
    .hero-nav:hover { background: rgba(255,255,255,0.95); }
    .hero-nav[disabled]{ opacity: .45; cursor: default; box-shadow: none; }
    .hero-nav.is-hidden{ display: none; }

    /* fade between images */
    .hero img.is-fading{ opacity: 0; }

    /* ANCHOR: REDUCED_MOTION_CSS */
    @media (prefers-reduced-motion: reduce){
      .hero img{ transition: none !important; }
      .hero-nav{ transition: none !important; }
      .hero.is-loading::after{ animation: none !important; }
    }

    .thumbs{
      display: grid;
      grid-auto-flow: column;
      grid-auto-columns: max-content;
      gap: 10px;
      margin: 12px 0 10px;
      padding: 6px 2px;
      overflow-x: auto;
      scrollbar-gutter: stable;
    }
    .thumbs button{
      appearance: none;
      border: 1px solid #e5e7eb;
      border-radius: 14px;
      background: #ffffff;
      padding: 0;
      margin: 0;
      line-height: 0;
      cursor: pointer;
      box-shadow: none;
      transition: border-color .12s ease, transform .12s ease;
    }
    .thumbs button:hover{
      border-color: #9ca3af;
      transform: translateY(-1px);
    }
    .thumbs img{
      display: block;
      width: 110px;
      height: 72px;
      object-fit: cover;
      background:#f3f4f6;
      border-radius: 14px;
    }
   .thumbs button:hover{ transform: translateY(-1px); box-shadow: 0 10px 22px rgba(0,0,0,.12); }
    .thumbs button:focus-visible{ outline: 2px solid var(--bubble); outline-offset: 2px; }
    .thumbs button[aria-current="true"]{ border-color: var(--bubble); box-shadow: 0 0 0 2px rgba(255,102,51,.25) inset; }

    /* ANCHOR: SKELETON_CSS */
    @keyframes shimmer {
      0% { background-position: -400px 0; }
      100% { background-position: 400px 0; }
    }
    .skeleton-bar{
      height: 12px;
      border-radius: 8px;
      background: #f3f4f6;
      background-image: linear-gradient(90deg, #f3f4f6 0px, #e5e7eb 40px, #f3f4f6 80px);
      background-size: 400px 100%;
      animation: shimmer 1.1s infinite linear;
    }

    /* ANCHOR: DETAILS_CTA_UNIFY */
    .book,
    .roomcat .btn-select,
    .planrow .btn-select{
      border: none;
      background: var(--bubble);
      color: #fff;
      font-weight: 600;
      border-radius: 999px;
      padding: 10px 16px;
      cursor: pointer;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      box-shadow: 0 4px 12px rgba(255,106,61,0.25);
      transition:
        filter .15s ease-out,
        box-shadow .15s ease-out,
        transform .12s ease-out;
    }

    .book:hover,
    .roomcat .btn-select:hover,
    .planrow .btn-select:hover{
      filter: brightness(.96);
      box-shadow: 0 6px 18px rgba(255,106,61,0.35);
      transform: translateY(-1px);
    }

    /* ANCHOR: DETAILS_SUMMARY_CSS */
    .summary{
      margin: 12px 16px 4px;
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: var(--panel);
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 6px 16px;
    }

    .summary-main{
      display: flex;
      flex-direction: column;
      gap: 4px;
      flex: 1 1 auto;
      min-width: 0;
    }

    .summary-price-line{
      display: flex;
      align-items: baseline;
      gap: 6px;
      flex-wrap: wrap;
    }

    .summary-label{
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: .08em;
      color: var(--muted);
    }

    .summary .price{
      font-size: 18px;
      font-weight: 600;
    }

    #nights-note{
      font-size: 12px;
      color: var(--muted);
    }

    .summary-location{
      margin-top: 2px;
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .summary-desc{
      margin-top: 4px;
      font-size: 13px;
      line-height: 1.4;
      color: var(--fg);
      max-height: 4.2em; /* ~3 lines */
      overflow: hidden;
    }

    /* Inside the Description bubble, show the full text instead of clipping */
    .summary-bubble-owner .summary-desc{
      max-height: none;
      overflow: visible;
      white-space: pre-line;  /* respect line breaks from backend text */
      text-align: left;
    }

    /* Match Amenities bubble text color to Description bubble (dark navy) */
    .summary-bubble:not(.summary-bubble-owner){
      color: #0F1C2E !important;
    }

    .summary .chips{
      margin-top: 4px;
      flex-wrap: wrap;
      row-gap: 6px;
    }

    /* ANCHOR: ROOM_DIALOG_LAYOUT */
    /* Wider edit-room dialog */
    .dialog{
      width: min(760px, calc(100vw - 24px));
      max-width: 840px;
    }

    /* Column layout for Room details / Inclusions checkboxes */
    .ri-details-grid,
    .ri-inclusions-grid{
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px 12px;
      margin-bottom: 6px;
    }

    @media (min-width: 1024px){
      .ri-details-grid,
      .ri-inclusions-grid{
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
    }

    /* Make the textareas span full width and be comfortable height */
    #edit-room-summary,
    #edit-room-details,
    #edit-room-inclusions{
      width: 100%;
      resize: vertical;
      min-height: 60px;
    }

    /* ANCHOR: DETAILS_SUMMARY_ICONS_CSS */
    /* Canonical: icons row + date card + bubbles */
    .summary-actions{
      display:grid;
      grid-template-columns: repeat(3, minmax(0, 1fr)) minmax(220px, 1fr);
      column-gap: 14px;
      row-gap: 12px;
      align-items: start;
      width:100%;
      margin-bottom:4px;
    }

    .summary-icon-wrap{
      position:relative;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:flex-start;
      text-align:center;
      min-width:0;
    }

    .summary-icon-btn{
      width:58px;
      height:58px;
      border-radius:999px;
      border:none;
      background:#fff;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:34px;
      cursor:pointer;
    }

    .summary-actions > .summary-icon-wrap:nth-child(2) .summary-icon-btn{
      display:flex;
      flex-direction:row;
      gap:4px;
      justify-content:center;
      align-items:center;
      font-size:32px;
    }

    /* IMPORTANT: remove the desktop “min-width:130px” that causes overlap */
    .summary-actions > .summary-icon-wrap:nth-child(2){
      min-width:0;
    }

    /* Labels */
    .summary-icon-label{
      margin-top:6px;
      font-size:12px;
      font-weight:500;
      color:#0F1C2E;
      text-align:center;
      width:100%;
      white-space:nowrap;
    }

    /* Date card always lives in the 4th column on desktop */
    .summary-dates{
      display:flex;
      flex-direction:column;
      gap:4px;
      padding:8px 10px;
      border-radius:14px;
      border:1px solid var(--line);
      background:#ffffff;
      box-shadow:0 4px 12px rgba(15,23,42,0.05);
      width:100%;
      max-width:100%;
      box-sizing:border-box;
    }

    /* Bubbles */
    .summary-bubble{
      position:absolute;
      top:115%;
      left:0;
      transform:none;
      z-index:30;

      /* wider bubble, but still capped so it never runs off-screen */
      width:fit-content;
      min-width:360px;
      max-width:min(900px, calc(100vw - 48px));

      max-height:70vh;
      overflow-y:auto;

      padding:12px 18px;
      border-radius:14px;

      background:#FFFFFF;
      border:1px solid #E5E7EB;
      color:#0F1C2E;

      box-shadow:0 10px 30px rgba(15,23,42,0.12);
      font-size:13px;
      line-height:1.45;
      display:none;
    }

    /* Desktop: show bubble on hover (mobile uses :active/:focus-within below) */
    @media (hover:hover) and (pointer:fine){
      .summary-icon-wrap:hover .summary-bubble{ display:block; }
    }

    /* ensure the anchor container doesn't constrain bubble math */
    .summary-icon-wrap{ max-width:100%; }
    .summary-bubble.summary-bubble-owner{ text-align:left; }

    .summary-nights{
      font-size:11px;
      color:var(--muted);
    }

    /* ANCHOR: DETAILS_SUMMARY_ICONS_MOBILE */
    @media (max-width: 640px){
      /* Put 3 icons on one row, dates on its own row */
      /* Mobile: allow bubbles to escape container without clipping */
      .summary,
      .summary-main,
      .summary-actions{
        overflow: visible;
      }

      /* Mobile: tap toggle state (JS adds/removes .is-open) */
      .summary-icon-wrap.is-open .summary-bubble{
        display:block !important;
      }

      .summary-actions{
        grid-template-columns: repeat(3, minmax(0, 1fr));
        column-gap: 10px;
        row-gap: 12px;
        justify-items:center;
      }

      .summary-dates{
        grid-column: 1 / -1;
      }

      /* Mobile: icons without circular outlines */
      .summary-icon-btn{
        width:52px;
        height:52px;
        font-size:30px;
        border:none;
        background:transparent;
      }

      .summary-icon-label{
        white-space:normal;
        font-size:12px;
        line-height:1.1;
      }

      /* Mobile: bubble behaves like a viewport panel (tap-friendly, portrait-safe) */
      .summary-bubble{
        position: fixed !important;

        /* keep bubble fully inside viewport */
        top: 140px;              /* below gallery + icons */
        bottom: 16px;
        left: 12px;
        right: 12px;

        width: auto !important;
        max-width: none !important;
        min-width: 0 !important;

        transform: none !important;

        overflow-y: auto;
        -webkit-overflow-scrolling: touch;

        z-index: 9999;
      }
    }

    /* ANCHOR: DETAILS_MAP_MODAL_CSS */
    .details-map-backdrop{
      position:fixed;
      inset:0;
      background:rgba(15,23,42,0.45);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:60;
    }
    .details-map-backdrop.is-open{
      display:flex;
    }
    .details-map-inner{
      width:min(900px,94vw);
      height:min(540px,80vh);
      background:#ffffff;
      border-radius:18px;
      box-shadow:0 20px 60px rgba(15,23,42,0.35);
      position:relative;
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    .details-map-header{
      display:none !important; /* removes the white bar */
    }
    .details-map-close{
      position: absolute;
      z-index: 2000;
      top: 12px;
      right: 12px;
      border:none;
      border-radius:999px;
      padding:4px 10px;
      font-size:12px;
      cursor:pointer;
      background:rgba(15,23,42,0.06);
    }
    .details-map-frame{
      flex:1;
      width:100%;
      border:0;
    }

    /* When the loading overlay is on, hide the page beneath it */
    body.details-loading-on .paper{
      visibility: hidden;
    }

    /* Optional: prevent scroll while loading */
    body.details-loading-on{
      overflow: hidden;
    }

    .summary-map-icon {
      width: 43px;      /* Matches visual size of surrounding icons */
      height: 43px;
      object-fit: contain;
      display: block;
      margin: 0 auto;
    }

    /* ===== MOBILE LANDSCAPE FIXES (room cards + bubbles + inline rateplans) ===== */
    @media (max-width: 900px) and (orientation: landscape) {

      /* --- ROOM CARDS (catalog list rows) --- */
      /* Fix image bleeding into text: your 840px rule uses a 72px image column but img was 100px */
      .roomcat{
        grid-template-columns: 30px 72px 1fr !important;
        align-items: center !important;
      }
      .roomcat img{
        width: 72px !important;
        height: 56px !important;
      }
      .roomcat > div{
        min-width: 0 !important;
      }
      .roomcat h3,
      .roomcat .meta{
        white-space: normal !important;
        overflow-wrap: anywhere !important;
        line-height: 1.25 !important;
      }

      /* --- SUMMARY BUBBLES (Description / Inclusions) --- */
      /* Landscape often exceeds 640px width so the portrait mobile rules don’t apply.
        Force tap-open bubble visible and keep it inside the viewport. */
      .summary-icon-wrap.is-open .summary-bubble{
        display: block !important;
      }
      .summary-bubble{
        position: fixed !important;
        top: 12px !important;
        bottom: 12px !important;
        left: 12px !important;
        right: 12px !important;

        width: auto !important;
        max-width: none !important;
        min-width: 0 !important;
        max-height: none !important;

        transform: none !important;
        overflow-y: auto !important;
        -webkit-overflow-scrolling: touch !important;
        z-index: 9999 !important;
      }

      /* --- INLINE RATEPLAN ROWS (.planrow) --- */
      /* Stack actions under plan text so nothing overlaps in tight landscape viewports */
      .planrow{
        grid-template-columns: 1fr !important;
        gap: 10px !important;
      }
      .planrow .plan-actions{
        justify-content: flex-start !important;
        flex-wrap: wrap !important;
        gap: 10px !important;
      }
      .planrow .qty-inline{
        white-space: normal !important;
        flex-wrap: wrap !important;
        justify-content: flex-start !important;
        gap: 10px !important;
      }
      .planrow .planinfo{
        min-width: 0 !important;
      }
      .planrow .planinfo .meta{
        overflow-wrap: anywhere !important;
      }
    }

  </style>
</head>
<body>
  <!-- ANCHOR: DETAILS_LOADING_OVERLAY -->
  <div id="detailsLoading" class="details-loading" aria-hidden="true">
    <div class="details-loading-pulse-only" role="status" aria-live="polite">
      <img
        src="/images/logo2.png"
        alt="Lolaelo"
        class="details-loading-logo"
        decoding="async"
      />
    </div>
  </div>

  <div class="paper">
    <header>
      <!-- ANCHOR: DETAILS_TOPBAR -->
      <div class="topbar">
        <a class="logo" href="/" aria-label="Lolaelo home">
          <img
            src="/images/logo.png?cb=logo-5x"
            alt="Lolaelo"
            class="logo-img"
            decoding="async"
            loading="eager"
          >
        </a>
        <h1 class="title">
          <span>
            <span id="prop-name">Loading…</span>
            <span id="src-badge" class="chip" style="display:none; margin-left:8px;">db</span>
          </span>
          <div id="stay-range" class="stay-range" style="display:none;"></div>
        </h1>
      </div>
      <!-- /ANCHOR: DETAILS_TOPBAR -->
    </header>

    <!-- ANCHOR: DETAILS_HERO_BLOCK -->
    <section class="hero-block">
      <div id="hero" class="hero" aria-live="polite">
        <img id="hero-img" src="" alt="" width="1600" height="900">
        <button id="hero-prev" class="hero-nav" aria-label="Previous photo">‹</button>
        <button id="hero-next" class="hero-nav" aria-label="Next photo">›</button>
      </div>
      <div id="thumbs" class="thumbs" aria-label="More photos"></div>
    </section>

    <div class="layout">
      <section>
        <!-- ANCHOR: DETAILS_SUMMARY_BLOCK -->
        <div class="summary">
          <div class="summary-main">

            <div class="summary-actions">

              <!-- Owner / manager letter -->
              <div class="summary-icon-wrap">
                <button
                  type="button"
                  class="summary-icon-btn"
                  aria-label="Message from the owner"
                >
                  📝
                </button>
                <div class="summary-icon-label">Description</div>

                <div class="summary-bubble summary-bubble-owner">
                  <strong>Description</strong>
                  <p id="prop-desc" class="summary-desc"></p>
                </div>
              </div>

              <!-- Amenities bubble -->
              <div class="summary-icon-wrap">
                <button
                  type="button"
                  class="summary-icon-btn"
                  aria-label="Amenities"
                >
                  <span>🏝️</span>
                  <span>🍹</span>
                  <span>🏖️</span>
                </button>
                <div class="summary-icon-label">Property Inclusions</div>

                <div class="summary-bubble summary-bubble-amenities">
                  <div id="amenities" class="chips" style="display:none;"></div>
                </div>
              </div>

              <!-- Map icon -->
              <div class="summary-icon-wrap">
                <button
                  type="button"
                  class="summary-icon-btn"
                  aria-label="View on map"
                  id="summary-map-btn"
                >
                  <img
                    src="/images/logo2.png"
                    alt="Map"
                    class="summary-map-icon"
                  />
                </button>
                <div class="summary-icon-label">Map</div>
              </div>

              <!-- Date selector -->
              <div class="summary-dates">
              <!-- ANCHOR: DETAILS_DATE_BAR_HTML -->
              <div id="details-date-bar" class="detail-date-bar">
                <label class="detail-date-field detail-dates-combined">
                  <span class="detail-date-label">Dates</span>
                  <div class="detail-dates-shell">
                    <span class="icon">📅</span>

                    <!-- Visible clickable label (same idea as landing / catalog) -->
                    <button
                      type="button"
                      id="details-dates-display"
                      class="details-dates-display"
                      aria-haspopup="dialog"
                    >
                      <span id="details-dates-display-label" class="details-dates-display-label">
                        Check-in – Check-out
                      </span>
                    </button>

                    <!-- Invisible input that Flatpickr actually binds to -->
                    <input
                      id="details-dates-driver"
                      class="details-dates-driver"
                      type="text"
                      autocomplete="off"
                    />
                  </div>

                  <!-- Hidden actual values used by JS / URLs -->
                  <input type="date" id="detail-checkin">
                  <input type="date" id="detail-checkout">
                </label>

                <button type="button" id="detail-dates-apply">
                  Update dates
                </button>
              </div>
              <div id="nights-note" class="meta summary-nights"></div>
              </div>

            </div> <!-- /.summary-actions -->

            <div id="prop-location" class="summary-location"></div>
          </div> <!-- /.summary-main -->
        </div> <!-- /.summary -->

        <!-- ANCHOR: DETAILS_MAP_MODAL_HTML -->
        <div id="details-map-modal" class="details-map-backdrop" aria-hidden="true">
          <div class="details-map-inner" role="dialog" aria-modal="true" aria-label="Map">
            <div class="details-map-header">
              <div>Map</div>
              <button type="button" id="details-map-close" class="details-map-close" aria-label="Close">Close</button>
            </div>
            <iframe
              id="details-map-frame"
              class="details-map-frame"
              loading="lazy"
              referrerpolicy="no-referrer-when-downgrade"
              allowfullscreen
            ></iframe>
          </div>
        </div>
        <!-- /ANCHOR: DETAILS_MAP_MODAL_HTML -->

        <!-- ANCHOR: ROOMCAT_LIST_HTML -->
        <div id="roomCats" class="roomcats" aria-label="Available room categories (open only)"></div>
      </section>
    </div>

<!-- ANCHOR: ROOM_MODAL_HTML -->
<div id="roomModalBackdrop" class="room-modal-backdrop" aria-hidden="true">
  <div class="room-modal" role="dialog" aria-modal="true" aria-label="Room details">
    <button type="button" class="room-modal-close" aria-label="Close">Close</button>

    <div class="room-modal-body">
      <div class="room-modal-top">
        <h2 id="roomModalTitle">Room</h2>
        <p id="roomModalMeta" class="small muted"></p>
      </div>

      <div class="room-modal-hero">
        <div class="room-modal-hero-main">
          <img
            id="roomModalHeroImg"
            src=""
            alt=""
            loading="lazy"
            decoding="async"
          >
        </div>
        <div
          id="roomModalThumbs"
          class="room-modal-thumbs"
          aria-label="Room photos"
        ></div>
      </div>

      <div class="room-modal-info">
        <div class="room-desc-block">
          <div class="room-desc">
            <div id="roomModalSummary" class="room-desc-text"></div>
            <button
              type="button"
              id="roomModalReadMore"
              class="room-desc-toggle"
              hidden
            >
              Read more
            </button>
          </div>
        </div>

        <div id="roomModalSpecs" class="small muted"></div>
      </div>

      <!-- ANCHOR: ROOM_MODAL_TWO_COLS -->
      <div class="room-modal-two-cols">
        <div class="room-modal-col" id="roomModalColDetails">
          <div class="room-modal-section" id="roomModalDetailsSection" style="display:none;">
            <p class="room-modal-subtitle">Room Details</p>
            <ul id="roomModalDetailsList" class="small"></ul>
          </div>
        </div>

        <div class="room-modal-col" id="roomModalColFacilities">
          <div class="room-modal-section" id="roomModalInclusionsSection" style="display:none;">
            <p class="room-modal-subtitle">Property Facilities & Inclusions</p>
            <ul id="roomModalInclusionsList" class="small"></ul>
          </div>
        </div>
      </div>
      <!-- /ANCHOR: ROOM_MODAL_TWO_COLS -->

    </div> <!-- /room-modal-body -->

      <div class="room-modal-plans">
        <p class="room-modal-subtitle">Available plans</p>
        <div id="roomModalPlans"></div>
      </div>

        <!-- ANCHOR: ROOM_MODAL_LIGHTBOX -->
        <div id="roomModalLightbox" class="room-modal-lightbox" aria-hidden="true">
          <div class="room-modal-lightbox-backdrop"></div>

          <div class="room-modal-lightbox-inner">
            <button class="room-modal-lightbox-close" aria-label="Close">X</button>
            <button class="room-modal-lightbox-prev" aria-label="Previous image">‹</button>

            <img class="room-modal-lightbox-img" src="" alt="Room photo" />

            <button class="room-modal-lightbox-next" aria-label="Next image">›</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr@4.6.13/dist/flatpickr.min.js"></script>

  <script>
    // ANCHOR: DETAILS_QUERY_PARAMS
    // === DETAILS LOADING OVERLAY HELPERS (with min-delay + page hide) ===
    let __detailsLoadingShownAt = 0;
    const DETAILS_LOADING_MIN_MS = 350;

    function detailsLoadingOn(){
      const el = document.getElementById("detailsLoading");
      if (!el) return;

      __detailsLoadingShownAt = Date.now();

      el.classList.add("is-on");
      el.setAttribute("aria-hidden","false");

      // Hide underlying page while loading
      document.body.classList.add("details-loading-on");
    }

    function detailsLoadingOff(){
      const el = document.getElementById("detailsLoading");
      if (!el) return;

      const elapsed = Date.now() - (__detailsLoadingShownAt || 0);
      const remaining = Math.max(0, DETAILS_LOADING_MIN_MS - elapsed);

      window.setTimeout(() => {
        el.classList.remove("is-on");
        el.setAttribute("aria-hidden","true");

        // Reveal page again
        document.body.classList.remove("details-loading-on");
      }, remaining);
    }

    const qs = new URLSearchParams(location.search || '');

    // Shared params for this page
    const propertyId =
      Number(qs.get('propertyId') || qs.get('partnerId') || '') || '';

    let start = qs.get('start') || '';
    let end   = qs.get('end') || '';

    // Fallback if dates are missing
    if (!start || !end) {
      const today = new Date();
      const tomorrow = new Date(today);
      tomorrow.setDate(today.getDate() + 1);
      const fmt = d => d.toISOString().slice(0, 10);
      if (!start) start = fmt(today);
      if (!end)   end   = fmt(tomorrow);
    }

    const plan =
      (qs.get('ratePlanId') || qs.get('plan') || '').trim();

    // === ANALYTICS (V2) ===================================================
    const WA_ENDPOINT = "/api/analytics/event";
    const WA_SID_KEY  = "lolaelo_wa_sid";

    function waGetSid(){
      try { return localStorage.getItem(WA_SID_KEY) || ""; } catch (_) { return ""; }
    }
    function waSetSid(sid){
      try { if (sid) localStorage.setItem(WA_SID_KEY, sid); } catch (_) {}
    }

    async function waTrack(name, payload, activeMs){
      try {
        const body = {
          sid: waGetSid() || null,
          name: String(name || "").trim(),
          path: location.pathname,
          url: location.href,
          title: document.title || "",
          referrer: document.referrer || "",
          activeMs: Number.isFinite(activeMs) ? activeMs : 0,
          payload: payload && typeof payload === "object" ? payload : null
        };
        if (!body.name) return;

        const r = await fetch(WA_ENDPOINT, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body),
          keepalive: true
        }).catch(() => null);

        const j = r ? await r.json().catch(() => null) : null;
        if (j && j.ok && j.sid) waSetSid(String(j.sid));
      } catch (_) {}
    }

    document.addEventListener("DOMContentLoaded", () => {
      waTrack("page_view", { page: "catalog_details" }, 0);

      // Property view (key funnel step)
      const pid = Number(propertyId || 0) || 0;
      if (pid > 0) {
        waTrack("view_property", { partnerId: pid }, 0);
      }
    });
    // === ANALYTICS (V2) END ===============================================

    // ANCHOR: DETAILS_DATE_BAR_SETUP
    (function setupDetailsDateBar() {
      const checkInInput   = document.getElementById("detail-checkin");
      const checkOutInput  = document.getElementById("detail-checkout");
      const applyBtn       = document.getElementById("detail-dates-apply");
      const rangeDriver    = document.getElementById("details-dates-driver");
      const displayBtn     = document.getElementById("details-dates-display");
      const displayLabel   = document.getElementById("details-dates-display-label");
      const combinedField  = document.querySelector(".detail-date-field.detail-dates-combined");

      if (!checkInInput || !checkOutInput || !applyBtn) return;

      // Helper: local YYYY-MM-DD formatter (no timezone conversion)
      function formatLocalYmd(d) {
        const y  = d.getFullYear();
        const m  = String(d.getMonth() + 1).padStart(2, "0");
        const dd = String(d.getDate()).padStart(2, "0");
        return y + "-" + m + "-" + dd;
      }

      // Helper: parse YYYY-MM-DD as a local Date (no UTC shift)
      function parseLocalYmd(str) {
        if (!str) return null;
        const parts = str.split("-");
        if (parts.length !== 3) return null;
        const y = Number(parts[0]);
        const m = Number(parts[1]);
        const d = Number(parts[2]);
        if (!y || !m || !d) return null;
        return new Date(y, m - 1, d);
      }

      // For the visible label, use numeric m/d/Y like the other pages
      function labelFromYmd(ymd) {
        const d = parseLocalYmd(ymd);
        if (!d) return "";
        const mm = String(d.getMonth() + 1).padStart(2, "0");
        const dd = String(d.getDate()).padStart(2, "0");
        const yy = d.getFullYear();
        return mm + "/" + dd + "/" + yy;
      }

      function syncDisplay() {
        if (!displayLabel || !combinedField) return;

        const ciRaw = checkInInput.value;
        const coRaw = checkOutInput.value;

        if (!ciRaw || !coRaw) {
          combinedField.classList.remove("has-dates");
          displayLabel.textContent = "Check-in – Check-out";
          return;
        }

        const ciLabel = labelFromYmd(ciRaw);
        const coLabel = labelFromYmd(coRaw);
        if (!ciLabel || !coLabel) {
          combinedField.classList.remove("has-dates");
          displayLabel.textContent = "Check-in – Check-out";
          return;
        }

        combinedField.classList.add("has-dates");
        displayLabel.textContent = ciLabel + " to " + coLabel;
      }

      // Initialize hidden inputs from current URL dates
      try {
        checkInInput.value  = start;
        checkOutInput.value = end;
      } catch (_) {
        // ignore
      }
      syncDisplay();

      // Flatpickr range on the invisible driver, if available
      let fp = null;
      if (rangeDriver && window.flatpickr) {
        const defaultDates = [];
        const sDate = parseLocalYmd(start);
        const eDate = parseLocalYmd(end);
        if (sDate) defaultDates.push(sDate);
        if (eDate) defaultDates.push(eDate);

        fp = flatpickr(rangeDriver, {
          mode: "range",
          dateFormat: "Y-m-d",
          minDate: "today",
          defaultDate: defaultDates,
          onChange(selectedDates) {
            let s = selectedDates[0] || null;
            let e = selectedDates[1] || null;

            // Enforce end >= start + 1 day, same rule as catalog
            if (s && !e) {
              e = new Date(s.getTime());
              e.setDate(e.getDate() + 1);
            }

            if (s && e) {
              checkInInput.value  = formatLocalYmd(s);
              checkOutInput.value = formatLocalYmd(e);
              syncDisplay();
            }
          }
        });

        // Clicking the visible pill opens the calendar (or falls back to native picker)
        if (displayBtn) {
          displayBtn.addEventListener("click", function () {
            if (fp && typeof fp.open === "function") {
              fp.open();
              return;
            }
            if (checkInInput) {
              checkInInput.focus();
              if (typeof checkInInput.showPicker === "function") {
                checkInInput.showPicker();
              }
            }
          });
        }
      } else if (displayBtn) {
        // No flatpickr loaded: still make the pill do something useful
        displayBtn.addEventListener("click", function () {
          if (checkInInput) {
            checkInInput.focus();
            if (typeof checkInInput.showPicker === "function") {
              checkInInput.showPicker();
            }
          }
        });
      }

      // Fallback: if someone changes check-in (keyboard, etc.), keep end ≥ start+1 and refresh label
      checkInInput.addEventListener("change", function () {
        const ciRaw = checkInInput.value;
        if (!ciRaw) return;

        const ciDate = parseLocalYmd(ciRaw);
        if (!ciDate) return;

        const coRaw = checkOutInput.value;
        let endDate = null;

        if (coRaw) {
          const parsedEnd = parseLocalYmd(coRaw);
          if (parsedEnd && parsedEnd > ciDate) {
            endDate = parsedEnd;
          }
        }

        if (!endDate) {
          endDate = new Date(ciDate.getTime());
          endDate.setDate(ciDate.getDate() + 1);
        }

        checkOutInput.value = formatLocalYmd(endDate);
        syncDisplay();
      });

      // Apply button: enforce end > start and push dates into URL
      applyBtn.addEventListener("click", function () {
        const ciRaw = checkInInput.value || start;
        const coRaw = checkOutInput.value || end;

        // Guardrail: no past / invalid dates
        if (typeof guardDatesOrDisable === "function") {
          const ok = guardDatesOrDisable({
            startStr: (ciRaw || "").slice(0, 10),
            endStr: (coRaw || "").slice(0, 10),
            btns: [applyBtn],
            containerEl: combinedField || document.querySelector(".summary-actions") || document.body
          });
          if (!ok) return;
        }

        if (!ciRaw) return;

        const ciDate = parseLocalYmd(ciRaw);
        let finalStart = (ciRaw || "").slice(0, 10);
        let finalEnd;

        if (ciDate) {
          let endDate = null;

          if (coRaw) {
            const parsedEnd = parseLocalYmd(coRaw);
            if (parsedEnd && parsedEnd > ciDate) {
              endDate = parsedEnd;
            }
          }

          if (!endDate) {
            endDate = new Date(ciDate.getTime());
            endDate.setDate(ciDate.getDate() + 1);
          }

          finalEnd = formatLocalYmd(endDate);
        } else {
          finalEnd = (coRaw || "").slice(0, 10);
        }

        const qsNext = new URLSearchParams(location.search);
        qsNext.set("start", finalStart);
        qsNext.set("end",   finalEnd);

        const nextUrl = `${location.pathname}?${qsNext.toString()}`;
        location.assign(nextUrl);
      });
      // Step C: Guardrail - prevent navigating to checkout with past/invalid dates
      // Blocks clicks on the "Select" buttons (a.roomcat-plan-btn) if dates are invalid.
      document.addEventListener("click", function (e) {
        const a = e.target && e.target.closest ? e.target.closest('a.roomcat-plan-btn') : null;
        if (!a) return;

        const ciRaw = (checkInInput && checkInInput.value) ? checkInInput.value : start;
        const coRaw = (checkOutInput && checkOutInput.value) ? checkOutInput.value : end;

        if (typeof guardDatesOrDisable === "function") {
          const ok = guardDatesOrDisable({
            startStr: (ciRaw || "").slice(0, 10),
            endStr: (coRaw || "").slice(0, 10),
            btns: [applyBtn],
            containerEl: combinedField || document.querySelector(".summary-actions") || document.body
          });
          if (!ok) {
            e.preventDefault();
            e.stopPropagation();
            return;
          }
        }
      }, true);
    })();

    // ANCHOR: DETAILS_PLAN_PARAM_DEF
    const planParam = (qs.get('ratePlanId') || qs.get('plan') || '').trim();
    const planQS = planParam ? `&ratePlanId=${encodeURIComponent(planParam)}` : '';

    /* ANCHOR: DETAILS_SET_BACK */
    const backLink = document.querySelector('a.back');
    if (backLink){
      const guests = qs.get('guests') || '2';
      const plan   = qs.get('ratePlanId') || qs.get('plan') || '';
      const planPart = plan ? `&ratePlanId=${encodeURIComponent(plan)}` : '';
      backLink.href =
        `/catalog?start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}&guests=${encodeURIComponent(guests)}${planPart}`;
    }

    const hero = document.getElementById('hero-img');
    hero.decoding = 'async';
    hero.draggable = false;
    const heroWrap = document.getElementById('hero'); // container div for hero
    const thumbs = document.getElementById('thumbs');
    const fromEl = document.getElementById('from');
    const rangeEl = document.getElementById('stay-range');
    const nameEl = document.getElementById('prop-name');
    const amenities = document.getElementById('amenities'); // may not exist on this page
    const nightsNote = document.getElementById('nights-note'); // may not exist

        const locationEl =
      document.getElementById('prop-location') ||
      document.querySelector('[data-prop-location]') ||
      null;

    // Helpers for checkout URL meta
    function getCheckoutMeta() {
      const payload = window.__detailsPayload || {};

      const propertyName =
        (nameEl && nameEl.textContent ? nameEl.textContent.trim() : '') ||
        String(
          (payload && (payload.name || payload.title || payload.propertyName)) ||
          (payload &&
            payload.meta &&
            payload.meta.property &&
            payload.meta.property.name) ||
          ''
        ).trim() ||
        'Property';

      const propertyLocation =
        (locationEl && locationEl.textContent
          ? locationEl.textContent.trim()
          : '') || '';

      return { propertyName, propertyLocation };
    }

    function getRoomNameForCheckout(roomId) {
      const payload = window.__detailsPayload || {};
      const rooms = Array.isArray(payload.rooms) ? payload.rooms : [];
      const room = rooms.find(r => {
        const cand =
          r.roomTypeId ??
          r.typeId ??
          r.id ??
          r.roomId ??
          r.code ??
          '';
        return String(cand) === String(roomId);
      });
      return (
        (room &&
          String(room.name || room.title || room.roomName).trim()) ||
        'Room'
      );
    }

    let images = [];
    // Start at -1 so the first setHero(0) does not early-return
    let heroIndex = -1;

    /* ANCHOR: IMAGE_PLACEHOLDER_HELPER */
    function getPlaceholderSVG(label = 'Photo not available'){
      return 'data:image/svg+xml;utf8,' + encodeURIComponent(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 450">
          <rect width="800" height="450" fill="white"/>
          <rect x="20" y="20" width="760" height="410" fill="#f3f4f6" stroke="#e5e7eb"/>
          <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle"
                font-family="Inter, Arial, sans-serif" font-size="20" fill="#9ca3af">${label}</text>
        </svg>`
      );
    }

    /* ANCHOR: HERO_SRCSET_HELPER */
    function buildHeroSrcSet(url){
      try{
        const u = new URL(url, location.origin);
        if (!/picsum\.photos$/.test(u.hostname)) return null;
        const m = u.pathname.match(/\/id\/(\d+)\/(\d+)\/(\d+)/);
        if (!m) return null;
        const id = m[1], w = Number(m[2]), h = Number(m[3]);
        if (!Number.isFinite(w) || !Number.isFinite(h)) return null;
        const oneX  = `https://picsum.photos/id/${id}/${w}/${h}`;
        const twoX  = `https://picsum.photos/id/${id}/${w*2}/${h*2}`;
        return `${oneX} 1x, ${twoX} 2x`;
      }catch{ return null; }
    }

    /* ANCHOR: HERO_PRELOAD_HELPER */
    const __heroPreloaded = new Set();
    function preloadImage(url){
      if (!url || __heroPreloaded.has(url)) return;
      const img = new Image();
      img.loading = 'eager';
      img.decoding = 'async';
      img.src = url;
      __heroPreloaded.add(url);
    }

    function setHero(i){
      if (!images.length) return;

      // clamp
      i = Math.max(0, Math.min(images.length - 1, i));

      // if same index, do nothing (prevents redundant fade / “double blink”)
      if (i === heroIndex) return;

      heroIndex = i;
      const src = images[i];

      hero.classList.add('is-fading');
      const img = new Image();
      img.onload = () => {
        hero.src = src;

        const ss = buildHeroSrcSet(src);
        if (ss) {
          hero.setAttribute('srcset', ss);
          hero.setAttribute('sizes', '(min-width: 900px) 70vw, 100vw');
        } else {
          hero.removeAttribute('srcset');
          hero.removeAttribute('sizes');
        }

        hero.alt = `${nameEl.textContent || 'Property'} — hero image`;
        hero.loading = 'eager';
        hero.fetchPriority = 'high';

        requestAnimationFrame(() => {
          hero.classList.remove('is-fading');
          if (heroWrap) heroWrap.classList.remove('is-loading');

          // Mark ready ONLY after the image is actually usable
          hero.classList.add('is-ready');
          if (heroWrap) heroWrap.classList.add('is-ready');
        });
      };

      img.onerror = () => {
        const ph = getPlaceholderSVG('Photo not available');
        hero.src = ph;
        hero.removeAttribute('srcset');
        hero.removeAttribute('sizes');
        hero.alt = `${nameEl.textContent || 'Property'} — photo not available`;

        requestAnimationFrame(() => {
          hero.classList.remove('is-fading');
          if (heroWrap) heroWrap.classList.remove('is-loading');

          // Even on error, exit loading state cleanly
          hero.classList.add('is-ready');
          if (heroWrap) heroWrap.classList.add('is-ready');
        });
      };

      img.src = src;

      thumbs.querySelectorAll('button.thumb').forEach((btn, idx) => {
        btn.setAttribute('aria-current', idx === i ? 'true' : 'false');
      });

      // Preload previous/next images
      const prevIdx = i - 1;
      const nextIdx = i + 1;
      if (prevIdx >= 0) preloadImage(images[prevIdx]);
      if (nextIdx < images.length) preloadImage(images[nextIdx]);

      // Toggle arrows
      const prevBtn = document.getElementById('hero-prev');
      const nextBtn = document.getElementById('hero-next');
      const n = images.length;

      if (n <= 1) {
        prevBtn.classList.add('is-hidden');
        nextBtn.classList.add('is-hidden');
      } else {
        prevBtn.classList.remove('is-hidden');
        nextBtn.classList.remove('is-hidden');

        const atStart = i <= 0;
        const atEnd   = i >= n - 1;

        prevBtn.disabled = atStart;
        nextBtn.disabled = atEnd;

        prevBtn.setAttribute('aria-disabled', atStart ? 'true' : 'false');
        nextBtn.setAttribute('aria-disabled', atEnd   ? 'true' : 'false');
      }
    }

    // ANCHOR: HERO_NAV_LOGIC
    (() => {
      const prevBtn = document.getElementById('hero-prev');
      const nextBtn = document.getElementById('hero-next');
      if (prevBtn) prevBtn.addEventListener('click', () => setHero(heroIndex - 1));
      if (nextBtn) nextBtn.addEventListener('click', () => setHero(heroIndex + 1));
    })();

    /* ANCHOR: HERO_TOUCH_SWIPE */
    (() => {
      const heroWrap = document.getElementById('hero');
      if (!heroWrap) return;

      let startX = 0, startY = 0, active = false;

      heroWrap.addEventListener('touchstart', (e) => {
        if (!e.touches || e.touches.length !== 1) return;
        const t = e.touches[0];
        startX = t.clientX;
        startY = t.clientY;
        active = true;
      }, { passive: true });

      heroWrap.addEventListener('touchmove', (e) => {
        if (!active || !e.touches || e.touches.length !== 1) return;
        const dy = Math.abs(e.touches[0].clientY - startY);
        if (dy > 20) active = false;
      }, { passive: true });

      heroWrap.addEventListener('touchend', (e) => {
        if (!active) return;
        active = false;
        const t = e.changedTouches && e.changedTouches[0];
        if (!t) return;
        const dx = t.clientX - startX;
        const threshold = 40;
        if (Math.abs(dx) < threshold) return;

        if (dx < 0) setHero(heroIndex + 1);
        else        setHero(heroIndex - 1);
      }, { passive: true });
    })();

    /* ANCHOR: GALLERY_KB_NAV */
    document.addEventListener('keydown', (e) => {
      if (e.altKey || e.ctrlKey || e.metaKey) return;
      if (e.key === 'ArrowLeft') { setHero(heroIndex - 1); e.preventDefault(); }
      if (e.key === 'ArrowRight') { setHero(heroIndex + 1); e.preventDefault(); }
    });

    /* ANCHOR: THUMB_SRC_HELPER */
    function buildThumbSrcAndSet(url){
      try{
        const u = new URL(url, location.origin);
        if (!/picsum\.photos$/.test(u.hostname)) return { src: url, srcset: null };
        const m = u.pathname.match(/\/id\/(\d+)\/(\d+)\/(\d+)/);
        if (!m) return { src: url, srcset: null };
        const id = m[1], w = 110, h = 72;
        const oneX = `https://picsum.photos/id/${id}/${w}/${h}`;
        const twoX = `https://picsum.photos/id/${id}/${w*2}/${h*2}`;
        return { src: oneX, srcset: `${oneX} 1x, ${twoX} 2x` };
      }catch{ return { src: url, srcset: null }; }
    }
    function thumbHTML(src, idx){
      const current = idx === 0 ? 'true' : 'false';
      const total = images.length || 0;
      const name = (nameEl && nameEl.textContent) ? nameEl.textContent : 'Property';
      const w = 110, h = 72;
      const { src: s, srcset } = buildThumbSrcAndSet(src);
      const srcsetAttr = srcset ? ` srcset="${srcset}" sizes="110px"` : '';
      return `<button class="thumb" type="button" data-idx="${idx}" aria-label="${name} photo ${idx+1} of ${total}" aria-current="${current}">
        <img src="${s}"${srcsetAttr} alt="${name} — photo ${idx+1} of ${total}" loading="lazy" decoding="async" width="${w}" height="${h}" draggable="false">
      </button>`;
    }

    function money(v){ const n=Number(v); return Number.isFinite(n) ? `$${n.toFixed(2)}` : '—'; }

    function formatYMD(ymd){
      if (!ymd || typeof ymd !== "string") return ymd;
      const parts = ymd.split("-");
      if (parts.length !== 3) return ymd;
      const [y, m, d] = parts.map(Number);
      if (!y || !m || !d) return ymd;
      const months = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
      const label = months[m - 1];
      if (!label) return ymd;
      return `${label} ${d}, ${y}`;
    }

    async function load(){
      // ANCHOR: DETAILS_FETCH_WITH_PLAN
      console.log("[details] fetching catalog details with:", {
        propertyId, start, end, plan, urlPreview:
        `/catalog/details?propertyId=${encodeURIComponent(propertyId)}&start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}${plan ? "&ratePlanId="+encodeURIComponent(plan) : ""}`
      });

      const planQS   = plan ? `&ratePlanId=${encodeURIComponent(plan)}` : '';
      const url      = `/catalog/details?propertyId=${encodeURIComponent(propertyId)}&start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}${planQS}`;
      const urlAlt   = `/api/catalog/details?propertyId=${encodeURIComponent(propertyId)}&start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}${planQS}`;

      // ANCHOR: SKELETON_START
      detailsLoadingOn();
      if (heroWrap) heroWrap.classList.add('is-loading');

      // Force a non-broken initial image while loading
      try{
        const ph = getPlaceholderSVG('Loading photos…');
        if (hero && !hero.getAttribute('src')) hero.src = ph;
        hero.classList.remove('is-ready');
        if (heroWrap) heroWrap.classList.remove('is-ready');
      }catch(_){}

      // Robust fetch with fallback
      let j;
      try {
        console.log('[details] GET', url);
        let r = await fetch(url, { cache: 'no-store' });
        if (!r.ok) {
          console.warn('[details] primary failed', r.status, r.statusText);
          if (r.status === 404) {
            console.log('[details] retrying fallback', urlAlt);
            r = await fetch(urlAlt, { cache: 'no-store' });
          }
        }
        if (!r.ok) throw new Error(`HTTP ${r.status} ${r.statusText}`);
        j = await r.json();
        // ===== DETAILS_PAYLOAD_TAP (insert) =====
        window.__detailsPayload = j;  // allow console inspection

        // Existing image summary (keep)
        console.log("[details] images.summary", {
          hasImagesArray: Array.isArray(j?.images),
          imagesLen: Array.isArray(j?.images) ? j.images.length : 0,
          room0HasImages: Array.isArray(j?.rooms?.[0]?.images),
          room0ImagesLen: Array.isArray(j?.rooms?.[0]?.images) ? j.rooms[0].images.length : 0
        });

        // New: verify DB-backed room inclusions are present in the payload
        try {
          console.log("[details] rooms inclusion_keys snapshot",
            (j?.rooms || []).map(r => ({
              id: r.roomTypeId ?? r.typeId ?? r.id ?? r.roomId ?? r.code ?? null,
              inclusion_keys_len: Array.isArray(r?.inclusion_keys) ? r.inclusion_keys.length : null,
              inclusion_text_len: (r?.inclusion_text || "").length
            }))
          );
        } catch (_) {}

        // ===== DETAILS_PAYLOAD_TAP (insert end) =====
        // ===== DETAILS_PAYLOAD_DUMP (insert) =====
        console.log("[details] full payload", j);
        // ===== DETAILS_PAYLOAD_DUMP (insert end) =====
        // ===== DETAILS_IMG_DEBUG (insert) =====
        console.log("[details] payload keys:", Object.keys(j || {}));
        console.log("[details] j.images:", j?.images);
        console.log("[details] rooms[0].images:", j?.rooms?.[0]?.images);
        try {
          const badge = document.getElementById("src-badge");
          if (badge) {
            const a = Array.isArray(j?.images) ? j.images.length : 0;
            const b = Array.isArray(j?.rooms?.[0]?.images) ? j.rooms[0].images.length : 0;
            badge.textContent = `${j?._roomsSource || "src"} · img:${a} · r0:${b}`;
            badge.style.display = "inline-block";
          }
        } catch {}
        // ===== DETAILS_IMG_DEBUG (insert end) =====
      } catch (e) {
        console.error('[details] fetch error', e);
        throw e;
      }

      // Safe DOM writes + property card fallback from /catalog/search
      let propertyCard = null;
      try {
        const q = `start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}&partnerId=${encodeURIComponent(propertyId)}&limit=1`;
        const sr = await fetch(`/catalog/search?${q}`, { cache: 'no-store' });
        if (sr.ok) {
          const sj = await sr.json();
          const pidStr = String(propertyId);
          const props = Array.isArray(sj?.properties) ? sj.properties : (Array.isArray(sj) ? sj : []);
          propertyCard =
            props.find(it => String(it.partnerId ?? it.propertyId ?? it.id) === pidStr) ||
            props[0] ||
            null;
        }
      } catch (e) {
        console.warn('[details] propertyCard search fallback failed', e);
      }

      if (nameEl) {
        const mp = j?.meta?.property || {};
        const cp = propertyCard || {};

        const candidates = [
          mp.displayName,
          mp.name,
          mp.title,
          j?.displayName,
          j?.title,
          j?.name,
          cp.displayName,
          cp.name,
          cp.title,
          cp.propertyName
        ];

        let displayName = '';
        for (const c of candidates) {
          const v = (c ?? '').toString().trim();
          if (v && v.toLowerCase() !== 'stay') {
            displayName = v;
            break;
          }
        }

        if (!displayName) displayName = 'Property';
        nameEl.textContent = displayName;
      }

      {
        const srcBadgeEl = document.getElementById('src-badge');
        if (srcBadgeEl) {
          srcBadgeEl.style.display =
            (j?._roomsSource === 'db') ? 'inline-block' : 'none';
        }
      }

      if (rangeEl) {
        const fs = formatYMD(start);
        const fe = formatYMD(end);
        rangeEl.textContent = (start === end)
          ? fs
          : `${fs} to ${fe}`;
      }

            // ANCHOR: DETAILS_LOCATION_DESC_RENDER
      {
        const locEl = document.getElementById('prop-location');
        const descEl = document.getElementById('prop-desc');

        const mp = j?.meta?.property || {};
        const cp = propertyCard || {};

        // Prefer meta.property, then card fields, then top-level
        const area =
          mp.area ||
          cp.area ||
          cp.district ||
          '';

        const city =
          mp.city ||
          cp.city ||
          cp.town ||
          j?.city ||
          '';

        const island =
          mp.island ||
          cp.island ||
          '';

        const country =
          mp.country ||
          cp.country ||
          j?.country ||
          '';

        const parts = [area, city, island, country]
          .map(x => String(x || '').trim())
          .filter(Boolean);

        if (locEl) {
          if (parts.length) {
            locEl.textContent = parts.join(' · ');
          } else if (j?.location && typeof j.location === 'string') {
            locEl.textContent = j.location;
          } else if (cp.location && typeof cp.location === 'string') {
            locEl.textContent = cp.location;
          } else {
            locEl.textContent = '';
          }
        }

        // Description bubble: prefer Company Profile description
        if (descEl) {
          // Description priority:
          // 1) Company Profile (partners_app) – meta.property / card description
          // 2) Any long-form description from meta
          // 3) Card summary
          // 4) Details-level description fields
          const desc =
            (mp && typeof mp.description === 'string' && mp.description.trim()) ||
            (cp && typeof cp.description === 'string' && cp.description.trim()) ||
            (mp && typeof mp.longDescription === 'string' && mp.longDescription.trim()) ||
            (cp && typeof cp.summary === 'string' && cp.summary.trim()) ||
            (j && typeof j.description === 'string' && j.description.trim()) ||
            (j && j.meta && typeof j.meta.description === 'string' && j.meta.description.trim()) ||
            '';

          descEl.textContent = desc || '';
          descEl.style.display = desc ? 'block' : 'none';

          // TEMP: one-time debug so we can see what the API is actually sending
          if (!window.__detailsDescDebugged) {
            try {
              console.log('DETAILS DESC DEBUG', {
                fromMeta: mp && mp.description,
                fromCard: cp && cp.description,
                fromMetaLong: mp && mp.longDescription,
                fromCardSummary: cp && cp.summary,
                fromJ: j && j.description,
                fromJMeta: j && j.meta && j.meta.description,
                finalDesc: desc
              });
            } catch (_) {}
            window.__detailsDescDebugged = true;
          }
        }

        // Map icon wiring: prefer lat/lng from Company Profile (partners_app)
        const mapBtn       = document.getElementById('summary-map-btn');
        const mapBackdrop  = document.getElementById('details-map-modal');
        const mapFrame     = document.getElementById('details-map-frame');
        const mapClose     = document.getElementById('details-map-close');

        if (mapBtn) {
          // Try to get coordinates from meta, card, or top-level payload
          const latRaw =
            mp.lat ||
            mp.latitude ||
            mp.geoLat ||
            mp.mapLat ||
            cp.lat ||
            cp.latitude ||
            cp.geoLat ||
            cp.mapLat ||
            j?.lat ||
            j?.latitude ||
            j?.geoLat ||
            null;

          const lngRaw =
            mp.lng ||
            mp.longitude ||
            mp.geoLng ||
            mp.mapLng ||
            cp.lng ||
            cp.longitude ||
            cp.geoLng ||
            cp.mapLng ||
            j?.lng ||
            j?.longitude ||
            j?.geoLng ||
            null;

          let mapQuery = "";

          // 1) Primary: explicit lat/lng from Company Profile / payload
          if (latRaw != null && lngRaw != null) {
            const lat = Number(latRaw);
            const lng = Number(lngRaw);
            if (Number.isFinite(lat) && Number.isFinite(lng)) {
              mapQuery = `${lat},${lng}`;
            }
          }

          // 2) Fallback: address-style string (including any map label)
          if (!mapQuery) {
            const addrParts = [
              mp.mapLabel,
              j?.mapLabel,
              mp.addressLine1,
              mp.addressLine2,
              mp.barangay,
              area,
              city,
              island,
              country,
              cp.address,
              cp.location,
              j?.location
            ]
              .map(x => String(x || "").trim())
              .filter(Boolean);

            mapQuery = addrParts.join(", ");
          }

          // Store query if available
          if (mapQuery) {
            mapBtn.dataset.mapQuery = mapQuery;
          } else {
            delete mapBtn.dataset.mapQuery;
          }

          // Always show the icon in the layout
          mapBtn.style.display = "inline-flex";

          // Bind click → open inline modal map (once)
          if (!mapBtn.dataset.bound) {
            const closeModal = () => {
              if (!mapBackdrop) return;
              mapBackdrop.style.display = "none";
              mapBackdrop.setAttribute("aria-hidden", "true");
            };

            if (mapClose) {
              mapClose.addEventListener("click", closeModal);
            }
            if (mapBackdrop) {
              mapBackdrop.addEventListener("click", (ev) => {
                if (ev.target === mapBackdrop) closeModal();
              });
            }

            mapBtn.addEventListener("click", () => {
              if (!mapBackdrop || !mapFrame) return;

              // Prefer stored query, fallback to visible location text
              let q = (mapBtn.dataset.mapQuery || "").trim();
              if (!q) {
                const locEl = document.getElementById("prop-location");
                const locText =
                  locEl && typeof locEl.textContent === "string"
                    ? locEl.textContent.trim()
                    : "";
                if (locText) q = locText;
              }
              if (!q) return;

              const isLatLng =
                /^-?\d+(\.\d+)?,-?\d+(\.\d+)?$/.test(q);

              const embedUrl = isLatLng
                ? `https://www.google.com/maps?q=${encodeURIComponent(q)}&z=15&output=embed`
                : `https://www.google.com/maps?q=${encodeURIComponent(q)}&output=embed`;

              mapFrame.src = embedUrl;
              mapBackdrop.style.display = "flex";
              mapBackdrop.setAttribute("aria-hidden", "false");
            });

            mapBtn.dataset.bound = "1";
          }
        }
      }

      // Compute fromPrice from daily rows (first room) if available
      const daily0  = (j?.rooms?.[0]?.daily || []);
      const priced  = daily0.filter(d => typeof d.price === 'number');
      const minPrice = priced.length ? Math.min(...priced.map(d => Number(d.price))) : null;
      if (fromEl) fromEl.textContent = (minPrice != null) ? money(minPrice) : '—';

      // Global label maps for amenities bubble (same mapping as room modal)
      const DETAIL_LABELS = {
        // Views / position
        city_view:            "City view",
        sea_view:             "Sea / ocean view",
        garden_view:          "Garden view",
        pool_view:            "Pool view",
        high_floor:           "High floor",

        // Legacy position flags (kept so old data still renders)
        ground_floor:         "Ground floor",
        connecting:           "Connecting rooms available",
        accessible:           "Accessible room",

        // Beds
        bed_king:             "King bed",
        bed_queen:            "Queen bed",
        bed_double:           "Double bed",
        bed_single_twin:      "Single or twin bed",
        bed_bunk:             "Bunk bed",
        bed_sofa:             "Sofa bed",

        // Layout / private spaces
        balcony_terrace:      "Balcony or terrace",
        separate_living:      "Separate living area",
        kitchenette:          "Kitchenette",
        full_kitchen:         "Full kitchen",
        private_pool:         "Private pool",

        // In-room amenities
        air_conditioning:     "Air conditioning",
        tv_streaming:         "TV with streaming",
        refrigerator:         "Refrigerator",
        work_desk:            "Work desk",
        inroom_safe:          "In-room safe",

        // Bathroom / family
        bathtub:              "Bathtub",
        bidet:                "Bidet",
        crib_available:       "Crib or baby cot available",
        handicap_accessible:  "Handicap accessible room",
      };

      const INCLUSION_LABELS = {
        // New inclusions / facilities
        breakfast_included:    "Breakfast included (no added cost)",
        kids_free_under12:     "Kids stay free under 12",
        free_wifi:             "Free Wi-Fi",
        free_parking:          "Free parking",
        airport_shuttle:       "Airport shuttle",
        daily_housekeeping:    "Daily housekeeping",

        facility_pool:         "Swimming pool",
        facility_gym:          "Gym or fitness center",
        facility_spa_sauna:    "Spa or sauna",
        beachfront_access:     "Beachfront or direct beach access",
        watersports_equipment: "Water sports equipment (kayak / paddleboard / snorkel)",

        frontdesk_24h:         "24-hour front desk",
        family_friendly:       "Family / child-friendly property",
        nonsmoking_property:   "Non-smoking property",
        smoking_area:          "Smoking area",
        pets_allowed:          "Pets allowed",
        disabled_facilities:   "Facilities for disabled guests",

        business_center:       "Business center or meeting rooms",
        shared_kitchen:        "Shared kitchen or guest pantry",
        laundry:               "Laundry service or self-service laundry",
        onsite_restaurant:     "On-site restaurant",

        eco_cleaning:          "Eco-cleaning option (reduced housekeeping)",
        quiet_hours:           "Quiet hours enforced",
        crib_guaranteed:       "Guaranteed crib or baby cot",
        flexible_self_checkin: "Flexible self check-in (lockbox / smart lock)",

        // Legacy inclusion flags (kept so old data still renders)
        breakfast:             "Breakfast included",
        half_board:            "Half board",
        full_board:            "Full board",
        all_inclusive:         "All inclusive",
        late_checkout:         "Late checkout (subject to availability)",
        early_checkin:         "Early check-in (subject to availability)",
        pool_access:           "Pool access",
        spa_access:            "Spa / wellness access",
      };

      /* ANCHOR: DETAILS_AMENITIES_RENDER (property + room metadata) */
      {
        const mp = j?.meta?.property || {};
        const cp = propertyCard || {};

        const collected = [];

        // Accept arrays AND object maps (eg { free_wifi:true, breakfast:true })
        const pushArr = (arr) => {
          if (!Array.isArray(arr)) return;
          for (const v of arr) {
            if (v == null) continue;
            if (typeof v === "string") {
              const s = v.trim();
              if (s) collected.push(s);
              continue;
            }
            if (typeof v === "object" && v.name) {
              const s = String(v.name).trim();
              if (s) collected.push(s);
              continue;
            }
            const s = String(v).trim();
            if (s) collected.push(s);
          }
        };

        const pushObjKeysTrue = (obj) => {
          if (!obj || typeof obj !== "object" || Array.isArray(obj)) return;
          for (const k of Object.keys(obj)) {
            if (!obj[k]) continue;
            const s = String(k).trim();
            if (s) collected.push(s);
          }
        };

        // 1) Property-level lists (Company Profile / partners_app + card)
        pushArr(mp.amenities);     pushObjKeysTrue(mp.amenities);
        pushArr(mp.inclusions);    pushObjKeysTrue(mp.inclusions);
        pushArr(mp.features);      pushObjKeysTrue(mp.features);
        pushArr(mp.facilities);    pushObjKeysTrue(mp.facilities);

        pushArr(cp.amenities);     pushObjKeysTrue(cp.amenities);
        pushArr(cp.inclusions);    pushObjKeysTrue(cp.inclusions);
        pushArr(cp.features);      pushObjKeysTrue(cp.features);
        pushArr(cp.facilities);    pushObjKeysTrue(cp.facilities);

        // 2) Details-level flat lists from /catalog/details, if present
        pushArr(j?.amenities);     pushObjKeysTrue(j?.amenities);
        pushArr(j?.inclusions);    pushObjKeysTrue(j?.inclusions);
        pushArr(j?.features);      pushObjKeysTrue(j?.features);
        pushArr(j?.facilities);    pushObjKeysTrue(j?.facilities);

        // 3) Room-level metadata (DB-backed only; do NOT read localStorage here)
        if (Array.isArray(j?.rooms)) {
          const splitText = (txt) => {
            if (!txt || typeof txt !== "string") return [];
            return txt
              .split(/[•\n;]/)
              .map((s) => s.trim())
              .filter(Boolean);
          };

          for (const room of j.rooms) {
            if (!room) continue;

            // Direct arrays on the room object (from DB payload)
            pushArr(room.amenities);
            pushArr(room.inclusions);
            pushArr(room.features);

            // Meta containers (if backend includes them)
            if (room.meta && typeof room.meta === "object") {
              pushArr(room.meta.amenities);
              pushArr(room.meta.inclusions);
              pushArr(room.meta.features);
            }

            // Free-text fields (from DB payload)
            pushArr(splitText(room.details_text));
            pushArr(splitText(room.inclusion_text));

            // Keys -> labels (from DB payload)
            const inclusionKeys = Array.isArray(room.inclusion_keys) ? room.inclusion_keys : [];
            if (typeof INCLUSION_LABELS === "object") {
              pushArr(
                inclusionKeys
                  .map((k) => INCLUSION_LABELS[k])
                  .filter(Boolean)
              );
            }
          }
        }

        // Normalize, dedupe, trim list
        const chips = [...new Set(
          collected
            .map(s => String(s || "").trim())
            .filter(Boolean)
        )].slice(0, 12);

        console.log("[details] amenities chips", {
          count: chips?.length || 0,
          sample: (chips || []).slice(0, 12),
          propAmenities: j?.meta?.property?.amenities,
          propFacilities: j?.meta?.property?.facilities,
          roomAmenitiesCount: Array.isArray(j?.rooms) ? j.rooms.reduce((n,r)=> n + (Array.isArray(r?.amenities)? r.amenities.length : 0), 0) : null
        });

        const amenitiesEl = document.getElementById("amenities");
        if (amenitiesEl) {
          if (chips.length) {
            amenitiesEl.style.display = "flex";
            amenitiesEl.innerHTML = chips
              .map(a => `<span class="chip">${a}</span>`)
              .join("");
          } else {
            // IMPORTANT: don't hide the container, otherwise mobile shows a blank white bubble
            amenitiesEl.style.display = "block";
            amenitiesEl.innerHTML =
              `<div class="muted" style="font-size:13px; padding:6px 2px;">
                No property inclusions listed yet.
              </div>`;
          }
        }
      }

      /* ANCHOR: DESCRIPTION_BUBBLE_RENDER */
      {
        const propDescEl = document.getElementById("prop-desc");

        if (propDescEl) {
          const pDesc =
            (j?.meta?.property?.description &&
              String(j.meta.property.description).trim()) ||
            (j?.card?.property?.description &&
              String(j.card.property.description).trim()) ||
            "";

          if (pDesc) {
            propDescEl.style.display = "";
            propDescEl.textContent = pDesc;
          } else {
            propDescEl.style.display = "none";
            propDescEl.textContent = "";
          }
        }
      }

      /* ANCHOR: DETAILS_SUMMARY_BUBBLES_TAP_TOGGLE */
      (function setupSummaryBubbleTapToggle(){
        const wraps = Array.from(document.querySelectorAll('.summary-icon-wrap'));
        if (!wraps.length) return;

        // Create a dedicated backdrop so "tap outside" is unambiguous on mobile.
        // This avoids document-level click races / ghost clicks.
        let backdrop = document.getElementById('summaryBubbleBackdrop');
        if (!backdrop) {
          backdrop = document.createElement('div');
          backdrop.id = 'summaryBubbleBackdrop';
          backdrop.style.position = 'fixed';
          backdrop.style.inset = '0';
          backdrop.style.zIndex = '9998';     // bubble is 9999 on mobile
          backdrop.style.display = 'none';
          backdrop.style.background = 'transparent';
          document.body.appendChild(backdrop);
        }

        function closeAll(){
          wraps.forEach(w => w.classList.remove('is-open'));
          backdrop.style.display = 'none';
        }

        function openOne(wrap){
          wraps.forEach(w => { if (w !== wrap) w.classList.remove('is-open'); });
          wrap.classList.add('is-open');
          // Only show backdrop if this wrap actually has a bubble
          const hasBubble = !!wrap.querySelector('.summary-bubble');
          backdrop.style.display = hasBubble ? 'block' : 'none';
        }

        // Backdrop tap closes
        backdrop.addEventListener('click', (e) => {
          e.preventDefault();
          closeAll();
        }, { passive: false });

        wraps.forEach(wrap => {
          const btn = wrap.querySelector('.summary-icon-btn');
          const bubble = wrap.querySelector('.summary-bubble');

          if (bubble){
            // Keep clicks inside bubble from closing it
            bubble.addEventListener('click', (e) => e.stopPropagation(), { passive: true });
          }

          if (!btn) return;

          btn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();

            const isOpen = wrap.classList.contains('is-open');
            if (isOpen) closeAll();
            else openOne(wrap);
          }, { passive: false });
        });

        // Escape closes (nice UX on desktop too)
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') closeAll();
        });
      })();

      // Prefer PROPERTY-LEVEL photos (same as catalog cards), then details/room images
      const pickUrl = (it) =>
        typeof it === "string"
          ? it
          : (it?.url || it?.photoUrl || it?.imageUrl || it?.src || it?.href || "");

      const pickList = (arr) =>
        (Array.isArray(arr) ? arr : [])
          .map(pickUrl)
          .filter(Boolean);

      // 1) Primary: propertyCard photos (same source as catalog cards)
      let rawImages = [];
      let coverUrl = null;

      if (propertyCard) {
        // Try images/photos directly on the card
        rawImages = pickList(propertyCard.images || propertyCard.photos);

        // If a cover is defined, remember it so we can push it to front
        if (!coverUrl && propertyCard.cover) {
          const c = pickUrl(propertyCard.cover.url ? propertyCard.cover : propertyCard.coverUrl || propertyCard.cover);
          if (c) coverUrl = c;
        }
        if (!coverUrl && propertyCard.coverUrl) {
          const c = pickUrl(propertyCard.coverUrl);
          if (c) coverUrl = c;
        }
        if (!coverUrl && typeof propertyCard.image === "string") {
          coverUrl = propertyCard.image;
        }
      }

      // 2) Secondary: details.images from /catalog/details
      if (!rawImages.length && Array.isArray(j?.images)) {
        rawImages = pickList(j.images);

        // Try to detect designated cover inside j.images
        if (!coverUrl) {
          const coverObj = j.images.find(
            (it) =>
              it &&
              typeof it === "object" &&
              (it.isCover === true ||
                it.is_cover === true ||
                it.isPrimary === true ||
                it.is_primary === true)
          );
          if (coverObj) {
            const c = pickUrl(coverObj);
            if (c) coverUrl = c;
          }
        }
      }

      // 3) Tertiary: first room's images as a strict fallback
      if (
        !rawImages.length &&
        Array.isArray(j?.rooms?.[0]?.images)
      ) {
        rawImages = pickList(j.rooms[0].images);
      }

      // Normalize to plain URL strings
      images = rawImages.slice();

      // If we found a coverUrl, move it to the front
      if (coverUrl) {
        const idx = images.indexOf(coverUrl);
        if (idx > 0) {
          images.splice(0, 0, ...images.splice(idx, 1));
        }
      }

      // ===== DETAILS_IMG_FALLBACKS (streamlined) =====
      // 1) Try alternates in the details payload
      if (!images.length) {
        const pickFrom = (arr) =>
          (Array.isArray(arr) ? arr : [])
            .map(pickUrl)
            .filter(Boolean);

        images = pickFrom(j?.meta?.property?.photos);
        if (!images.length) images = pickFrom(j?.meta?.photos);
        if (!images.length) images = pickFrom(j?.rooms?.[0]?.photos);
      }

      detailsLoadingOff();

      // 2) We intentionally do NOT call extranet (auth) here; any additional
      //    property-level photos should be wired via the catalog/search card
      //    (propertyCard) or meta above.
      // ===== DETAILS_IMG_FALLBACKS (end) =====

      // 1) Try alternates in the details payload
      if (!images.length) {
        const pick = (arr) => (Array.isArray(arr) ? arr : [])
          .map(it => typeof it === 'string'
            ? it
            : (it?.url || it?.photoUrl || it?.imageUrl || it?.src || it?.href || ""))
          .filter(Boolean);

        images = pick(j?.meta?.property?.photos);
        if (!images.length) images = pick(j?.meta?.photos);
        if (!images.length) images = pick(j?.rooms?.[0]?.photos);
      }

      // 2) Primary public source (same wiring as catalog cards): /catalog/search
      if (!images.length) {
        try {
          const q  = `start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}&partnerId=${encodeURIComponent(propertyId)}&limit=1`;
          const sr = await fetch(`/catalog/search?${q}`, { cache: 'no-store' });
          console.log("[details][search] status:", sr.status);
          if (sr.ok) {
            const sj = await sr.json();
            console.log("[details][search] keys:", Object.keys(sj || {}));

            const pidStr  = String(propertyId);
            const pickUrl = (it) => (typeof it === 'string') ? it :
              (it?.url || it?.photoUrl || it?.imageUrl || it?.src || it?.href || "");
            const pickList = (arr) => (Array.isArray(arr) ? arr : []).map(pickUrl).filter(Boolean);

            // Prefer map-style if present; otherwise use properties[].images
            let arr = [];
            const maps = [sj?.photosByPid, sj?.photos_by_pid, sj?.byPid, sj?.photosMap, sj?.photos_map];
            for (const m of maps) {
              if (m && typeof m === "object") {
                if (Array.isArray(m[pidStr]))           { arr = pickList(m[pidStr]); break; }
                if (Array.isArray(m[Number(pidStr)]))   { arr = pickList(m[Number(pidStr)]); break; }
              }
            }
            if (!arr.length) {
              const props = Array.isArray(sj?.properties) ? sj.properties : (Array.isArray(sj) ? sj : []);
              const item  = props.find(it => String(it?.partnerId ?? it?.propertyId ?? it?.id) === pidStr) || props[0];
              if (item) {
                arr = pickList(item.images || item.photos || []);
                if (!arr.length && item?.cover)    arr = pickList([item.cover.url || item.cover]);
                if (!arr.length && item?.coverUrl) arr = pickList([item.coverUrl]);
                if (!arr.length && item?.image)    arr = pickList([item.image]);
              }
            }
            if (arr.length) {
              images = arr;
              console.log("[details] photos from /catalog/search:", images.length);
            }
          }
        } catch (e) {
          console.warn("[details] search photos fallback error", e);
        }
      }

      // NOTE: we intentionally skip /extranet/property/photos (auth) and
      // /catalog/property/photos|/catalog/photos (non-existent) to avoid 401/404 noise.
      // ===== DETAILS_IMG_FALLBACKS (end) =====

      // Final safety: de-duplicate images while preserving order
      if (Array.isArray(images) && images.length > 1) {
        const seen = new Set();
        images = images.filter((url) => {
          if (!url) return false;
          if (seen.has(url)) return false;
          seen.add(url);
          return true;
        });
      }

      const placeholder = 'data:image/svg+xml;utf8,' +
        encodeURIComponent(
          `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 450">
             <rect width="800" height="450" fill="white"/>
             <rect x="20" y="20" width="760" height="410" fill="#f3f4f6" stroke="#e5e7eb"/>
             <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle"
                   font-family="Inter, Arial, sans-serif" font-size="20" fill="#9ca3af">
               Photo not available
             </text>
           </svg>`
        );

      if (!images.length) {
        thumbs.innerHTML = '';
        hero.src = placeholder;
        hero.removeAttribute('srcset');
        hero.removeAttribute('sizes');
        hero.alt = `${nameEl.textContent || 'Property'} — photo not available`;
      } else {
        thumbs.innerHTML = images.map((src, i)=>thumbHTML(src, i)).join("");
        setHero(0);
      }

      if (thumbs) {
        thumbs.addEventListener('click', (e) => {
          const b = e.target.closest('.thumb'); if (!b) return;
          setHero(Number(b.dataset.idx || '0'));
        });
        thumbs.addEventListener('mouseover', (e) => {
          const b = e.target.closest('.thumb'); if (!b) return;
          setHero(Number(b.dataset.idx || '0'));
        });
      }
  
      /* ANCHOR: ROOMCAT_LIST_JS (expandable with per-plan subrows; self-contained) */
      (function(){
        const listEl = document.getElementById('roomCats');
        if (!listEl) return;

        // === QTY SELECTION STATE (v1) ===
        // key: `${roomId}|${planId}` -> qty
        const qtyByRoomPlanKey = Object.create(null);

        function qpKey(roomId, planId){
          return `${String(roomId)}|${String(planId)}`;
        }
        function clampInt(n, lo, hi){
          const x = Number.parseInt(n, 10);
          if (!Number.isFinite(x)) return lo;
          return Math.max(lo, Math.min(hi, x));
        }
        function getAvailForRoom(roomId){
          const el = document.querySelector(`.roomcat[data-room-id="${CSS.escape(String(roomId))}"]`);
          const v = el ? Number(el.getAttribute('data-available-rooms') || 0) : 0;
          return Number.isFinite(v) ? Math.max(0, v) : 0;
        }

        // local helpers
        function getSelectedPlanIds(){
          try { const a = JSON.parse(localStorage.getItem('rateplan.selectedIds')||'[]'); return Array.isArray(a)?a.map(Number).filter(Number.isFinite):[]; }
          catch { return []; }
        }
        function getCustomLabels(){
          try { return JSON.parse(localStorage.getItem('rateplan.customLabels')||'{}')||{}; }
          catch { return {}; }
        }
        function friendlyPlanName(id){
          if (Number(id) === 1) return 'Standard';
          const labels = getCustomLabels();
          return labels.CUS1 || labels.CUS2 || `Plan ${Number(id)}`;
        }
        function derivePlansForDisplay(){
          // 1) Try localStorage (set by partners_rooms.html)
          let ids = [];
          try {
            const a = JSON.parse(localStorage.getItem('rateplan.selectedIds') || '[]');
            if (Array.isArray(a)) ids = a.map(Number).filter(Number.isFinite);
          } catch {}

          // 2) If empty, fall back to URL (?plans=1,2,6 or ?plan=1)
          if (!ids.length) {
            try {
              const u = new URL(location.href);
              const csv = (u.searchParams.get('plans') || '').trim();
              if (csv) {
                ids = csv.split(',').map(s => Number(s.trim())).filter(Number.isFinite);
              } else {
                const p = Number(u.searchParams.get('ratePlanId') || u.searchParams.get('plan'));
                if (Number.isFinite(p)) ids = [p];
              }
            } catch {}
          }

          // 3) Default to Standard if still empty
          if (!ids.length) ids = [1];

          // 4) Build display objects with friendly names
          let labels = {};
          try { labels = JSON.parse(localStorage.getItem('rateplan.customLabels') || '{}') || {}; } catch {}
          const items = ids.map(id => ({
            id,
            name: (id === 1) ? 'Standard'
                : (labels.CUS1 || labels.CUS2 || `Plan ${id}`)
          }));

          // 5) Ensure Standard is present when nothing else included
          if (!items.some(p => p.id === 1)) items.unshift({ id:1, name:'Standard' });

          // 6) Dedupe by id, preserving order
          const seen = new Set();
          return items.filter(p => (seen.has(p.id) ? false : (seen.add(p.id), true)));
        }

        const payload = window.__detailsPayload || {};
        const rooms = Array.isArray(payload.rooms) ? payload.rooms : [];

        function getPlanPriceForRoom(roomTypeId, ratePlanId) {
          const rid = Number(roomTypeId);
          const pid = Number(ratePlanId);

          try {
            const payload = window.__detailsPayload || {};
            const rooms = Array.isArray(payload.rooms) ? payload.rooms : [];

            const room = rooms.find(rm => {
              const rtId = rm.roomTypeId != null ? Number(rm.roomTypeId) : null;
              const id   = rm.id != null ? Number(rm.id) : null;
              return rtId === rid || id === rid;
            });
            if (!room) return null;

            // Backend already returns the correct per-plan nightly prices in room.daily for the requested ratePlanId.
            // So: use the minimum nightly price across the stay window.
            const daily = Array.isArray(room.daily) ? room.daily : [];
            const nums = daily
              .filter(d => d && !d.closed && Number(d.inventory ?? d.open ?? 0) > 0)
              .map(d => Number(d.price))
              .filter(Number.isFinite);

            if (!nums.length) return null;
            return Math.min.apply(null, nums);
          } catch (e) {
            console.warn("[getPlanPriceForRoom] failed", e);
            return null;
          }
        }

        // Ensure helper is available globally
        window.getPlanPriceForRoom = getPlanPriceForRoom;

        const openRooms = rooms
          .map(r => {
            const daily = Array.isArray(r.daily) ? r.daily : [];
            const openNights = daily.filter(
              d => !d.closed && Number(d.inventory ?? d.open ?? 0) > 0
            );
            const minPrice = openNights.length
              ? Math.min(...openNights.map(d => Number(d.price ?? Infinity)))
              : null;
            return { room: r, openNights, minPrice };
          })
          .filter(x => x.openNights.length > 0);

        const hadRooms = Array.isArray(payload.rooms) && payload.rooms.length > 0;

        // Update the big right-hand "From" price to the lowest across all open rooms
        try {
          const globalMin = openRooms.reduce((acc, x) => {
            const p = Number(x.minPrice);
            if (!Number.isFinite(p)) return acc;
            return acc == null ? p : Math.min(acc, p);
          }, null);
          if (typeof fromEl !== 'undefined' && fromEl && globalMin != null) {
            fromEl.textContent = money(globalMin);
          }
        } catch (_) {}

        if (!openRooms.length){
          const msg = hadRooms
            ? 'No room categories with open inventory for these dates.'
            : 'Online booking is not yet available for this property. Please check back soon.';

          listEl.innerHTML = `
            <div class="small" style="color:var(--muted); padding:4px 0;">
              ${msg}
            </div>`;
          return;
        }

        const ph = (label='Room') => 'data:image/svg+xml;utf8,' + encodeURIComponent(
          `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 270">
            <rect width="400" height="270" fill="#f3f4f6"/>
            <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle"
              font-family="Inter, Arial, sans-serif" font-size="16" fill="#9ca3af">${label}</text>
          </svg>`);

        const plans = derivePlansForDisplay(); // [{id,name}, …]

        function planRowsHTML(roomId) {
        // Fixed 3 core plans, in the order you want to show them
        const basePlans = [
          { id: 1, label: 'Standard',       desc: 'Flexible standard rate with free cancellation.' },
          { id: 2, label: 'Non-refundable', desc: 'Lower price, no refunds or changes.' },
          { id: 3, label: 'With Breakfast', desc: 'This rate includes breakfast for 2.' }
        ];

        const plansQS = '';

        // Try to get the Standard plan price from the payload
        const stdFromBackend = getPlanPriceForRoom(roomId, 1);
        const baseStd = stdFromBackend != null && Number.isFinite(Number(stdFromBackend))
          ? Number(stdFromBackend)
          : null;

        const rows = basePlans.map(p => {
          // First choice: use backend per-plan price if present
          let rawPrice = getPlanPriceForRoom(roomId, p.id);
          let numPrice = rawPrice != null ? Number(rawPrice) : null;

          // Fallback: derive per-plan price from Standard using your rules
          if (numPrice == null || !Number.isFinite(numPrice)) {
            if (baseStd != null) {
              if (p.id === 1) {
                // Standard: base price
                numPrice = baseStd;
              } else if (p.id === 2) {
                // Non-refundable: -10 percent
                numPrice = Math.round(baseStd * 0.9 * 100) / 100;
              } else if (p.id === 3) {
                // With Breakfast: +10
                numPrice = baseStd + 10;
              }
            }
          }
            const hasPrice = numPrice != null && Number.isFinite(numPrice);
            const priceLabel = hasPrice ? money(numPrice) : null;
            const priceHtml = hasPrice
              ? `<div class="meta"><strong>${priceLabel}</strong> / night</div>`
              : '';

            const url =
              `/checkout.html?propertyId=${encodeURIComponent(propertyId)}` +
              `&roomId=${encodeURIComponent(roomId)}` +
              `&start=${encodeURIComponent(start)}` +
              `&end=${encodeURIComponent(end)}` +
              `&ratePlanId=${encodeURIComponent(p.id)}` +
              `&planLabel=${encodeURIComponent(p.label)}` +
              `${plansQS}`;

            return `
              <div class="planrow" data-plan-id="${p.id}">
                <div>
                  <div class="planname">${p.label}</div>
                  <div class="meta">${p.desc}</div>
                  ${priceHtml}
                </div>
                <a class="roomcat-plan-btn"
                    href="${url}"
                    aria-label="Book now with this rate"
                  >
                    Book now
                  </a>
              </div>`;
          }).join('');

          return rows;
        }
     
        listEl.innerHTML = openRooms.map(({ room, minPrice }) => {
          const rid = room.roomTypeId ?? room.typeId ?? room.id ?? room.roomId ?? room.code ?? '';
          const name = String(room.name ?? 'Room').trim() || 'Room';
          // Prefer room-level images; fall back to property-level/detail images; then placeholder
          let thumb = null;
          if (Array.isArray(room.images) && room.images.length) {
            thumb = room.images[0]?.url || room.images[0] || null;
          }
          if (!thumb) {
            try {
              const payload = window.__detailsPayload || {};
              if (Array.isArray(payload.images) && payload.images.length) {
                const it = payload.images[0];
                thumb = (typeof it === "string")
                  ? it
                  : (it?.url || it?.photoUrl || it?.imageUrl || it?.src || it?.href || null);
              }
            } catch {}
          }
          if (!thumb && Array.isArray(images) && images.length) {
            const it = images[0];
            thumb = (typeof it === "string")
              ? it
              : (it?.url || it?.photoUrl || it?.imageUrl || it?.src || it?.href || null);
          }
          if (!thumb) {
            thumb = ph(name);
          }

          // Transparent nightly pricing for this room within the search window
          const daily = Array.isArray(room.daily) ? room.daily : [];
          const pricedNights = daily
            .filter(d => !d?.closed && Number(d?.inventory ?? d?.open ?? 0) > 0)
            .map(d => {
              if (!d) return NaN;
              if ("price" in d) return Number(d.price);
              if ("amount" in d) return Number(d.amount);
              if ("basePrice" in d) return Number(d.basePrice);
              return NaN;
            })
            .filter(Number.isFinite);

          let avg = null, min = null, max = null;
          if (pricedNights.length) {
            const sum = pricedNights.reduce((s, v) => s + v, 0);
            avg = sum / pricedNights.length;
            min = Math.min(...pricedNights);
            max = Math.max(...pricedNights);
          }

          const m2 = room.areaM2 ?? room.areaSqm ?? null;
          const ft2 = room.areaFt2 ?? (m2 ? Math.round(m2 * 10.7639) : null);
          const m2txt = m2 ? `${m2} m²` : '';
          const ft2txt = ft2 ? `${ft2} ft²` : '';
          const area = (m2txt || ft2txt) ? ` · ${[m2txt, ft2txt].filter(Boolean).join(' / ')}` : '';

          let priceMeta;
          if (avg != null && isFinite(avg)) {
            const avgStr = `$${avg.toFixed(2)}`;
            if (min != null && max != null && isFinite(min) && isFinite(max) && min !== max) {
              priceMeta = `Avg ${avgStr} per night (range $${min.toFixed(2)}–$${max.toFixed(2)})`;
            } else {
              priceMeta = `Avg ${avgStr} per night`;
            }
          } else {
            priceMeta = 'Price unavailable for these dates';
          }

          return `
            <div class="roomcat" data-room-id="${rid}" data-available-rooms="${Number(room.availableRooms ?? 0)}">
            ${ (plans && plans.length >= 1)
                ? `<button class="toggle" type="button" aria-expanded="false" aria-label="Show plans" tabindex="0" role="button">+</button>`
                : `<span class="visually-hidden">Single rate plan</span>` }

            <img src="${thumb}" alt="${name} thumbnail" loading="lazy" decoding="async">
            <div>
              <h3>${name}</h3>
              <div class="meta">${priceMeta}${area}</div>
            </div>

            <a class="btn-select"
              href="/checkout.html?propertyId=${encodeURIComponent(String(propertyId))}&start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}&ratePlanId=${
                encodeURIComponent((() => { try {
                  const u = new URL(location.href);
                  const p = u.searchParams.get('ratePlanId') || u.searchParams.get('plan');
                  if (p && Number.isFinite(Number(p))) return String(Number(p));
                  const last = Number(localStorage.getItem('rateplan.lastPlanId') || '');
                  return Number.isFinite(last) ? String(last) : '1';
                } catch(_) { return '1'; } })())
              }"
              aria-label="Select ${name}">Select</a>

            ${ (plans && plans.length >= 1)
                ? `<div class="planlist" aria-label="Rate plans for ${name}">
                    ${planRowsHTML(rid)}
                  </div>`
                : `` }
          </div>
        `;
        }).join('');

        setTimeout(() => {
          try { hydratePlansFromPartners?.(); }
          catch (e) { console.warn('[hydrate] after render failed', e); }
        }, 0);

        // (no MutationObserver auto-rehydrate block here anymore)

        // ANCHOR: PARTNER_HYDRATE_AFTER_RENDER
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            try { hydratePlansFromPartners?.(); } catch (e) { console.warn('[hydrate] failed', e); }
          });
        });

        // === Persist expand/collapse per property+room (session only) ===
        const EXPAND_KEY = `details.expand.${propertyId}`;
        function loadExpandMap(){
          try { return JSON.parse(sessionStorage.getItem(EXPAND_KEY) || '{}') || {}; } catch { return {}; }
        }
        function saveExpandMap(map){
          try { sessionStorage.setItem(EXPAND_KEY, JSON.stringify(map || {})); } catch {}
        }
        function applyExpandedFromStorage(){
          const map = loadExpandMap();
          document.querySelectorAll('#roomCats .roomcat').forEach(cat => {
            const rid = cat.getAttribute('data-room-id');
            if (!rid) return;
            if (map[rid]) {
              const panel = cat.querySelector('.planlist');
              const toggle = cat.querySelector('.toggle');
              if (panel) panel.classList.add('open');
              if (toggle) { toggle.setAttribute('aria-expanded','true'); toggle.textContent = '−'; }
            }
          });
        }
        applyExpandedFromStorage();

        // === Partner-managed rate plans: hydrate per-room plan names/ids ===
        window.hydratePlansFromPartners = async function hydratePlansFromPartners(){
          // helpers
          function selectedIds(){
            try {
              const a = JSON.parse(localStorage.getItem('rateplan.selectedIds') || '[]');
              return Array.isArray(a) ? a.map(Number).filter(Number.isFinite) : [];
            } catch { return []; }
          }
          function customLabels(){
            try { return JSON.parse(localStorage.getItem('rateplan.customLabels') || '{}') || {}; }
            catch { return {}; }
          }
          function labelFor(plan){
            const code = String(plan.code || '').toUpperCase();
            const lbls = customLabels(); // { CUS1: "...", CUS2: "..." }

            // Partner overrides
            if (code === 'CUS1' && lbls.CUS1) return lbls.CUS1;
            if (code === 'CUS2' && lbls.CUS2) return lbls.CUS2;

            // Built-ins
            if (code === 'STD' || Number(plan.id) === 1) return 'Standard';
            if (code === 'BRKF' || /breakfast/i.test(plan.name || '')) return 'With Breakfast';
            if (code === 'NRF' || /non[-\s]?ref/i.test(plan.name || '')) return 'Non-refundable';

            // Fallback
            return String(plan.name || plan.code || `Plan ${plan.id}`);
          }

          function describePlan(plan){
            const label = labelFor(plan);

            if (/non[-\s]?ref/i.test(label)) {
              return 'Lower price, no refunds or changes.';
            }
            if (/with breakfast/i.test(label)) {
              return 'This rate includes breakfast for 2.';
            }
            if (/standard/i.test(label)) {
              return 'Flexible standard rate with free cancellation.';
            }
            return 'Standard conditions apply for this rate.';
          }

          function planSortKey(plan){
            const label = labelFor(plan);

            if (/non[-\s]?ref/i.test(label))   return 1; // cheapest
            if (/standard/i.test(label))       return 2;
            if (/with breakfast/i.test(label)) return 3; // most expensive

            return 99; // unknown / custom at the end
          }

          async function fetchPlans(roomId){
            if (!roomId) return [];
            const rid = String(roomId).trim();

            // include propertyId and send cookies for auth
            const url = `/extranet/property/rateplans?propertyId=${encodeURIComponent(propertyId)}&roomTypeId=${encodeURIComponent(rid)}`;

            try {
              const fetcher = (typeof window.authFetch === 'function') ? window.authFetch : fetch;

              // Token headers (Render endpoints expect these)
              let token = '';
              try { token = localStorage.getItem('partnerToken') || localStorage.getItem('lolaelo_session') || ''; } catch(_){}
              const headers = token ? { 'Authorization': 'Bearer ' + token, 'x-partner-token': token } : {};

              const r = await fetcher(url, {
                method: 'GET',
                cache: 'no-store',
                credentials: 'include',
                headers
              });

              if (!r.ok) throw new Error(`HTTP ${r.status}`);

              const j = await r.json();
              const raw = Array.isArray(j) ? j : (j.rows || j.plans || j.data || j.result || []);

              const parsed = raw
                .map(p => {
                  const id = Number(p.id ?? p.ratePlanId ?? p.rate_plan_id);
                  const code = String(p.code ?? p.ratePlanCode ?? p.rate_plan_code ?? "").toUpperCase();
                  const name = (p.name ?? p.label ?? p.code ?? `Plan ${p.id ?? p.ratePlanId ?? ""}`) + "";

                  const kind = String(p.kind ?? "NONE").toUpperCase();
                  const value = Number(p.value ?? 0);           // numeric may come as string
                  const active = (p.active === true);
                  const isDefault = (p.isDefault === undefined) ? false : Boolean(p.isDefault);

                  return { id, code, name, kind, value, active, isDefault };
                })
                .filter(p => Number.isFinite(p.id) && p.code);

                // Cache plan meta by id for modal + label resolution
                try {
                  window.__ratePlanMetaById = window.__ratePlanMetaById || {};
                  for (const p of parsed){
                    window.__ratePlanMetaById[String(p.id)] = {
                      id: p.id,
                      code: p.code,
                      name: p.name,
                      active: p.active,
                      kind: p.kind,
                      value: p.value,
                      isDefault: p.isDefault
                    };
                  }
                } catch(_){}

              if (!parsed.length) {
                console.warn('[hydratePlansFromPartners] no usable rateplans for room', rid);
              }

              return parsed;
            } catch (err) {
              console.warn('[hydratePlansFromPartners] fetchPlans failed for room', rid, err);
              return [];
            }
          }

          function applyPlanRule(basePrice, plan){
            const base = Number(basePrice);
            if (!Number.isFinite(base)) return null;

            const kind = String(plan?.kind || 'NONE').toUpperCase();
            const rawVal = (plan?.value == null) ? 0 : Number(plan.value);
            const val = Number.isFinite(rawVal) ? rawVal : 0;

            if (kind === 'ABSOLUTE') return Math.max(0, base + val);
            if (kind === 'PERCENT')  return Math.max(0, base * (1 + (val / 100)));
            return Math.max(0, base);
          }

          function renderPlanRows(roomId, plans){
            const sel = selectedIds(); // keep only for checkout URL params
            const plansQS = sel.length ? `&plans=${encodeURIComponent(sel.join(','))}` : '';

            // DB owns which plans are available to travelers
            const rowsSource = plans.filter(p => p && p.active === true);

            if (!rowsSource.length) return '';

            const { propertyName, propertyLocation } = getCheckoutMeta();
            const roomName = getRoomNameForCheckout(roomId);

            // availability is stored on the roomcat DOM node by Step B
            const maxAvail = getAvailForRoom(roomId);

            const rows = rowsSource.map(p => {
              const name = labelFor(p);
              const desc = describePlan(p);

              // Base nightly price should come from Standard, then apply rule per plan (kind/value)
              const stdId = (() => {
                try {
                  if (String(p.code || '').toUpperCase() === 'STD') return Number(p.id);
                  const byRoom = window.__ratePlansByRoom && window.__ratePlansByRoom[String(roomId)];
                  if (Array.isArray(byRoom)) {
                    const std = byRoom.find(x => String(x.code || '').toUpperCase() === 'STD');
                    const n = Number(std && std.id);
                    if (Number.isFinite(n)) return n;
                  }
                } catch(_) {}
                return Number(p.id); // fallback
              })();

              // Base = Standard nightly, fallback to this plan's nightly if STD missing
              if (!Number.isFinite(Number(stdId))) stdId = Number(p.id);

              let baseRaw = getPlanPriceForRoom(roomId, stdId);
              if (!(baseRaw != null && Number.isFinite(Number(baseRaw)))) {
                baseRaw = getPlanPriceForRoom(roomId, Number(p.id));
              }

              const baseOk = baseRaw != null && Number.isFinite(Number(baseRaw));
              const adjRaw = baseOk ? applyPlanRule(Number(baseRaw), p) : null;

              const hasPrice = adjRaw != null && Number.isFinite(Number(adjRaw));
              const priceLabel = hasPrice ? money(Number(adjRaw).toFixed(2)) : null;
              const priceHtml = hasPrice ? `<div class="meta"><strong>${priceLabel}</strong> / night</div>` : '';

              // current qty (default 1 when maxAvail > 0)
              const key = qpKey(roomId, p.id);

              // pull saved qty (or 0), clamp to [0..maxAvail]
              let cur = clampInt(qtyByRoomPlanKey[key] ?? 0, 0, maxAvail);

              // if nothing selected yet, default to 1 (only if rooms exist)
              if (!(Number.isFinite(Number(cur)) && Number(cur) > 0)) {
                cur = (maxAvail > 0 ? 1 : 0);
              }

              // build qty options 0..maxAvail
              let opts = "";
              for (let i = 0; i <= maxAvail; i++){
                opts += `<option value="${i}" ${i === cur ? "selected" : ""}>${i}</option>`;
              }

              const url =
                `/checkout.html?propertyId=${encodeURIComponent(propertyId)}` +
                `&propertyName=${encodeURIComponent(propertyName)}` +
                (propertyLocation ? `&propertyLocation=${encodeURIComponent(propertyLocation)}` : '') +
                `&roomId=${encodeURIComponent(roomId)}` +
                `&roomName=${encodeURIComponent(roomName)}` +
                `&start=${encodeURIComponent(start)}` +
                `&end=${encodeURIComponent(end)}` +
                `&ratePlanId=${encodeURIComponent(p.id)}` +
                `&planLabel=${encodeURIComponent(name)}` +
                `${plansQS}` +
                `&qty=${encodeURIComponent(cur)}`;

              // NOTE: pure string concatenation to avoid nested template literal issues
              return (
                `<div class="planrow" data-plan-id="${p.id}">` +

                  `<div class="planinfo">` +
                    `<div class="planname">${name}</div>` +
                    `<div class="meta">${desc}</div>` +
                    `${priceHtml}` +
                  `</div>` +

                  `<div class="plan-actions">` +
                    `<div class="qty-inline">` +

                      `<div class="qty-avail-pill">Available Rooms: <span class="qty-avail-val"> ${maxAvail}</span></div>` +

                      `<div class="qty-pick-pill">` +
                        `<label class="qty-label" for="qty_${roomId}_${p.id}">Qty</label>` +
                        `<select class="qty-select" id="qty_${roomId}_${p.id}" data-room-id="${roomId}" data-plan-id="${p.id}">` +
                          `${opts}` +
                        `</select>` +
                      `</div>` +

                    `</div>` +

                    `<a class="roomcat-plan-btn" href="${url}" aria-label="Book now with this rate">Book now</a>` +
                  `</div>` +

                `</div>`
              );
            }).join('');

            return rows;
          }

          // === HYDRATE_LOOP_BEGIN (drop-in replacement) ===
          async function waitForCats(maxTries = 20){
            for (let i = 0; i < maxTries; i++){
              const nodes = document.querySelectorAll('#roomCats .roomcat');
              if (nodes.length) return nodes;
              await new Promise(r => setTimeout(r, 100));
            }
            return document.querySelectorAll('#roomCats .roomcat');
          }

          // Pull room ids from the payload (authoritative) and wait for DOM rows
          const payloadRoomIds = (Array.isArray(j?.rooms) ? j.rooms : [])
            .map(r =>
              r.roomTypeId ?? r.typeId ?? r.id ?? r.roomId ?? r.code
            )
            .filter(Boolean)
            .map(v => String(v));

          await waitForCats();

          for (const ridRaw of payloadRoomIds){
            const rid = String(ridRaw);
            const selector = `#roomCats .roomcat[data-room-id="${CSS.escape(rid)}"]`;
            const cat = document.querySelector(selector);
            if (!cat) continue;

            let panel = cat.querySelector('.planlist');
            if (!panel){
              panel = document.createElement('div');
              panel.className = 'planlist';
              panel.setAttribute('aria-label', 'Rate plans');
              cat.appendChild(panel);
            }

            let plans = await fetchPlans(rid);        // [{id,code,name}]

            if (!plans.length) continue;

            // sync with locally stored partner state (selectedIds/customLabels)
            try {
              const sel = JSON.parse(localStorage.getItem('rateplan.selectedIds') || '[]');
              const lbls = JSON.parse(localStorage.getItem('rateplan.customLabels') || '{}') || {};

              plans.forEach(p => {
                if (p.code === 'CUS1' && lbls.CUS1) p.name = lbls.CUS1;
                if (p.code === 'CUS2' && lbls.CUS2) p.name = lbls.CUS2;
              });
            } catch {}

            // DB owns which plans are available to travelers
            plans = plans.filter(p => p && p.active === true);

            // Cache per-room plans for modal + reuse
            try {
              window.__ratePlansByRoom = window.__ratePlansByRoom || {};
              window.__ratePlansByRoom[String(rid)] = Array.isArray(plans) ? plans.slice() : [];
            } catch(_){}

            if (!plans.length) continue;

            panel.innerHTML = renderPlanRows(rid, plans);          // render rows
            // wire qty selects inside this panel
            panel.querySelectorAll('.qty-select').forEach(selEl => {
              selEl.addEventListener('change', (e) => {
                const el = e.currentTarget;
                const roomId = String(el.getAttribute('data-room-id') || '');
                const planId = String(el.getAttribute('data-plan-id') || '');
                const max = getAvailForRoom(roomId);
                const qty = clampInt(el.value, 0, max);

                const key = qpKey(roomId, planId);
                qtyByRoomPlanKey[key] = qty;

                // update the adjacent Book now link inside the same planrow
                const row = el.closest('.planrow');
                const a = row ? row.querySelector('a.roomcat-plan-btn') : null;
                if (a && a.getAttribute('href')) {
                  const href = a.getAttribute('href');
                  const base = href.replace(/([?&])qty=\d+(&?)/, (m, p1, p2) => (p2 ? p1 : ''));
                  const join = base.includes('?') ? '&' : '?';
                  a.setAttribute('href', `${base}${join}qty=${encodeURIComponent(qty)}`);
                }

                // Persist normalized selection object (groundwork for cart later)
                try {
                  const selKey = "checkout.selection.v1";

                  // Read existing selection, or create new
                  let selObj = null;
                  try { selObj = JSON.parse(localStorage.getItem(selKey) || "null"); } catch (_) { selObj = null; }

                  if (!selObj || typeof selObj !== "object") {
                    selObj = { propertyId: String(propertyId), start: String(start), end: String(end), items: [] };
                  }

                  // Always keep these aligned to current page context
                  selObj.propertyId = String(propertyId);
                  selObj.start = String(start);
                  selObj.end = String(end);
                  if (!Array.isArray(selObj.items)) selObj.items = [];

                  const roomTypeId = String(roomId);
                  const ratePlanId = String(planId);

                  // Pull labels from DOM for accuracy
                  const row = el.closest(".planrow");
                  const planLabel = row && row.querySelector(".planname") ? row.querySelector(".planname").textContent.trim() : "";
                  const roomName = (typeof getRoomNameForCheckout === "function") ? String(getRoomNameForCheckout(roomTypeId) || "") : "";

                  // Upsert or delete item
                  const idx = selObj.items.findIndex(it => String(it.roomTypeId) === roomTypeId && String(it.ratePlanId) === ratePlanId);

                  if (qty <= 0) {
                    if (idx >= 0) selObj.items.splice(idx, 1);
                  } else {
                    const item = { roomTypeId, ratePlanId, qty: Number(qty), roomName, planLabel };
                    if (idx >= 0) selObj.items[idx] = item;
                    else selObj.items.push(item);
                  }

                  localStorage.setItem(selKey, JSON.stringify(selObj));
                  console.log("[details][qty][persist] saved", selObj);
                } catch (e) {
                  console.warn("[details][qty][persist] failed", e);
                }

                console.log('[details][qty] set', { roomId, planId, qty, max });
              });
            });

            // === Qty guard: block Book now when qty <= 0 (inline + modal) ===
            function flashQtyError(selectEl){
              if (!selectEl) return;

              // Highlight ONLY the outer pill, not the <select>
              const pill =
                selectEl.closest(".qty-pick-pill") ||
                selectEl.closest(".qty-pick") ||
                selectEl.parentElement;

              if (!pill) return;

              if (pill) pill.classList.add("is-error");
              // ensure inner select never gets the error class (prevents double outline)
              selectEl.classList.remove("is-error");

              try { selectEl.focus(); } catch(_){}

              window.clearTimeout(flashQtyError._t);
              flashQtyError._t = window.setTimeout(() => {
                if (pill) pill.classList.remove("is-error");
              }, 1400);
            }

            document.addEventListener("click", (e) => {
              const btn = e.target.closest(".roomcat-plan-btn, .plan-book-btn, .modal-plan-book-btn");
              if (!btn) return;

              const scope =
                btn.closest(".planrow") ||
                btn.closest(".plan-card") ||
                btn.closest(".modal-plan-card") ||
                btn.closest(".roomcat-card") ||
                btn.closest("[data-plan-id]") ||
                btn.parentElement;

              const sel = scope ? scope.querySelector("select.qty-select") : null;
              const qty = sel ? (Number.parseInt(String(sel.value || "0"), 10) || 0) : 0;

              if (qty <= 0) {
                e.preventDefault();
                e.stopPropagation();
                flashQtyError(sel);
              }
            }, true);

            panel.setAttribute('data-hydrated', 'true');           // mark as partner-authoritative
            panel.dataset.hydratedAt = String(Date.now());         // (optional) timestamp for debugging

            // Update the top-right Select link to primary (cheapest) in-scope plan
            const selIds = (function(){
              try {
                const a = JSON.parse(localStorage.getItem('rateplan.selectedIds') || '[]');
                return Array.isArray(a) ? a.map(Number).filter(Number.isFinite) : [];
              } catch { return []; }
            })();
            const plansQS = selIds.length ? `&plans=${encodeURIComponent(selIds.join(','))}` : '';

            let inScopeTop = selIds.length ? plans.filter(p => selIds.includes(p.id)) : plans.slice();
            if (!inScopeTop.length) {
              inScopeTop = [{ id:1, code:'STD', name:'Standard' }];
            }

            const sortedTop = inScopeTop.slice().sort((a, b) => {
              const pa = planSortKey(a);
              const pb = planSortKey(b);
              if (pa !== pb) return pa - pb;
              return (Number(a.id) || 0) - (Number(b.id) || 0);
            });

            const primary = sortedTop[0] || { id:1 };

            const topLink = cat.querySelector(".btn-select");
            if (topLink) {
              const { propertyName, propertyLocation } = getCheckoutMeta();
              const roomName  = getRoomNameForCheckout(rid);
              const planLabel = primary && (primary.name || primary.code || "");

              // CART v1 (Secondary Sprint) - append behavior
              const CartV1 = (() => {
                if (window.__checkoutCartV1) return window.__checkoutCartV1;

                const CART_KEY = "checkout.cart.v1";
                const SELECTION_KEY = "checkout.selection.v1";

                const api = {
                  load() {
                    try {
                      const raw = localStorage.getItem(CART_KEY) || "";
                      const obj = raw ? JSON.parse(raw) : null;
                      if (!obj || typeof obj !== "object") return null;
                      if (obj.version !== 1) return null;
                      if (!Array.isArray(obj.items)) obj.items = [];
                      return obj;
                    } catch (_) {
                      return null;
                    }
                  },

                  save(cart) {
                    try {
                      localStorage.setItem(CART_KEY, JSON.stringify(cart));
                      return true;
                    } catch (_) {
                      return false;
                    }
                  },

                  newCartWithItem(item) {
                    return {
                      version: 1,
                      createdAt: new Date().toISOString(),
                      itinerary: { policy: "continuous_or_adjacent", currency: "PHP" },
                      items: [item]
                    };
                  },

                  getQtyFromSelection(roomTypeId, ratePlanId) {
                    try {
                      const raw = localStorage.getItem(SELECTION_KEY) || "";
                      const sel = raw ? JSON.parse(raw) : null;
                      if (!sel || typeof sel !== "object") return 1;
                      if (!Array.isArray(sel.items)) return 1;

                      const rt = String(roomTypeId || "");
                      const rp = String(ratePlanId || "");
                      const hit = sel.items.find(it =>
                        String(it.roomTypeId) === rt && String(it.ratePlanId) === rp
                      );

                      const q = hit && hit.qty != null ? Number(hit.qty) : 1;
                      return Number.isFinite(q) ? q : 1;
                    } catch (_) {
                      return 1;
                    }
                  },

                  _day(ymd) {
                    // ymd expected: YYYY-MM-DD
                    if (!ymd || typeof ymd !== "string") return NaN;
                    const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(ymd.trim());
                    if (!m) return NaN;
                    const y = Number(m[1]), mo = Number(m[2]), d = Number(m[3]);
                    return Date.UTC(y, mo - 1, d) / 86400000; // integer day count
                  },

                  isContinuousOrAdjacent(items) {
                    const spans = items
                      .map(it => ({
                        s: this._day(it.start),
                        e: this._day(it.end)
                      }))
                      .filter(x => Number.isFinite(x.s) && Number.isFinite(x.e))
                      .sort((a, b) => a.s - b.s || a.e - b.e);

                    if (spans.length <= 1) return true;

                    let curEnd = spans[0].e;
                    for (let i = 1; i < spans.length; i++) {
                      const next = spans[i];
                      // allow overlap OR exact adjacency (next.start == curEnd)
                      if (next.s > curEnd) return false;
                      if (next.e > curEnd) curEnd = next.e;
                    }
                    return true;
                  },

                  tryAppend(item) {
                    const existing = this.load();
                    const cart = existing || this.newCartWithItem(item);

                    if (existing) {
                      cart.items = Array.isArray(cart.items) ? cart.items : [];
                      cart.items = cart.items.concat([item]);
                    }

                    if (!this.isContinuousOrAdjacent(cart.items)) {
                      return { ok: false, cart: existing || null };
                    }

                    this.save(cart);
                    return { ok: true, cart };
                  },

                  clearAndStart(item) {
                    const cart = this.newCartWithItem(item);
                    this.save(cart);
                    return cart;
                  }
                };

                window.__checkoutCartV1 = api;
                return api;
              })();

              // Look at the server payload first, fall back to the query param
              const payload = window.__detailsPayload || {};
              const pidRaw =
                payload && (payload.partnerId ?? payload.propertyId ?? payload.id ?? null);

              const checkoutPropertyId =
                pidRaw != null && pidRaw !== ""
                  ? String(pidRaw)
                  : (propertyId || "");

              // Build the checkout URL with a guaranteed propertyId
              const url = new URL("/checkout.html", location.origin);
              url.searchParams.set("propertyId", checkoutPropertyId);
              url.searchParams.set("propertyName", propertyName || "");
              if (propertyLocation) {
                url.searchParams.set("propertyLocation", propertyLocation);
              }
              url.searchParams.set("roomId", rid);
              url.searchParams.set("roomName", roomName || "");
              url.searchParams.set("start", start);
              url.searchParams.set("end", end);
              url.searchParams.set("ratePlanId", String(primary.id));
              if (planLabel) {
                url.searchParams.set("planLabel", planLabel);
              }

              // Keep your selected plan CSV if it exists
              if (plansQS && plansQS.startsWith("&plans=")) {
                const csv = plansQS.slice("&plans=".length);
                if (csv) {
                  url.searchParams.set("plans", csv);
                }
              }

              // Fallback bridge for checkout: remember last good propertyId
              try {
                if (checkoutPropertyId) {
                  localStorage.setItem("checkout.lastPropertyId", checkoutPropertyId);
                }
              } catch (_) {}

              try {
                localStorage.setItem("checkout.lastDetailsUrl", window.location.href);
              } catch (_) {}

              topLink.setAttribute("href", url.toString());

              // === CLEAR AFTER-SUCCESS LOCK WHEN ENTERING CATALOG DETAILS ===
              try { localStorage.removeItem("checkout.afterSuccessAt"); } catch (_) {}

              // Append-to-cart on click (do not overwrite). Guard against duplicate listeners.
              if (!topLink.dataset.cartBound) {
                topLink.dataset.cartBound = "1";

                topLink.addEventListener("click", (e) => {
                  // Build the line item from the same context used to build the checkout URL

                  const lineId =
                    "ln_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2, 8);

                  const qty = CartV1.getQtyFromSelection(rid, String(primary.id));

                  // Enforce primary-sprint rule: block only when qty=0 (scoped to this click)
                  if (!qty || Number(qty) <= 0) {
                    e.preventDefault();
                    alert("Please select at least 1 room.");
                    return;
                  }

                  const item = {
                    lineId,
                    propertyId: String(checkoutPropertyId || ""),
                    propertyName: String(propertyName || ""),
                    propertyLocation: String(propertyLocation || ""),
                    roomTypeId: String(rid || ""),
                    roomName: String(roomName || ""),
                    ratePlanId: String(primary.id),
                    planLabel: String(planLabel || ""),
                    qty: Number(qty),
                    start: String(start || ""),
                    end: String(end || "")
                  };

                  // Try to append. If continuity breaks, prompt for next action.
                  const res = CartV1.tryAppend(item);

                  if (!res.ok) {
                    e.preventDefault();

                    const msg =
                      "This checkout supports one trip at a time. Multiple hotels are allowed only if dates are continuous or back-to-back.\n\n" +
                      "Choose:\n" +
                      "1 = Finish current trip (go to checkout, do not add)\n" +
                      "2 = Clear cart and start new trip\n" +
                      "3 = Cancel";

                    const choice = (window.prompt(msg, "3") || "").trim();

                    if (choice === "1") {
                      window.location.href = url.toString();
                      return;
                    }
                    if (choice === "2") {
                      CartV1.clearAndStart(item);
                      window.location.href = url.toString();
                      return;
                    }
                    // cancel: do nothing
                    return;
                  }

                  // On success, proceed to checkout (cart persists)
                  // Let the link navigate normally.
                });
              }

              console.log("[details→checkout] building href (final)", {
                checkoutPropertyId,
                href: url.toString()
              });
            }

            // Keep the toggle visible on details page as long as there is at least one plan.
            const hasAnyPlan = plans.length > 0;
            let toggle = cat.querySelector('.toggle');

            if (hasAnyPlan && !toggle) {
              // Re-create the button if markup was missing
              toggle = document.createElement('button');
              toggle.className = 'toggle';
              toggle.type = 'button';
              toggle.setAttribute('aria-expanded', 'false');
              toggle.setAttribute('aria-label', 'Show plans');
              toggle.textContent = '+';
              cat.insertBefore(toggle, cat.firstElementChild);
            } else if (!hasAnyPlan && toggle) {
              // Only strip the toggle if we truly have zero plans
              toggle.replaceWith(document.createElement('span'));
            }
          }
          // === HYDRATE_LOOP_END ===
        };
        hydratePlansFromPartners().catch(()=>{});

        // Re-hydrate when returning from partners hub or when labels/selection change
        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'visible') {
            // re-run the partner plan hydration to pick up latest state
            (async () => { try { await (async function(){ await hydratePlansFromPartners?.(); })(); } catch(_){} })();
          }
        });

        // Also react to cross-tab/local edits (selectedIds, customLabels)
        window.addEventListener('storage', (e) => {
          if (!e) return;
          if (e.key === 'rateplan.selectedIds' || e.key === 'rateplan.customLabels') {
            (async () => { try { await (async function(){ await hydratePlansFromPartners?.(); })(); } catch(_){} })();
          }
        });

        // Persist last chosen plan when any "Select" is clicked
        listEl.addEventListener('click', (e) => {
          const link = e.target.closest('.planrow .btn-select, .roomcat > .btn-select');
          if (!link) return;

          try {
            // Prefer data-plan-id from plan rows; otherwise read from link href
            const row = e.target.closest('.planrow');
            let pid = row ? Number(row.getAttribute('data-plan-id')) : NaN;
            if (!Number.isFinite(pid)) {
              const u = new URL(link.href, location.href);
              pid = Number(u.searchParams.get('ratePlanId'));
            }
            if (Number.isFinite(pid)) {
              localStorage.setItem('rateplan.lastPlanId', String(pid));
              // optional: mirror into selectedIds if partner has none
              const sel = JSON.parse(localStorage.getItem('rateplan.selectedIds') || '[]');
              if (Array.isArray(sel) && !sel.map(Number).includes(pid)) {
                localStorage.setItem('rateplan.selectedIds', JSON.stringify([...sel, pid]));
              }
            }
          } catch {}
        });

        /* Toggle open/closed with mouse */
        listEl.addEventListener('click', (e) => {
          const t = e.target.closest('.toggle');
          if (!t) return;
          const cat = t.closest('.roomcat');
          const panel = cat.querySelector('.planlist');
          if (!panel) return;
          const open = panel.classList.toggle('open');

          // close any other open room panels (accordion behavior)
          if (open) {
            document.querySelectorAll('#roomCats .roomcat .planlist.open').forEach(pl => {
              if (pl === panel) return;
              pl.classList.remove('open');
              pl.setAttribute('aria-hidden','true');
              const btn = pl.closest('.roomcat')?.querySelector('.toggle');
              if (btn){
                btn.setAttribute('aria-expanded','false');
                btn.setAttribute('aria-label','Show plans');
                btn.textContent = '+';
              }
              // keep persistence in sync for the room we just closed
              const rid2 = pl.closest('.roomcat')?.getAttribute('data-room-id');
              if (rid2){
                const map = loadExpandMap();
                map[rid2] = false;
                saveExpandMap(map);
              }
            });
          }

          panel.setAttribute('aria-hidden', open ? 'false' : 'true');
          t.setAttribute('aria-expanded', open ? 'true' : 'false');
          t.setAttribute('aria-label', open ? 'Hide plans' : 'Show plans');
          t.textContent = open ? '−' : '+';
          if (open) { cat.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); }

          // persist expanded state (sessionStorage)
          const rid = cat.getAttribute('data-room-id');
          const map = loadExpandMap();
          map[rid] = !!open;
          saveExpandMap(map);
        });
     
        /* Also support keyboard (Enter/Space) on the toggle */
        listEl.addEventListener('keydown', (e) => {
          const t = e.target.closest('.toggle');
          if (!t) return;
          if (e.key !== 'Enter' && e.key !== ' ') return;
          e.preventDefault();
          const cat = t.closest('.roomcat');
          const panel = cat.querySelector('.planlist');
          if (!panel) return;
          const open = panel.classList.toggle('open');

          // close any other open room panels (accordion behavior)
          if (open) {
            document.querySelectorAll('#roomCats .roomcat .planlist.open').forEach(pl => {
              if (pl === panel) return;
              pl.classList.remove('open');
              pl.setAttribute('aria-hidden','true');
              const btn = pl.closest('.roomcat')?.querySelector('.toggle');
              if (btn){
                btn.setAttribute('aria-expanded','false');
                btn.setAttribute('aria-label','Show plans');
                btn.textContent = '+';
              }
              // keep persistence in sync for the room we just closed
              const rid2 = pl.closest('.roomcat')?.getAttribute('data-room-id');
              if (rid2){
                const map = loadExpandMap();
                map[rid2] = false;
                saveExpandMap(map);
              }
            });
          }

          panel.setAttribute('aria-hidden', open ? 'false' : 'true');
          t.setAttribute('aria-expanded', open ? 'true' : 'false');
          t.setAttribute('aria-label', open ? 'Hide plans' : 'Show plans');
          t.textContent = open ? '−' : '+';
          if (open) { cat.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); }

          // persist expanded state (sessionStorage)
          const rid = cat.getAttribute('data-room-id');
          const map = loadExpandMap();
          map[rid] = !!open;
          saveExpandMap(map);
        });

        // ANCHOR: ROOM_MODAL_CLICK_WIRE
        listEl.addEventListener('click', (e) => {
          const btn = e.target.closest('.planrow .btn-select, .roomcat > .btn-select');
          if (!btn) return;

          // We are handling this click for the modal, so stop navigation
          e.preventDefault();

          const cat = btn.closest('.roomcat');
          if (!cat) return;

          const rid = cat.getAttribute('data-room-id') || '';
          const payload = window.__detailsPayload || {};
          const rooms = Array.isArray(payload.rooms) ? payload.rooms : [];

          // Match room by the same id mapping used elsewhere
          const room = rooms.find(r => {
            const cand =
              r.roomTypeId ?? r.typeId ?? r.id ?? r.roomId ?? r.code ?? '';
            return String(cand) === String(rid);
          }) || null;

          // Pull plan info if this is inside a planrow
          let planId = null;
          let planLabel = null;

          const row = btn.closest('.planrow');
          if (row) {
            const pid = Number(row.getAttribute('data-plan-id'));
            if (Number.isFinite(pid)) planId = pid;

            const nameEl = row.querySelector('.planname');
            if (nameEl) planLabel = String(nameEl.textContent || '').trim() || null;
          }

          // Fallback: derive planId from href if not on a planrow
          if (!planId && btn.href) {
            try {
              const u = new URL(btn.href, location.href);
              const p = Number(u.searchParams.get('ratePlanId'));
              if (Number.isFinite(p)) planId = p;
            } catch {}
          }

          if (!planLabel && planId) {
            planLabel = `Plan ${planId}`;
          }

          const ctx = { room, roomId: rid, planId, planLabel };

          if (typeof window.openRoomModal === 'function') {
          console.log('[modal] ctx.room keys:', ctx.room ? Object.keys(ctx.room) : null, ctx.room);
            window.openRoomModal(ctx.room || null);
          } else {
            console.log('[room-modal] handler: openRoomModal missing, ctx=', ctx);
          }
        });

        // When the top-right "Select" button is clicked, open the room modal instead of navigating
        listEl.addEventListener('click', (e) => {
          const btn = e.target.closest('.roomcat > .btn-select');
          if (!btn) return;

          const cat = btn.closest('.roomcat');
          const rid = cat ? cat.getAttribute('data-room-id') : null;
          if (!rid) return;

          e.preventDefault();
          e.stopPropagation();

          if (typeof window.openRoomModalById === 'function') {
            window.openRoomModalById(rid);
          }
        });

        // Persist chosen plan and ensure href has canonical params (+ propertyId + &plans=)
        listEl.addEventListener("click", (e) => {
          const a = e.target.closest(".planrow .btn-select, .roomcat > .btn-select");
          if (!a) return;

          try {
            // 1) Persist last clicked plan id (for top "Select" and subrows)
            const row = e.target.closest(".planrow");
            let pid = row ? Number(row.getAttribute("data-plan-id")) : NaN;

            if (!Number.isFinite(pid)) {
              // Fallback: read from existing href if present
              try {
                const u = new URL(a.href || "/checkout.html", location.href);
                pid = Number(u.searchParams.get("ratePlanId"));
              } catch (_) {}
            }

            if (Number.isFinite(pid)) {
              localStorage.setItem("rateplan.lastPlanId", String(pid));
            }

            // 2) Read selectedIds so we can preserve &plans=<csv>
            const sel = (() => {
              try {
                const raw = localStorage.getItem("rateplan.selectedIds") || "[]";
                const arr = JSON.parse(raw);
                return Array.isArray(arr)
                  ? [...new Set(arr.map(Number).filter(Number.isFinite))]
                  : [];
              } catch {
                return [];
              }
            })();

            // 3) Only tweak the plans param. Do NOT touch propertyId here.
            const url = new URL(a.href || "/checkout.html", location.href);

            if (sel.length) {
              url.searchParams.set("plans", sel.join(","));
            }

            a.setAttribute("href", url.toString());

            console.log("[details→checkout] click rewrite (plans only)", {
              href: url.toString()
            });
          } catch (err) {
            console.warn("[details→checkout] click handler failed", err);
          }
        });

        /* Repaint sub-rows if plans changed while away (hub -> back) — delegate to partner hydration */
        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState !== 'visible') return;
          try {
            // Re-run the authoritative partner hydrate instead of repainting from the local fallback.
            hydratePlansFromPartners?.();
          } catch (_) {
            // no-op
          }
        });
      })();
    }

    // ANCHOR: ROOM_MODAL_SUMMARY_TOGGLE
    (function attachRoomModalSummaryToggle(){
      const info    = document.querySelector(".room-modal-info");
      const summary = document.getElementById("roomModalSummary");
      const btn     = document.getElementById("roomModalReadMore");

      if (!info || !summary || !btn) return;

      // Rough heuristic so we only show "Read more" when it is actually long.
      const MIN_LEN_FOR_TOGGLE = 260;

      function applyClamp(){
        const text = (summary.textContent || "").trim();

        // No text or very short text → no clamp, no button
        if (!text || text.length < MIN_LEN_FOR_TOGGLE){
          summary.classList.remove("is-clamped");
          info.classList.remove("is-expanded");
          btn.hidden = true;
          btn.textContent = "Read more";
          return;
        }

        // Long text → clamp by default, show button
        summary.classList.add("is-clamped");
        info.classList.remove("is-expanded");
        btn.hidden = false;
        btn.textContent = "Read more";
      }

      btn.addEventListener("click", () => {
        const expanded = info.classList.toggle("is-expanded");

        if (expanded){
          summary.classList.remove("is-clamped");
          btn.textContent = "Show less";
        } else {
          summary.classList.add("is-clamped");
          btn.textContent = "Read more";
        }
      });

      // If other code fills in the summary later, this keeps clamp in sync
      const observer = new MutationObserver(applyClamp);
      observer.observe(summary, {
        childList: true,
        characterData: true,
        subtree: true
      });

      // Initial run for whatever text is there on first open
      applyClamp();
    })();

    /* ANCHOR: ROOM_MODAL_JS */
    (function(){
      const backdrop   = document.getElementById("roomModalBackdrop");
      const modalImg   = document.getElementById("roomModalHeroImg");
      const modalTitle = document.getElementById("roomModalTitle");
      const modalMeta  = document.getElementById("roomModalMeta");
      const thumbsWrap = document.getElementById("roomModalThumbs");
      const plansWrap  = document.getElementById("roomModalPlans");

      const modalSummary        = document.getElementById("roomModalSummary");
      const modalSpecs          = document.getElementById("roomModalSpecs");
      const detailsSection      = document.getElementById("roomModalDetailsSection");
      const detailsList         = document.getElementById("roomModalDetailsList");
      const inclusionsSection   = document.getElementById("roomModalInclusionsSection");
      const inclusionsList      = document.getElementById("roomModalInclusionsList");

      // ANCHOR: ROOM_MODAL_LIGHTBOX_JS
      const lightboxEl  = document.getElementById("roomModalLightbox");
      const lbBackdrop  = lightboxEl ? lightboxEl.querySelector(".room-modal-lightbox-backdrop") : null;
      const lbImg       = lightboxEl ? lightboxEl.querySelector(".room-modal-lightbox-img") : null;
      const lbCloseBtn  = lightboxEl ? lightboxEl.querySelector(".room-modal-lightbox-close") : null;
      const lbPrevBtn   = lightboxEl ? lightboxEl.querySelector(".room-modal-lightbox-prev") : null;
      const lbNextBtn   = lightboxEl ? lightboxEl.querySelector(".room-modal-lightbox-next") : null;

      let lbImages = [];
      let lbIndex  = 0;
      let lbBound  = false;

      function lbRender(){
        if (!lbImg || !lbImages.length) return;
        if (lbIndex < 0) lbIndex = 0;
        if (lbIndex >= lbImages.length) lbIndex = lbImages.length - 1;
        lbImg.src = lbImages[lbIndex];
      }

      function lbOpen(startIndex){
        if (!lightboxEl || !lbImages.length) return;
        if (Number.isFinite(startIndex)) {
          lbIndex = Math.min(Math.max(startIndex, 0), lbImages.length - 1);
        } else {
          lbIndex = 0;
        }
        lbRender();
        lightboxEl.classList.add("is-open");
        lightboxEl.setAttribute("aria-hidden","false");
      }

      function lbClose(){
        if (!lightboxEl) return;
        lightboxEl.classList.remove("is-open");
        lightboxEl.setAttribute("aria-hidden","true");
      }

      function lbStep(delta){
        if (!lbImages.length) return;
        const len = lbImages.length;
        lbIndex = (lbIndex + delta + len) % len;
        lbRender();
      }

      function lbBindOnce(){
        if (lbBound || !lightboxEl) return;
        lbBound = true;

        if (lbCloseBtn) {
          lbCloseBtn.addEventListener("click", lbClose);
        }

        if (lbBackdrop) {
          lbBackdrop.addEventListener("click", lbClose);
        }

        if (lbPrevBtn) {
          lbPrevBtn.addEventListener("click", () => lbStep(-1));
        }

        if (lbNextBtn) {
          lbNextBtn.addEventListener("click", () => lbStep(1));
        }

        // Basic swipe support
        let touchStartX = null;
        lightboxEl.addEventListener("touchstart", (e) => {
          if (e.touches && e.touches.length === 1) {
            touchStartX = e.touches[0].clientX;
          }
        }, { passive: true });

        lightboxEl.addEventListener("touchend", (e) => {
          if (touchStartX == null || !e.changedTouches || !e.changedTouches.length) return;
          const dx = e.changedTouches[0].clientX - touchStartX;
          touchStartX = null;
          if (Math.abs(dx) < 40) return; // ignore tiny swipes
          if (dx < 0) {
            lbStep(1);   // swipe left -> next
          } else {
            lbStep(-1);  // swipe right -> prev
          }
        }, { passive: true });

        // Keyboard support when lightbox is open
        document.addEventListener("keydown", (e) => {
          if (!lightboxEl.classList.contains("is-open")) return;
          if (e.key === "Escape") {
            lbClose();
          } else if (e.key === "ArrowRight") {
            lbStep(1);
          } else if (e.key === "ArrowLeft") {
            lbStep(-1);
          }
        });
      }

      if (!backdrop) return;

      // Global label maps for amenities bubble (same mapping as room modal)
      const DETAIL_LABELS = {
        // Views / position
        city_view:            "City view",
        sea_view:             "Sea / ocean view",
        garden_view:          "Garden view",
        pool_view:            "Pool view",
        high_floor:           "High floor",

        // Legacy position flags (kept so old data still renders)
        ground_floor:         "Ground floor",
        connecting:           "Connecting rooms available",
        accessible:           "Accessible room",

        // Beds
        bed_king:             "King bed",
        bed_queen:            "Queen bed",
        bed_double:           "Double bed",
        bed_single_twin:      "Single or twin bed",
        bed_bunk:             "Bunk bed",
        bed_sofa:             "Sofa bed",

        // Layout / private spaces
        balcony_terrace:      "Balcony or terrace",
        separate_living:      "Separate living area",
        kitchenette:          "Kitchenette",
        full_kitchen:         "Full kitchen",
        private_pool:         "Private pool",

        // In-room amenities
        air_conditioning:     "Air conditioning",
        tv_streaming:         "TV with streaming",
        refrigerator:         "Refrigerator",
        work_desk:            "Work desk",
        inroom_safe:          "In-room safe",

        // Bathroom / family
        bathtub:              "Bathtub",
        bidet:                "Bidet",
        crib_available:       "Crib or baby cot available",
        handicap_accessible:  "Handicap accessible room",
      };

      const INCLUSION_LABELS = {
        // New inclusions / facilities
        breakfast_included:    "Breakfast included (no added cost)",
        kids_free_under12:     "Kids stay free under 12",
        free_wifi:             "Free Wi-Fi",
        free_parking:          "Free parking",
        airport_shuttle:       "Airport shuttle",
        daily_housekeeping:    "Daily housekeeping",

        facility_pool:         "Swimming pool",
        facility_gym:          "Gym or fitness center",
        facility_spa_sauna:    "Spa or sauna",
        beachfront_access:     "Beachfront or direct beach access",
        watersports_equipment: "Water sports equipment (kayak / paddleboard / snorkel)",

        frontdesk_24h:         "24-hour front desk",
        family_friendly:       "Family / child-friendly property",
        nonsmoking_property:   "Non-smoking property",
        smoking_area:          "Smoking area",
        pets_allowed:          "Pets allowed",
        disabled_facilities:   "Facilities for disabled guests",

        business_center:       "Business center or meeting rooms",
        shared_kitchen:        "Shared kitchen or guest pantry",
        laundry:               "Laundry service or self-service laundry",
        onsite_restaurant:     "On-site restaurant",

        eco_cleaning:          "Eco-cleaning option (reduced housekeeping)",
        quiet_hours:           "Quiet hours enforced",
        crib_guaranteed:       "Guaranteed crib or baby cot",
        flexible_self_checkin: "Flexible self check-in (lockbox / smart lock)",

        // Legacy inclusion flags (kept so old data still renders)
        breakfast:             "Breakfast included",
        half_board:            "Half board",
        full_board:            "Full board",
        all_inclusive:         "All inclusive",
        late_checkout:         "Late checkout (subject to availability)",
        early_checkin:         "Early check-in (subject to availability)",
        pool_access:           "Pool access",
        spa_access:            "Spa / wellness access",
      };

      // Canonical 3 plans only: 1 = Standard, 2 = With Breakfast, 3 = Non-Refundable
      function getModalSelectedPlanIds(){
        let ids = [];

        // 1) localStorage from partners_rooms (canonical)
        try {
          const raw = localStorage.getItem('rateplan.selectedIds') || '[]';
          const arr = JSON.parse(raw);
          if (Array.isArray(arr)) ids = arr.map(Number).filter(n => Number.isFinite(n) && n > 0);
        } catch (_) {
          ids = [];
        }

        // 2) URL (?plans=8,18,23 or ?ratePlanId=18)
        if (!ids.length){
          try {
            const qs  = new URLSearchParams(location.search || '');
            const csv = (qs.get('plans') || '').trim();
            if (csv){
              ids = csv.split(',').map(s => Number(String(s).trim())).filter(n => Number.isFinite(n) && n > 0);
            } else {
              const single = Number(qs.get('ratePlanId') || qs.get('plan'));
              if (Number.isFinite(single) && single > 0) ids = [single];
            }
          } catch(_){}
        }

        // 3) Fallback to lastPlanId
        if (!ids.length){
          try {
            const last = Number(localStorage.getItem('rateplan.lastPlanId'));
            if (Number.isFinite(last) && last > 0) ids = [last];
          } catch(_){}
        }

        // Dedupe, preserve order
        const seen = new Set();
        const out = [];
        for (let i = 0; i < ids.length; i++){
          const id = Number(ids[i]);
          if (!Number.isFinite(id) || id <= 0) continue;
          if (seen.has(id)) continue;
          seen.add(id);
          out.push(id);
        }
        return out;
      }

      function getModalPlanLabel(id){
        const rid = String(id);
        const meta = (window.__ratePlanMetaById && window.__ratePlanMetaById[rid]) ? window.__ratePlanMetaById[rid] : null;

        // Prefer partner-provided custom labels by CODE (STD/BRKF/NRF/CUS1/CUS2)
        let labels = null;
        try {
          labels = JSON.parse(localStorage.getItem('rateplan.customLabels') || '{}') || {};
        } catch(_){
          labels = {};
        }

        const code = String(meta && meta.code ? meta.code : '').toUpperCase();

        if (code && labels && typeof labels === 'object' && labels[code]) {
          return String(labels[code]);
        }

        if (code === 'STD')  return 'Standard';
        if (code === 'BRKF') return 'With Breakfast';
        if (code === 'NRF')  return 'Non-Refundable';

        if (meta && meta.name) return String(meta.name);
        return `Plan ${id}`;
      }

      function getModalPlanDescription(id){
        const rid = String(id);
        const meta = (window.__ratePlanMetaById && window.__ratePlanMetaById[rid]) ? window.__ratePlanMetaById[rid] : null;
        const code = String(meta && meta.code ? meta.code : '').toUpperCase();

        if (code === 'STD')  return 'Flexible standard rate with free cancellation.';
        if (code === 'BRKF') return 'This rate includes breakfast for 2.';
        if (code === 'NRF')  return 'Lower price, no refunds or changes.';
        if (code === 'CUS1' || code === 'CUS2') return 'Special rate.';

        return 'Standard conditions apply for this rate.';
      }

      function fillList(ul, labels, extraText) {
        if (!ul) return;
        while (ul.firstChild) ul.removeChild(ul.firstChild);

        (labels || []).forEach(lbl => {
          if (!lbl) return;
          const li = document.createElement("li");
          li.textContent = lbl;
          ul.appendChild(li);
        });

        if (extraText && String(extraText).trim()) {
          const li = document.createElement("li");
          li.textContent = String(extraText).trim();
          ul.appendChild(li);
        }
      }

      function normalizeRoomImages(room){
        let imgs = [];
        if (Array.isArray(room?.images)) {
          imgs = room.images
            .map(it => typeof it === "string"
              ? it
              : (it.url || it.photoUrl || it.imageUrl || it.src || it.href))
            .filter(Boolean);
        }

        if (!imgs.length) {
          const payload = window.__detailsPayload || {};
          if (Array.isArray(payload.images)) {
            imgs = payload.images
              .map(it => typeof it === "string"
                ? it
                : (it.url || it.photoUrl || it.imageUrl || it.src || it.href))
              .filter(Boolean);
          }
        }

        if (!imgs.length) {
          imgs = [ getPlaceholderSVG("No photo available") ];
        }
        return imgs;
      }

      function applyPlanRule(basePrice, plan){
        const base = Number(basePrice);
        if (!Number.isFinite(base)) return null;

        const kind = String(plan?.kind || 'NONE').toUpperCase();
        const rawVal = (plan?.value == null) ? 0 : Number(plan.value);
        const val = Number.isFinite(rawVal) ? rawVal : 0;

        if (kind === 'ABSOLUTE') return Math.max(0, base + val);
        if (kind === 'PERCENT')  return Math.max(0, base * (1 + (val / 100)));
        return Math.max(0, base);
      }

      function openRoomModal(room){
        if (!room) return;

        // Title
        modalTitle.textContent = room.name || "Room";

        // Size and specs (use new fields first, fall back to old ones)
        const sizeSqm  = room.size_sqm ?? room.areaM2 ?? room.areaSqm ?? null;
        const sizeSqft = room.size_sqft ?? (sizeSqm ? Math.round(sizeSqm * 10.7639) : (room.areaFt2 ?? null));
        const sizeTxt = sizeSqm
          ? `${sizeSqm} m² / ${sizeSqft} ft²`
          : (sizeSqft ? `${sizeSqft} ft²` : "");

        const maxGuests = room.maxGuests ?? room.occupancy ?? null;
        const specsParts = [];
        if (maxGuests) specsParts.push(`Sleeps up to ${maxGuests} guests`);
        if (sizeTxt)   specsParts.push(sizeTxt);

        if (modalMeta) {
          // Keep a simple, always-present line
          modalMeta.textContent = sizeTxt || "";
        }
        if (modalSpecs) {
          const txt = specsParts.join(" • ");
          modalSpecs.textContent = txt;
          modalSpecs.style.display = txt ? "" : "none";
        }

        // Summary
        if (modalSummary) {
          const s = (room.summary || "").trim();
          modalSummary.textContent = s;
          modalSummary.style.display = s ? "" : "none";

          // Ensure the Read more clamp is recalculated after we write text
          if (typeof refreshRoomDescClamp === "function") {
            refreshRoomDescClamp();
          }
        }

        // Details and inclusions from keys + free text
        const detailKeys = Array.isArray(room.details_keys) ? room.details_keys : [];
        const inclusionKeys =
          (Array.isArray(room.inclusion_keys) && room.inclusion_keys) ||
          (Array.isArray(room.inclusionKeys) && room.inclusionKeys) ||
          (Array.isArray(room?.meta?.inclusion_keys) && room.meta.inclusion_keys) ||
          (Array.isArray(room?.meta?.inclusionKeys) && room.meta.inclusionKeys) ||
          [];
        const detailLabels = detailKeys.map(k => DETAIL_LABELS[k]).filter(Boolean);
        const inclusionLabels = inclusionKeys.map(k => INCLUSION_LABELS[k]).filter(Boolean);

        if (detailsSection) {
          const hasAny = detailLabels.length || (room.details_text && String(room.details_text).trim());
          detailsSection.style.display = hasAny ? "" : "none";
          if (hasAny) fillList(detailsList, detailLabels, room.details_text);
        }

        if (inclusionsSection) {
          const hasAny = inclusionLabels.length || (room.inclusion_text && String(room.inclusion_text).trim());
          inclusionsSection.style.display = hasAny ? "" : "none";
          if (hasAny) fillList(inclusionsList, inclusionLabels, room.inclusion_text);
        }

        // Images + lightbox + hover hero update
        const imgs = normalizeRoomImages(room);

        if (!imgs.length) {
          if (modalImg) {
            modalImg.removeAttribute("src");
          }
          if (thumbsWrap) {
            thumbsWrap.innerHTML = "";
          }
        } else {
          if (modalImg) {
            modalImg.src = imgs[0];
            modalImg.style.cursor = "zoom-in";
          }

          // Share images with lightbox
          lbImages = imgs.slice();
          lbBindOnce();
          lbIndex = 0;
          lbRender();

          // Build thumbnails
          thumbsWrap.innerHTML = imgs.map((src, i) => `
            <button type="button" data-i="${i}" aria-current="${i === 0 ? "true" : "false"}">
              <img src="${src}" alt="Photo ${i+1}">
            </button>
          `).join("");

          const thumbButtons = thumbsWrap.querySelectorAll("button");

          thumbButtons.forEach(btn => {
            const idx = Number(btn.dataset.i || "0");

            // Hover: update hero + selected index
            btn.addEventListener("mouseenter", () => {
              if (!imgs.length) return;
              const safeIdx = Number.isFinite(idx) ? idx : 0;
              lbIndex = safeIdx;
              modalImg.src = imgs[safeIdx] || imgs[0];
              thumbButtons.forEach(b => b.removeAttribute("aria-current"));
              btn.setAttribute("aria-current","true");
            });

            // Click: open lightbox at that image
            btn.addEventListener("click", () => {
              if (!imgs.length) return;
              const safeIdx = Number.isFinite(idx) ? idx : 0;
              lbIndex = safeIdx;
              lbOpen(safeIdx);
            });
          });

          // Hero click opens lightbox at current image
          if (modalImg) {
            modalImg.onclick = () => {
              if (!lbImages.length) return;
              lbOpen(lbIndex);
            };
          }
        }

        // If partner plan hydrate hasn't populated this room yet, trigger it once (non-blocking)
        try {
          const ridKey = String(room?.roomTypeId ?? room?.roomId ?? room?.id ?? "");
          if (ridKey && (!window.__ratePlansByRoom || !window.__ratePlansByRoom[ridKey])) {
            setTimeout(() => { try { window.hydratePlansFromPartners?.(); } catch(_){} }, 0);
          }
        } catch(_){}

        // Rate plans – 3 canonical plans, horizontal pills with Select buttons
        try {
          if (plansWrap) {
            plansWrap.innerHTML = "";

            const payload    = window.__detailsPayload || {};
            const propertyId = payload.propertyId ?? payload.id ?? "";
            const roomId     = room.roomTypeId ?? room.typeId ?? room.id ?? room.roomId ?? room.code ?? "";

            // Reuse same helpers as inline plan rows
            const { propertyName, propertyLocation } = getCheckoutMeta();
            const roomName = getRoomNameForCheckout(roomId);

            // Use DB-active plans for this room (same truth as inline)
            const ridKey = String(roomId);
            const roomPlans = (window.__ratePlansByRoom && Array.isArray(window.__ratePlansByRoom[ridKey]))
              ? window.__ratePlansByRoom[ridKey]
              : [];

            const ids = roomPlans.length
              ? roomPlans.filter(p => p && p.active === true).map(p => Number(p.id)).filter(Number.isFinite)
              : getModalSelectedPlanIds(); // fallback only

            const plansQS = ids.length ? `&plans=${encodeURIComponent(ids.join(','))}` : '';

            ids.forEach(id => {
              if (!Number.isFinite(id)) return;

              const label = getModalPlanLabel(id);
              const desc  = getModalPlanDescription(id);

              const url =
                `/checkout.html?propertyId=${encodeURIComponent(propertyId)}` +
                `&propertyName=${encodeURIComponent(propertyName)}` +
                (propertyLocation ? `&propertyLocation=${encodeURIComponent(propertyLocation)}` : '') +
                `&roomId=${encodeURIComponent(roomId)}` +
                `&roomName=${encodeURIComponent(roomName)}` +
                `&start=${encodeURIComponent(start)}` +
                `&end=${encodeURIComponent(end)}` +
                `&ratePlanId=${encodeURIComponent(id)}` +
                `&planLabel=${encodeURIComponent(label)}` +
                plansQS;

              const pill = document.createElement("div");
              pill.className = "room-modal-plan-pill";

              // Price: base (Standard) + apply plan rule (kind/value)
              let priceHtml = "";
              try {
                // Resolve plan meta for this id (kind/value)
                const meta =
                  (window.__ratePlanMetaById && window.__ratePlanMetaById[String(id)]) ||
                  null;

                const planObj = meta || { id, code: '', kind: 'NONE', value: 0 };

                // Resolve Standard plan id for this room
                const stdId = (() => {
                  try {
                    const byRoom = window.__ratePlansByRoom && window.__ratePlansByRoom[String(roomId)];
                    if (Array.isArray(byRoom)) {
                      const std = byRoom.find(x => String(x.code || '').toUpperCase() === 'STD');
                      const n = Number(std && std.id);
                      if (Number.isFinite(n)) return n;
                    }
                  } catch(_) {}
                  return Number(id);
                })();

                // Base = Standard nightly, fallback to this plan's nightly if STD missing
                if (!Number.isFinite(Number(stdId))) stdId = Number(id);

                let baseRaw = getPlanPriceForRoom(roomId, stdId);
                if (!(baseRaw != null && Number.isFinite(Number(baseRaw)))) {
                  baseRaw = getPlanPriceForRoom(roomId, Number(id));
                }

                const baseOk = baseRaw != null && Number.isFinite(Number(baseRaw));
                const adjRaw = baseOk ? applyPlanRule(Number(baseRaw), planObj) : null;

                const hasPrice = adjRaw != null && Number.isFinite(Number(adjRaw));
                if (hasPrice) {
                  priceHtml = `<div class="room-modal-plan-pill-price">${money(Number(adjRaw).toFixed(2))} / night</div>`;
                } else {
                  priceHtml = `<div class="room-modal-plan-pill-price">Price unavailable</div>`;
                }
              } catch (err) {
                console.warn("[room-modal] price calc failed", err);
                priceHtml = `<div class="room-modal-plan-pill-price">Price unavailable</div>`;
              }

              // availability for the stay (backend rollup already present on room in your payload)
              const maxAvail = Math.max(0, Number(
                room.availabilitySummary?.availableRooms ??
                room.availableRooms ??
                0
              ) || 0);

              // read previously saved qty for this room+plan from checkout.selection.v1
              let savedQty = 0;
              try{
                const sel = JSON.parse(localStorage.getItem("checkout.selection.v1") || "null");
                const items = Array.isArray(sel?.items) ? sel.items : [];
                const hit = items.find(it =>
                  String(it.roomTypeId ?? it.roomId) === String(roomId) &&
                  String(it.ratePlanId ?? it.planId) === String(id)
                );
                savedQty = Math.max(0, Number(hit?.qty || 0) || 0);
              }catch(_){ savedQty = 0; }

              savedQty = Math.min(savedQty, maxAvail);

              const rawSaved = Number(savedQty);
              const normQty =
                Number.isFinite(rawSaved) && rawSaved > 0
                  ? Math.min(rawSaved, maxAvail)
                  : (maxAvail > 0 ? 1 : 0);

              const opts = Array.from({ length: maxAvail + 1 }, (_, i) => i)
                .map(i => `<option value="${i}" ${i === normQty ? "selected" : ""}>${i}</option>`)
                .join("");

              pill.innerHTML =
                `<div class="room-modal-plan-pill-title">${label}</div>
                <div class="room-modal-plan-pill-desc">${desc}</div>
                ${priceHtml}

                <div class="plan-actions">
                  <div class="qty-inline">
                    <div class="qty-avail">Available Rooms:  <span class="qty-avail-val">${maxAvail}</span></div>

                    <div class="qty-pick">
                      <span class="qty-label">Qty</span>
                      <select
                        class="qty-select room-modal-qty"
                        data-room-id="${roomId}"
                        data-plan-id="${id}"
                        data-max="${maxAvail}"
                      >
                        ${opts}
                      </select>
                    </div>
                  </div>

                  <a class="room-modal-plan-pill-btn"
                      href="${url}${url.includes('?') ? '&' : '?'}qty=${encodeURIComponent(normQty)}"
                      aria-label="Book ${label} now">
                      Book now
                  </a>
                </div>`;

              plansWrap.appendChild(pill);

              // wire qty change for this pill (persist + update href)
              const qtySel = pill.querySelector("select.room-modal-qty");
              if (qtySel){
                qtySel.addEventListener("change", () => {
                  const roomId2 = String(qtySel.getAttribute("data-room-id") || "");
                  const planId2 = String(qtySel.getAttribute("data-plan-id") || "");
                  const max2 = Math.max(0, Number(qtySel.getAttribute("data-max") || 0) || 0);
                  const qty2 = Math.min(max2, Math.max(0, Number(qtySel.value || 0) || 0));

                  // update link
                  const a = pill.querySelector("a.room-modal-plan-pill-btn");
                  if (a){
                    const href = a.getAttribute("href") || "";
                    const base = href.replace(/([?&])qty=\d+(&?)/, (m,p1,p2)=> (p2 ? p1 : ""));
                    const join = base.includes("?") ? "&" : "?";
                    a.setAttribute("href", `${base}${join}qty=${encodeURIComponent(qty2)}`);
                  }

                  // persist to checkout.selection.v1 (same format you already use inline)
                  try{
                    const selKey = "checkout.selection.v1";
                    let selObj = null;
                    try { selObj = JSON.parse(localStorage.getItem(selKey) || "null"); } catch(_) { selObj = null; }
                    if (!selObj || typeof selObj !== "object") selObj = { propertyId: String(propertyId), start: String(start), end: String(end), items: [] };

                    selObj.propertyId = String(propertyId);
                    selObj.start = String(start);
                    selObj.end = String(end);
                    if (!Array.isArray(selObj.items)) selObj.items = [];

                    const idx = selObj.items.findIndex(it =>
                      String(it.roomTypeId ?? it.roomId) === roomId2 &&
                      String(it.ratePlanId ?? it.planId) === planId2
                    );

                    if (qty2 <= 0){
                      if (idx >= 0) selObj.items.splice(idx, 1);
                    } else {
                      const item = {
                        roomTypeId: roomId2,
                        ratePlanId: planId2,
                        qty: qty2,
                        roomName: String(roomName || ""),
                        planLabel: String(label || "")
                      };
                      if (idx >= 0) selObj.items[idx] = item;
                      else selObj.items.push(item);
                    }

                    localStorage.setItem(selKey, JSON.stringify(selObj));
                    console.log("[details][qty][persist] saved", selObj);
                  }catch(e){
                    console.warn("[details][qty][persist] failed", e);
                  }
                });
              }
            });
          }
        } catch (_) {}
        // Always open at the top (mobile frequently lands near the bottom otherwise)
        try {
          const body = backdrop.querySelector(".room-modal-body");
          if (body) body.scrollTop = 0;
        } catch (_) {}

        // Mobile: prevent auto-scroll into the rate plan section.
        // Always open modal at the top and focus the close button without scrolling.
        try {
          const body = backdrop.querySelector(".room-modal-body");
          if (body) {
            body.scrollTop = 0;
          }

          // After the modal becomes visible, mobile browsers may still auto-scroll.
          requestAnimationFrame(() => {
            try {
              const body2 = backdrop.querySelector(".room-modal-body");
              if (body2) body2.scrollTop = 0;

              const closeBtn = backdrop.querySelector(".room-modal-close");
              if (closeBtn && closeBtn.focus) closeBtn.focus({ preventScroll: true });
            } catch (_) {}
          });

          setTimeout(() => {
            try {
              const body3 = backdrop.querySelector(".room-modal-body");
              if (body3) body3.scrollTop = 0;

              const closeBtn2 = backdrop.querySelector(".room-modal-close");
              if (closeBtn2 && closeBtn2.focus) closeBtn2.focus({ preventScroll: true });
            } catch (_) {}
          }, 0);
        } catch (_) {}

        backdrop.classList.add("is-open");
        backdrop.setAttribute("aria-hidden","false");
      }

      function openRoomModalById(roomId){
        const payload = window.__detailsPayload || {};
        const rooms   = Array.isArray(payload.rooms) ? payload.rooms : [];
        const ridStr  = String(roomId);
        const room    = rooms.find(r => String(
          r.roomTypeId ?? r.typeId ?? r.id ?? r.roomId ?? r.code
        ) === ridStr);

        if (room) openRoomModal(room);
      }

      window.openRoomModal    = openRoomModal;
      window.openRoomModalById = openRoomModalById;

      function closeModal(){
        backdrop.classList.remove("is-open");
        backdrop.setAttribute("aria-hidden","true");
      }

      backdrop.addEventListener("click", (e) => {
        if (e.target === backdrop) closeModal();
      });

      const closeBtn = document.querySelector(".room-modal-close");
      if (closeBtn){
        closeBtn.addEventListener("click", closeModal);
      }

      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && backdrop.classList.contains("is-open")) {
          closeModal();
        }
      });
    })();

    /* ANCHOR: TOAST_JS_HELPER */
    function showToast(msg, ms=1600){
      let t = document.querySelector('.toast');
      if (!t){
        t = document.createElement('div');
        t.className = 'toast';
        t.setAttribute('role', 'status');
        t.setAttribute('aria-live', 'polite');
        document.body.appendChild(t);
      }
      t.textContent = msg;
      void t.offsetWidth; // restart transition
      t.classList.add('show');
      clearTimeout(t._hideTimer);
      t._hideTimer = setTimeout(()=>{ t.classList.remove('show'); }, ms);
    }

    load().catch(err=>{
      console.error(err);
      showToast('Failed to load details');

      detailsLoadingOff();

      // Stop the hero shimmer and show a neutral placeholder
      if (heroWrap) heroWrap.classList.remove('is-loading');
      const heroEl = document.getElementById('hero-img');
      if (heroEl) {
        const ph = getPlaceholderSVG('Photo failed to load');
        heroEl.src = ph;
        heroEl.removeAttribute('srcset');
        heroEl.removeAttribute('sizes');
        heroEl.alt = 'Photo failed to load';
      }
    });
    // ANCHOR: ROOM_INFO_EXPORT
    async function exportRoomInfoMock(){
      try{
        const blob = new Blob([JSON.stringify(roomInfoById, null, 2)], {type: 'application/json'});
        const fileHandle = await window.showSaveFilePicker({
          suggestedName: '_room_info_mock.json',
          types: [{ description: 'JSON', accept: {'application/json': ['.json']} }]
        });
        const writable = await fileHandle.createWritable();
        await writable.write(blob);
        await writable.close();
        alert("Saved _room_info_mock.json — upload this to /public/_mock/ in lolaelo-api.");
      }catch(_){}
    }

    // Simple UI to export manually (kept hidden)
    window.exportRoomInfoMock = exportRoomInfoMock;

  </script>

  <!-- ANCHOR: SCROLLTOP_HTML -->
  <button id="scrollTopBtn" class="scrolltop-btn" aria-label="Scroll to top" title="Back to top">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true">
      <path d="M6 14l6-6 6 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
  </button>
  <script>
    // ANCHOR: SCROLLTOP_JS
    (function () {
      const btn = document.getElementById('scrollTopBtn');
      if (!btn) return;

      const prefersReduced =
        window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      const hero = document.querySelector('.hero, #hero, .gallery-hero');
      const baselinePx = 400;
      const threshold = () => {
        if (!hero) return baselinePx;
        const rect = hero.getBoundingClientRect();
        const pageY = window.scrollY + rect.top + rect.height; // bottom of hero
        return Math.max(pageY * 0.02, Math.min(pageY, 800));
      };

      let ticking = false;
      const onScroll = () => {
        if (ticking) return;
        ticking = true;
        requestAnimationFrame(() => {
          const show = window.scrollY > threshold();
          btn.classList.toggle('show', show);
          ticking = false;
        });
      };

      window.addEventListener('scroll', onScroll, { passive: true });
      window.addEventListener('resize', onScroll);

      btn.addEventListener('click', (e) => {
        e.preventDefault();
        try {
          window.scrollTo({ top: 0, behavior: prefersReduced ? 'auto' : 'smooth' });
        } catch {
          document.documentElement.scrollTop = 0;
          document.body.scrollTop = 0;
        }
      });

      onScroll();
    })();
</script>

  <!-- PARTNER BADGE & IMAGE FALLBACK (insert above </body>) -->
  <script>
  (function () {
    const qs = new URLSearchParams(location.search);
    const pid = Number(qs.get("propertyId"));
    const start = qs.get("start") || "";
    const end = qs.get("end") || "";
    if (!Number.isFinite(pid) || !start || !end) return;
    // If the main loader already rendered images, skip this fallback.
    const __thumbs = document.getElementById("thumbs");
    const __heroImg = document.getElementById("hero-img");
    if (__thumbs && __thumbs.children.length > 0 && __heroImg && __heroImg.src) return;

    const placeholder = "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1200 800'><defs><linearGradient id='g' x1='0' y1='0' x2='1' y2='1'><stop offset='0%' stop-color='%23e5e7eb'/><stop offset='100%' stop-color='%23c7d2fe'/></linearGradient></defs><rect width='1200' height='800' fill='url(%23g)'/><g fill='%239ca3af' font-family='system-ui,Segoe UI,Roboto,Helvetica,Arial' text-anchor='middle'><text x='600' y='420' font-size='56'>No photo</text><text x='600' y='470' font-size='28'>Partner provides images in Extranet</text></g></svg>";

    fetch(`/catalog/details?propertyId=${pid}&start=${encodeURIComponent(start)}&end=${encodeURIComponent(end)}`)
      .then(r => r.ok ? r.json() : {})
      .then(d => {
        // 1) Hero image fallback (if your page has an <img> for cover)
        const hero = document.getElementById("hero-img");
        const first = Array.isArray(d?.images) && d.images.length ? d.images[0] : null;
        if (hero) {
          hero.src = first || placeholder;
          hero.alt = d?.name || "Property";
        } else if (first) {
          // If no hero container exists, inject a simple one up top
          const img = document.createElement("img");
          img.src = first; img.alt = d?.name || "Property";
          img.style.cssText = "width:100%;max-height:360px;object-fit:cover;border-radius:12px;margin:8px 0";
          document.body.insertBefore(img, document.body.firstChild);
        }
      })
      .catch(()=>{});
  })();

  // ANCHOR: DETAILS_SCROLL_GUARD
  (function setupScrollGuard() {
    // Log what happens on load
    window.addEventListener("load", function () {
      console.log("[details] scroll on load:", window.scrollX, window.scrollY);
      if (window.scrollX !== 0) {
        window.scrollTo(0, window.scrollY || 0);
      }
    });

    // Any time the page scrolls, clamp horizontal scroll back to 0
    window.addEventListener("scroll", function () {
      if (window.scrollX !== 0) {
        console.log("[details] correcting scrollX from", window.scrollX, "to 0");
        window.scrollTo(0, window.scrollY || 0);
      }
    }, { passive: true });
  })();
  </script>

  <script>
  // === Date Guardrails (no past dates) ===
  function parseYmd(s){
    // Accepts YYYY-MM-DD only
    const m = String(s || "").trim().match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (!m) return null;
    const y = Number(m[1]), mo = Number(m[2]), d = Number(m[3]);
    const dt = new Date(y, mo - 1, d);
    // Validate rollover
    if (dt.getFullYear() !== y || (dt.getMonth() + 1) !== mo || dt.getDate() !== d) return null;
    // Normalize to local midnight
    dt.setHours(0,0,0,0);
    return dt;
  }

  function todayLocal(){
    const t = new Date();
    t.setHours(0,0,0,0);
    return t;
  }

  function validateStayDates(startStr, endStr){
    const start = parseYmd(startStr);
    const end = parseYmd(endStr);
    const t = todayLocal();

    if (!start || !end) return { ok:false, reason:"invalid_format" };
    if (end.getTime() <= start.getTime()) return { ok:false, reason:"end_before_start" };
    if (start.getTime() < t.getTime()) return { ok:false, reason:"start_in_past" };
    // Optional hard rule: disallow checkout in past too (covered by start rule, but explicit)
    if (end.getTime() < t.getTime()) return { ok:false, reason:"end_in_past" };

    return { ok:true };
  }

  function setBtnEnabled(btn, enabled){
    if (!btn) return;
    btn.disabled = !enabled;
    btn.style.opacity = enabled ? "" : "0.55";
    btn.style.pointerEvents = enabled ? "" : "none";
  }

  function showDateError(containerEl, msg){
    if (!containerEl) return;
    let el = containerEl.querySelector(".date-guard-error");
    if (!el){
      el = document.createElement("div");
      el.className = "date-guard-error";
      el.style.marginTop = "10px";
      el.style.color = "#b91c1c";
      el.style.fontSize = "13px";
      el.style.fontWeight = "600";
      containerEl.appendChild(el);
    }
    el.textContent = msg || "";
    el.style.display = msg ? "block" : "none";
  }

  function guardDatesOrDisable(opts){
    // opts: { startStr, endStr, btns: [..], containerEl }
    const v = validateStayDates(opts.startStr, opts.endStr);
    const ok = !!v.ok;

    for (const b of (opts.btns || [])) setBtnEnabled(b, ok);

    if (ok){
      showDateError(opts.containerEl, "");
      return true;
    }

    const msg =
      v.reason === "start_in_past" ? "Check-in date cannot be in the past." :
      v.reason === "end_before_start" ? "Check-out must be after check-in." :
      v.reason === "invalid_format" ? "Invalid date format." :
      "Invalid dates.";

    showDateError(opts.containerEl, msg);
    return false;
  }
</script>

</body>
</html>
